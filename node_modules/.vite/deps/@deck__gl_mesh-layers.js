import {
  require_earcut
} from "./chunk-S4TZEJPJ.js";
import {
  Accessor,
  Buffer,
  COORDINATE_SYSTEM,
  FEATURES,
  Geometry,
  Layer,
  Model,
  Texture2D,
  assert,
  createIterable,
  hasFeature,
  isWebGL2,
  log,
  log_default,
  pbr,
  phongLighting,
  picking_default,
  project32_default,
  uid
} from "./chunk-6SHUHNLC.js";
import "./chunk-RNSZBP6P.js";
import {
  GLTFLoader,
  getMeshBoundingBox
} from "./chunk-SG55KEDB.js";
import {
  Matrix4,
  Quaternion,
  Vector3
} from "./chunk-ZXUHYV2Q.js";
import {
  _defineProperty
} from "./chunk-NVCU2VMH.js";
import {
  __toESM
} from "./chunk-BHN6OJC3.js";

// node_modules/@deck.gl/mesh-layers/dist/esm/utils/matrix.js
var RADIAN_PER_DEGREE = Math.PI / 180;
var modelMatrix = new Float32Array(16);
var valueArray = new Float32Array(12);
function calculateTransformMatrix(targetMatrix, orientation, scale) {
  const pitch = orientation[0] * RADIAN_PER_DEGREE;
  const yaw = orientation[1] * RADIAN_PER_DEGREE;
  const roll = orientation[2] * RADIAN_PER_DEGREE;
  const sr = Math.sin(roll);
  const sp = Math.sin(pitch);
  const sw = Math.sin(yaw);
  const cr = Math.cos(roll);
  const cp = Math.cos(pitch);
  const cw = Math.cos(yaw);
  const scx = scale[0];
  const scy = scale[1];
  const scz = scale[2];
  targetMatrix[0] = scx * cw * cp;
  targetMatrix[1] = scx * sw * cp;
  targetMatrix[2] = scx * -sp;
  targetMatrix[3] = scy * (-sw * cr + cw * sp * sr);
  targetMatrix[4] = scy * (cw * cr + sw * sp * sr);
  targetMatrix[5] = scy * cp * sr;
  targetMatrix[6] = scz * (sw * sr + cw * sp * cr);
  targetMatrix[7] = scz * (-cw * sr + sw * sp * cr);
  targetMatrix[8] = scz * cp * cr;
}
function getExtendedMat3FromMat4(mat4) {
  mat4[0] = mat4[0];
  mat4[1] = mat4[1];
  mat4[2] = mat4[2];
  mat4[3] = mat4[4];
  mat4[4] = mat4[5];
  mat4[5] = mat4[6];
  mat4[6] = mat4[8];
  mat4[7] = mat4[9];
  mat4[8] = mat4[10];
  mat4[9] = mat4[12];
  mat4[10] = mat4[13];
  mat4[11] = mat4[14];
  return mat4.subarray(0, 12);
}
var MATRIX_ATTRIBUTES = {
  size: 12,
  accessor: ["getOrientation", "getScale", "getTranslation", "getTransformMatrix"],
  shaderAttributes: {
    instanceModelMatrix__LOCATION_0: {
      size: 3,
      elementOffset: 0
    },
    instanceModelMatrix__LOCATION_1: {
      size: 3,
      elementOffset: 3
    },
    instanceModelMatrix__LOCATION_2: {
      size: 3,
      elementOffset: 6
    },
    instanceTranslation: {
      size: 3,
      elementOffset: 9
    }
  },
  update(attribute, {
    startRow,
    endRow
  }) {
    const {
      data,
      getOrientation,
      getScale,
      getTranslation,
      getTransformMatrix
    } = this.props;
    const arrayMatrix = Array.isArray(getTransformMatrix);
    const constantMatrix = arrayMatrix && getTransformMatrix.length === 16;
    const constantScale = Array.isArray(getScale);
    const constantOrientation = Array.isArray(getOrientation);
    const constantTranslation = Array.isArray(getTranslation);
    const hasMatrix = constantMatrix || !arrayMatrix && Boolean(getTransformMatrix(data[0]));
    if (hasMatrix) {
      attribute.constant = constantMatrix;
    } else {
      attribute.constant = constantOrientation && constantScale && constantTranslation;
    }
    const instanceModelMatrixData = attribute.value;
    if (attribute.constant) {
      let matrix;
      if (hasMatrix) {
        modelMatrix.set(getTransformMatrix);
        matrix = getExtendedMat3FromMat4(modelMatrix);
      } else {
        matrix = valueArray;
        const orientation = getOrientation;
        const scale = getScale;
        calculateTransformMatrix(matrix, orientation, scale);
        matrix.set(getTranslation, 9);
      }
      attribute.value = new Float32Array(matrix);
    } else {
      let i = startRow * attribute.size;
      const {
        iterable,
        objectInfo
      } = createIterable(data, startRow, endRow);
      for (const object of iterable) {
        objectInfo.index++;
        let matrix;
        if (hasMatrix) {
          modelMatrix.set(constantMatrix ? getTransformMatrix : getTransformMatrix(object, objectInfo));
          matrix = getExtendedMat3FromMat4(modelMatrix);
        } else {
          matrix = valueArray;
          const orientation = constantOrientation ? getOrientation : getOrientation(object, objectInfo);
          const scale = constantScale ? getScale : getScale(object, objectInfo);
          calculateTransformMatrix(matrix, orientation, scale);
          matrix.set(constantTranslation ? getTranslation : getTranslation(object, objectInfo), 9);
        }
        instanceModelMatrixData[i++] = matrix[0];
        instanceModelMatrixData[i++] = matrix[1];
        instanceModelMatrixData[i++] = matrix[2];
        instanceModelMatrixData[i++] = matrix[3];
        instanceModelMatrixData[i++] = matrix[4];
        instanceModelMatrixData[i++] = matrix[5];
        instanceModelMatrixData[i++] = matrix[6];
        instanceModelMatrixData[i++] = matrix[7];
        instanceModelMatrixData[i++] = matrix[8];
        instanceModelMatrixData[i++] = matrix[9];
        instanceModelMatrixData[i++] = matrix[10];
        instanceModelMatrixData[i++] = matrix[11];
      }
    }
  }
};
function shouldComposeModelMatrix(viewport, coordinateSystem) {
  return coordinateSystem === COORDINATE_SYSTEM.CARTESIAN || coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS || coordinateSystem === COORDINATE_SYSTEM.DEFAULT && !viewport.isGeospatial;
}

// node_modules/@deck.gl/mesh-layers/dist/esm/simple-mesh-layer/simple-mesh-layer-vertex.glsl.js
var simple_mesh_layer_vertex_glsl_default = "#version 300 es\n#define SHADER_NAME simple-mesh-layer-vs\nuniform float sizeScale;\nuniform bool composeModelMatrix;\nin vec3 positions;\nin vec3 normals;\nin vec3 colors;\nin vec2 texCoords;\nin vec3 instancePositions;\nin vec3 instancePositions64Low;\nin vec4 instanceColors;\nin vec3 instancePickingColors;\nin mat3 instanceModelMatrix;\nin vec3 instanceTranslation;\nout vec2 vTexCoord;\nout vec3 cameraPosition;\nout vec3 normals_commonspace;\nout vec4 position_commonspace;\nout vec4 vColor;\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  geometry.uv = texCoords;\n  geometry.pickingColor = instancePickingColors;\n\n  vTexCoord = texCoords;\n  cameraPosition = project_uCameraPosition;\n  vColor = vec4(colors * instanceColors.rgb, instanceColors.a);\n\n  vec3 pos = (instanceModelMatrix * positions) * sizeScale + instanceTranslation;\n\n  if (composeModelMatrix) {\n    DECKGL_FILTER_SIZE(pos, geometry);\n    normals_commonspace = project_normal(instanceModelMatrix * normals);\n    geometry.worldPosition += pos;\n    gl_Position = project_position_to_clipspace(pos + instancePositions, instancePositions64Low, vec3(0.0), position_commonspace);\n    geometry.position = position_commonspace;\n  }\n  else {\n    pos = project_size(pos);\n    DECKGL_FILTER_SIZE(pos, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, pos, position_commonspace);\n    geometry.position = position_commonspace;\n    normals_commonspace = project_normal(instanceModelMatrix * normals);\n  }\n\n  geometry.normal = normals_commonspace;\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n";

// node_modules/@deck.gl/mesh-layers/dist/esm/simple-mesh-layer/simple-mesh-layer-fragment.glsl.js
var simple_mesh_layer_fragment_glsl_default = "#version 300 es\n#define SHADER_NAME simple-mesh-layer-fs\n\nprecision highp float;\n\nuniform bool hasTexture;\nuniform sampler2D sampler;\nuniform bool flatShading;\nuniform float opacity;\n\nin vec2 vTexCoord;\nin vec3 cameraPosition;\nin vec3 normals_commonspace;\nin vec4 position_commonspace;\nin vec4 vColor;\n\nout vec4 fragColor;\n\nvoid main(void) {\n  geometry.uv = vTexCoord;\n\n  vec3 normal;\n  if (flatShading) {\n#ifdef DERIVATIVES_AVAILABLE\n    normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));\n#else\n    normal = vec3(0.0, 0.0, 1.0);\n#endif\n  } else {\n    normal = normals_commonspace;\n  }\n\n  vec4 color = hasTexture ? texture(sampler, vTexCoord) : vColor;\n  DECKGL_FILTER_COLOR(color, geometry);\n\n  vec3 lightColor = lighting_getLightColor(color.rgb, cameraPosition, position_commonspace.xyz, normal);\n  fragColor = vec4(lightColor, color.a * opacity);\n}\n";

// node_modules/@deck.gl/mesh-layers/dist/esm/simple-mesh-layer/simple-mesh-layer.js
function validateGeometryAttributes(attributes, useMeshColors) {
  const hasColorAttribute = attributes.COLOR_0 || attributes.colors;
  const useColorAttribute = hasColorAttribute && useMeshColors;
  if (!useColorAttribute) {
    attributes.colors = {
      constant: true,
      value: new Float32Array([1, 1, 1])
    };
  }
  log_default.assert(attributes.positions || attributes.POSITION, 'no "postions" or "POSITION" attribute in mesh');
}
function getGeometry(data, useMeshColors) {
  if (data.attributes) {
    validateGeometryAttributes(data.attributes, useMeshColors);
    if (data instanceof Geometry) {
      return data;
    } else {
      return new Geometry(data);
    }
  } else if (data.positions || data.POSITION) {
    validateGeometryAttributes(data, useMeshColors);
    return new Geometry({
      attributes: data
    });
  }
  throw Error("Invalid mesh");
}
var DEFAULT_COLOR = [0, 0, 0, 255];
var defaultProps = {
  mesh: {
    type: "object",
    value: null,
    async: true
  },
  texture: {
    type: "image",
    value: null,
    async: true
  },
  sizeScale: {
    type: "number",
    value: 1,
    min: 0
  },
  _useMeshColors: {
    type: "boolean",
    value: false
  },
  _instanced: true,
  wireframe: false,
  material: true,
  getPosition: {
    type: "accessor",
    value: (x) => x.position
  },
  getColor: {
    type: "accessor",
    value: DEFAULT_COLOR
  },
  getOrientation: {
    type: "accessor",
    value: [0, 0, 0]
  },
  getScale: {
    type: "accessor",
    value: [1, 1, 1]
  },
  getTranslation: {
    type: "accessor",
    value: [0, 0, 0]
  },
  getTransformMatrix: {
    type: "accessor",
    value: []
  },
  textureParameters: {
    type: "object",
    ignore: true
  }
};
var SimpleMeshLayer = class extends Layer {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "state", void 0);
  }
  getShaders() {
    const transpileToGLSL100 = !isWebGL2(this.context.gl);
    const defines = {};
    if (hasFeature(this.context.gl, FEATURES.GLSL_DERIVATIVES)) {
      defines.DERIVATIVES_AVAILABLE = 1;
    }
    return super.getShaders({
      vs: simple_mesh_layer_vertex_glsl_default,
      fs: simple_mesh_layer_fragment_glsl_default,
      modules: [project32_default, phongLighting, picking_default],
      transpileToGLSL100,
      defines
    });
  }
  getBounds() {
    var _mesh$header;
    if (this.props._instanced) {
      return super.getBounds();
    }
    let result = this.state.positionBounds;
    if (result) {
      return result;
    }
    const {
      mesh
    } = this.props;
    if (!mesh) {
      return null;
    }
    result = (_mesh$header = mesh.header) === null || _mesh$header === void 0 ? void 0 : _mesh$header.boundingBox;
    if (!result) {
      const {
        attributes
      } = getGeometry(mesh, this.props._useMeshColors);
      attributes.POSITION = attributes.POSITION || attributes.positions;
      result = getMeshBoundingBox(attributes);
    }
    this.state.positionBounds = result;
    return result;
  }
  initializeState() {
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      instancePositions: {
        transition: true,
        type: 5130,
        fp64: this.use64bitPositions(),
        size: 3,
        accessor: "getPosition"
      },
      instanceColors: {
        type: 5121,
        transition: true,
        size: this.props.colorFormat.length,
        normalized: true,
        accessor: "getColor",
        defaultValue: [0, 0, 0, 255]
      },
      instanceModelMatrix: MATRIX_ATTRIBUTES
    });
    this.setState({
      emptyTexture: new Texture2D(this.context.gl, {
        data: new Uint8Array(4),
        width: 1,
        height: 1
      })
    });
  }
  updateState(params) {
    super.updateState(params);
    const {
      props,
      oldProps,
      changeFlags
    } = params;
    if (props.mesh !== oldProps.mesh || changeFlags.extensionsChanged) {
      var _this$state$model;
      this.state.positionBounds = null;
      (_this$state$model = this.state.model) === null || _this$state$model === void 0 ? void 0 : _this$state$model.delete();
      if (props.mesh) {
        this.state.model = this.getModel(props.mesh);
        const attributes = props.mesh.attributes || props.mesh;
        this.setState({
          hasNormals: Boolean(attributes.NORMAL || attributes.normals)
        });
      }
      this.getAttributeManager().invalidateAll();
    }
    if (props.texture !== oldProps.texture) {
      this.setTexture(props.texture);
    }
    if (this.state.model) {
      this.state.model.setDrawMode(this.props.wireframe ? 3 : 4);
    }
  }
  finalizeState(context) {
    super.finalizeState(context);
    this.state.emptyTexture.delete();
  }
  draw({
    uniforms
  }) {
    if (!this.state.model) {
      return;
    }
    const {
      viewport
    } = this.context;
    const {
      sizeScale,
      coordinateSystem,
      _instanced
    } = this.props;
    this.state.model.setUniforms(uniforms).setUniforms({
      sizeScale,
      composeModelMatrix: !_instanced || shouldComposeModelMatrix(viewport, coordinateSystem),
      flatShading: !this.state.hasNormals
    }).draw();
  }
  getModel(mesh) {
    const model = new Model(this.context.gl, {
      ...this.getShaders(),
      id: this.props.id,
      geometry: getGeometry(mesh, this.props._useMeshColors),
      isInstanced: true
    });
    const {
      texture
    } = this.props;
    const {
      emptyTexture
    } = this.state;
    model.setUniforms({
      sampler: texture || emptyTexture,
      hasTexture: Boolean(texture)
    });
    return model;
  }
  setTexture(texture) {
    const {
      emptyTexture,
      model
    } = this.state;
    if (model) {
      model.setUniforms({
        sampler: texture || emptyTexture,
        hasTexture: Boolean(texture)
      });
    }
  }
};
_defineProperty(SimpleMeshLayer, "defaultProps", defaultProps);
_defineProperty(SimpleMeshLayer, "layerName", "SimpleMeshLayer");

// node_modules/@luma.gl/experimental/dist/esm/scenegraph/scenegraph-node.js
var ScenegraphNode = class {
  constructor() {
    let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      id
    } = props;
    this.id = id || uid(this.constructor.name);
    this.display = true;
    this.position = new Vector3();
    this.rotation = new Vector3();
    this.scale = new Vector3(1, 1, 1);
    this.matrix = new Matrix4();
    this.userData = {};
    this.props = {};
    this._setScenegraphNodeProps(props);
  }
  delete() {
  }
  setProps(props) {
    this._setScenegraphNodeProps(props);
    return this;
  }
  toString() {
    return "{type: ScenegraphNode, id: ".concat(this.id, ")}");
  }
  getBounds() {
    return null;
  }
  setPosition(position) {
    assert(position.length === 3, "setPosition requires vector argument");
    this.position = position;
    return this;
  }
  setRotation(rotation) {
    assert(rotation.length === 3, "setRotation requires vector argument");
    this.rotation = rotation;
    return this;
  }
  setScale(scale) {
    assert(scale.length === 3, "setScale requires vector argument");
    this.scale = scale;
    return this;
  }
  setMatrix(matrix) {
    let copyMatrix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    if (copyMatrix) {
      this.matrix.copy(matrix);
    } else {
      this.matrix = matrix;
    }
  }
  setMatrixComponents(_ref) {
    let {
      position,
      rotation,
      scale,
      update = true
    } = _ref;
    if (position) {
      this.setPosition(position);
    }
    if (rotation) {
      this.setRotation(rotation);
    }
    if (scale) {
      this.setScale(scale);
    }
    if (update) {
      this.updateMatrix();
    }
    return this;
  }
  updateMatrix() {
    const pos = this.position;
    const rot = this.rotation;
    const scale = this.scale;
    this.matrix.identity();
    this.matrix.translate(pos);
    this.matrix.rotateXYZ(rot);
    this.matrix.scale(scale);
    return this;
  }
  update() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      position,
      rotation,
      scale
    } = options;
    if (position) {
      this.setPosition(position);
    }
    if (rotation) {
      this.setRotation(rotation);
    }
    if (scale) {
      this.setScale(scale);
    }
    this.updateMatrix();
    return this;
  }
  getCoordinateUniforms(viewMatrix, modelMatrix2) {
    assert(viewMatrix);
    modelMatrix2 = modelMatrix2 || this.matrix;
    const worldMatrix = new Matrix4(viewMatrix).multiplyRight(modelMatrix2);
    const worldInverse = worldMatrix.invert();
    const worldInverseTranspose = worldInverse.transpose();
    return {
      viewMatrix,
      modelMatrix: modelMatrix2,
      objectMatrix: modelMatrix2,
      worldMatrix,
      worldInverseMatrix: worldInverse,
      worldInverseTransposeMatrix: worldInverseTranspose
    };
  }
  _setScenegraphNodeProps(props) {
    if ("display" in props) {
      this.display = props.display;
    }
    if ("position" in props) {
      this.setPosition(props.position);
    }
    if ("rotation" in props) {
      this.setRotation(props.rotation);
    }
    if ("scale" in props) {
      this.setScale(props.scale);
    }
    if ("matrix" in props) {
      this.setMatrix(props.matrix);
    }
    Object.assign(this.props, props);
  }
};

// node_modules/@luma.gl/experimental/dist/esm/scenegraph/group-node.js
var GroupNode = class extends ScenegraphNode {
  constructor() {
    let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    props = Array.isArray(props) ? {
      children: props
    } : props;
    const {
      children = []
    } = props;
    log.assert(children.every((child) => child instanceof ScenegraphNode), "every child must an instance of ScenegraphNode");
    super(props);
    this.children = children;
  }
  add() {
    for (var _len = arguments.length, children = new Array(_len), _key = 0; _key < _len; _key++) {
      children[_key] = arguments[_key];
    }
    for (const child of children) {
      if (Array.isArray(child)) {
        this.add(...child);
      } else {
        this.children.push(child);
      }
    }
    return this;
  }
  remove(child) {
    const children = this.children;
    const indexOf = children.indexOf(child);
    if (indexOf > -1) {
      children.splice(indexOf, 1);
    }
    return this;
  }
  removeAll() {
    this.children = [];
    return this;
  }
  delete() {
    this.children.forEach((child) => child.delete());
    this.removeAll();
    super.delete();
  }
  getBounds() {
    const result = [[Infinity, Infinity, Infinity], [-Infinity, -Infinity, -Infinity]];
    this.traverse((node, _ref) => {
      let {
        worldMatrix
      } = _ref;
      const bounds = node.getBounds();
      if (!bounds) {
        return;
      }
      const [min, max] = bounds;
      const center = new Vector3(min).add(max).divide([2, 2, 2]);
      worldMatrix.transformAsPoint(center, center);
      const halfSize = new Vector3(max).subtract(min).divide([2, 2, 2]);
      worldMatrix.transformAsVector(halfSize, halfSize);
      for (let v = 0; v < 8; v++) {
        const position = new Vector3(v & 1 ? -1 : 1, v & 2 ? -1 : 1, v & 4 ? -1 : 1).multiply(halfSize).add(center);
        for (let i = 0; i < 3; i++) {
          result[0][i] = Math.min(result[0][i], position[i]);
          result[1][i] = Math.max(result[1][i], position[i]);
        }
      }
    });
    if (!Number.isFinite(result[0][0])) {
      return null;
    }
    return result;
  }
  traverse(visitor) {
    let {
      worldMatrix = new Matrix4()
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const modelMatrix2 = new Matrix4(worldMatrix).multiplyRight(this.matrix);
    for (const child of this.children) {
      if (child instanceof GroupNode) {
        child.traverse(visitor, {
          worldMatrix: modelMatrix2
        });
      } else {
        visitor(child, {
          worldMatrix: modelMatrix2
        });
      }
    }
  }
};

// node_modules/@luma.gl/experimental/dist/esm/gltf/gltf-animator.js
var ATTRIBUTE_TYPE_TO_COMPONENTS = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
};
var ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
};
function accessorToJsArray(accessor) {
  if (!accessor._animation) {
    const ArrayType = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY[accessor.componentType];
    const components = ATTRIBUTE_TYPE_TO_COMPONENTS[accessor.type];
    const length = components * accessor.count;
    const {
      buffer,
      byteOffset
    } = accessor.bufferView.data;
    const array = new ArrayType(buffer, byteOffset + (accessor.byteOffset || 0), length);
    if (components === 1) {
      accessor._animation = Array.from(array);
    } else {
      const slicedArray = [];
      for (let i = 0; i < array.length; i += components) {
        slicedArray.push(Array.from(array.slice(i, i + components)));
      }
      accessor._animation = slicedArray;
    }
  }
  return accessor._animation;
}
var helperMatrix = new Matrix4();
function applyTranslationRotationScale(gltfNode, node) {
  node.matrix.identity();
  if (gltfNode.translation) {
    node.matrix.translate(gltfNode.translation);
  }
  if (gltfNode.rotation) {
    const rotationMatrix = helperMatrix.fromQuaternion(gltfNode.rotation);
    node.matrix.multiplyRight(rotationMatrix);
  }
  if (gltfNode.scale) {
    node.matrix.scale(gltfNode.scale);
  }
}
var quaternion = new Quaternion();
function linearInterpolate(target, path, start, stop, ratio) {
  if (path === "rotation") {
    quaternion.slerp({
      start,
      target: stop,
      ratio
    });
    for (let i = 0; i < quaternion.length; i++) {
      target[path][i] = quaternion[i];
    }
  } else {
    for (let i = 0; i < start.length; i++) {
      target[path][i] = ratio * stop[i] + (1 - ratio) * start[i];
    }
  }
}
function cubicsplineInterpolate(target, path, _ref) {
  let {
    p0,
    outTangent0,
    inTangent1,
    p1,
    tDiff,
    ratio: t
  } = _ref;
  for (let i = 0; i < target[path].length; i++) {
    const m0 = outTangent0[i] * tDiff;
    const m1 = inTangent1[i] * tDiff;
    target[path][i] = (2 * Math.pow(t, 3) - 3 * Math.pow(t, 2) + 1) * p0[i] + (Math.pow(t, 3) - 2 * Math.pow(t, 2) + t) * m0 + (-2 * Math.pow(t, 3) + 3 * Math.pow(t, 2)) * p1[i] + (Math.pow(t, 3) - Math.pow(t, 2)) * m1;
  }
}
function stepInterpolate(target, path, value) {
  for (let i = 0; i < value.length; i++) {
    target[path][i] = value[i];
  }
}
function interpolate(time, _ref2, target, path) {
  let {
    input,
    interpolation,
    output
  } = _ref2;
  const maxTime = input[input.length - 1];
  const animationTime = time % maxTime;
  const nextIndex = input.findIndex((t) => t >= animationTime);
  const previousIndex = Math.max(0, nextIndex - 1);
  if (!Array.isArray(target[path])) {
    switch (path) {
      case "translation":
        target[path] = [0, 0, 0];
        break;
      case "rotation":
        target[path] = [0, 0, 0, 1];
        break;
      case "scale":
        target[path] = [1, 1, 1];
        break;
      default:
        log.warn("Bad animation path ".concat(path))();
    }
  }
  assert(target[path].length === output[previousIndex].length);
  const previousTime = input[previousIndex];
  const nextTime = input[nextIndex];
  switch (interpolation) {
    case "STEP":
      stepInterpolate(target, path, output[previousIndex]);
      break;
    case "LINEAR":
      if (nextTime > previousTime) {
        const ratio = (animationTime - previousTime) / (nextTime - previousTime);
        linearInterpolate(target, path, output[previousIndex], output[nextIndex], ratio);
      }
      break;
    case "CUBICSPLINE":
      if (nextTime > previousTime) {
        const ratio = (animationTime - previousTime) / (nextTime - previousTime);
        const tDiff = nextTime - previousTime;
        const p0 = output[3 * previousIndex + 1];
        const outTangent0 = output[3 * previousIndex + 2];
        const inTangent1 = output[3 * nextIndex + 0];
        const p1 = output[3 * nextIndex + 1];
        cubicsplineInterpolate(target, path, {
          p0,
          outTangent0,
          inTangent1,
          p1,
          tDiff,
          ratio
        });
      }
      break;
    default:
      log.warn("Interpolation ".concat(interpolation, " not supported"))();
      break;
  }
}
var GLTFAnimation = class {
  constructor(props) {
    this.startTime = 0;
    this.playing = true;
    this.speed = 1;
    this.channels = [];
    Object.assign(this, props);
  }
  animate(timeMs) {
    if (!this.playing) {
      return;
    }
    const absTime = timeMs / 1e3;
    const time = (absTime - this.startTime) * this.speed;
    this.channels.forEach((_ref3) => {
      let {
        sampler,
        target,
        path
      } = _ref3;
      interpolate(time, sampler, target, path);
      applyTranslationRotationScale(target, target._node);
    });
  }
};
var GLTFAnimator = class {
  constructor(gltf) {
    this.animations = gltf.animations.map((animation, index) => {
      const name = animation.name || "Animation-".concat(index);
      const samplers = animation.samplers.map((_ref4) => {
        let {
          input,
          interpolation = "LINEAR",
          output
        } = _ref4;
        return {
          input: accessorToJsArray(gltf.accessors[input]),
          interpolation,
          output: accessorToJsArray(gltf.accessors[output])
        };
      });
      const channels = animation.channels.map((_ref5) => {
        let {
          sampler,
          target
        } = _ref5;
        return {
          sampler: samplers[sampler],
          target: gltf.nodes[target.node],
          path: target.path
        };
      });
      return new GLTFAnimation({
        name,
        channels
      });
    });
  }
  animate(time) {
    this.setTime(time);
  }
  setTime(time) {
    this.animations.forEach((animation) => animation.animate(time));
  }
  getAnimations() {
    return this.animations;
  }
};

// node_modules/@luma.gl/experimental/dist/esm/scenegraph/model-node.js
var ModelNode = class extends ScenegraphNode {
  constructor(gl) {
    let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(props);
    this.onBeforeRender = null;
    this.AfterRender = null;
    if (gl instanceof Model) {
      this.model = gl;
      this._setModelNodeProps(props);
    } else {
      this.model = new Model(gl, props);
    }
    this.bounds = null;
    this.managedResources = props.managedResources || [];
  }
  setProps(props) {
    super.setProps(props);
    this._setModelNodeProps(props);
    return this;
  }
  getBounds() {
    return this.bounds;
  }
  delete() {
    if (this.model) {
      this.model.delete();
      this.model = null;
    }
    this.managedResources.forEach((resource) => resource.delete());
    this.managedResources = [];
  }
  draw() {
    return this.model.draw(...arguments);
  }
  setUniforms() {
    this.model.setUniforms(...arguments);
    return this;
  }
  setAttributes() {
    this.model.setAttributes(...arguments);
    return this;
  }
  updateModuleSettings() {
    this.model.updateModuleSettings(...arguments);
    return this;
  }
  _setModelNodeProps(props) {
    this.model.setProps(props);
  }
};

// node_modules/@luma.gl/experimental/dist/esm/gltf/gltf-material-parser.js
var GLTFMaterialParser = class {
  constructor(gl, _ref) {
    let {
      attributes,
      material,
      pbrDebug,
      imageBasedLightingEnvironment,
      lights,
      useTangents
    } = _ref;
    this.gl = gl;
    this.defines = {
      MANUAL_SRGB: 1,
      SRGB_FAST_APPROXIMATION: 1
    };
    if (hasFeature(gl, FEATURES.GLSL_TEXTURE_LOD)) {
      this.defines.USE_TEX_LOD = 1;
    }
    this.uniforms = {
      u_Camera: [0, 0, 0],
      u_MetallicRoughnessValues: [1, 1]
    };
    this.parameters = {};
    this.generatedTextures = [];
    if (imageBasedLightingEnvironment) {
      this.uniforms.u_DiffuseEnvSampler = imageBasedLightingEnvironment.getDiffuseEnvSampler();
      this.uniforms.u_SpecularEnvSampler = imageBasedLightingEnvironment.getSpecularEnvSampler();
      this.uniforms.u_brdfLUT = imageBasedLightingEnvironment.getBrdfTexture();
      this.uniforms.u_ScaleIBLAmbient = [1, 1];
    }
    if (pbrDebug) {
      this.uniforms.u_ScaleDiffBaseMR = [0, 0, 0, 0];
      this.uniforms.u_ScaleFGDSpec = [0, 0, 0, 0];
    }
    this.defineIfPresent(attributes.NORMAL, "HAS_NORMALS");
    this.defineIfPresent(attributes.TANGENT && useTangents, "HAS_TANGENTS");
    this.defineIfPresent(attributes.TEXCOORD_0, "HAS_UV");
    this.defineIfPresent(imageBasedLightingEnvironment, "USE_IBL");
    this.defineIfPresent(lights, "USE_LIGHTS");
    this.defineIfPresent(pbrDebug, "PBR_DEBUG");
    if (material) {
      this.parseMaterial(material);
    }
  }
  defineIfPresent(value, name) {
    if (value) {
      this.defines[name] = 1;
    }
  }
  parseTexture(gltfTexture, name) {
    let define = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
    const parameters = gltfTexture.texture && gltfTexture.texture.sampler && gltfTexture.texture.sampler.parameters || {};
    const image = gltfTexture.texture.source.image;
    let textureOptions;
    let specialTextureParameters = {};
    if (image.compressed) {
      textureOptions = image;
      specialTextureParameters = {
        [this.gl.TEXTURE_MIN_FILTER]: image.data.length > 1 ? this.gl.LINEAR_MIPMAP_NEAREST : this.gl.LINEAR
      };
    } else {
      textureOptions = {
        data: image
      };
    }
    const texture = new Texture2D(this.gl, {
      id: gltfTexture.name || gltfTexture.id,
      parameters: {
        ...parameters,
        ...specialTextureParameters
      },
      pixelStore: {
        [this.gl.UNPACK_FLIP_Y_WEBGL]: false
      },
      ...textureOptions
    });
    this.uniforms[name] = texture;
    this.defineIfPresent(define, define);
    this.generatedTextures.push(texture);
  }
  parsePbrMetallicRoughness(pbrMetallicRoughness) {
    if (pbrMetallicRoughness.baseColorTexture) {
      this.parseTexture(pbrMetallicRoughness.baseColorTexture, "u_BaseColorSampler", "HAS_BASECOLORMAP");
    }
    this.uniforms.u_BaseColorFactor = pbrMetallicRoughness.baseColorFactor || [1, 1, 1, 1];
    if (pbrMetallicRoughness.metallicRoughnessTexture) {
      this.parseTexture(pbrMetallicRoughness.metallicRoughnessTexture, "u_MetallicRoughnessSampler", "HAS_METALROUGHNESSMAP");
    }
    const {
      metallicFactor = 1,
      roughnessFactor = 1
    } = pbrMetallicRoughness;
    this.uniforms.u_MetallicRoughnessValues = [metallicFactor, roughnessFactor];
  }
  parseMaterial(material) {
    this.uniforms.pbr_uUnlit = Boolean(material.unlit);
    if (material.pbrMetallicRoughness) {
      this.parsePbrMetallicRoughness(material.pbrMetallicRoughness);
    }
    if (material.normalTexture) {
      this.parseTexture(material.normalTexture, "u_NormalSampler", "HAS_NORMALMAP");
      const {
        scale = 1
      } = material.normalTexture;
      this.uniforms.u_NormalScale = scale;
    }
    if (material.occlusionTexture) {
      this.parseTexture(material.occlusionTexture, "u_OcclusionSampler", "HAS_OCCLUSIONMAP");
      const {
        strength = 1
      } = material.occlusionTexture;
      this.uniforms.u_OcclusionStrength = strength;
    }
    if (material.emissiveTexture) {
      this.parseTexture(material.emissiveTexture, "u_EmissiveSampler", "HAS_EMISSIVEMAP");
      this.uniforms.u_EmissiveFactor = material.emissiveFactor || [0, 0, 0];
    }
    if (material.alphaMode === "MASK") {
      const {
        alphaCutoff = 0.5
      } = material;
      this.defines.ALPHA_CUTOFF = 1;
      this.uniforms.u_AlphaCutoff = alphaCutoff;
    } else if (material.alphaMode === "BLEND") {
      log.warn("BLEND alphaMode might not work well because it requires mesh sorting")();
      Object.assign(this.parameters, {
        blend: true,
        blendEquation: this.gl.FUNC_ADD,
        blendFunc: [this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA, this.gl.ONE, this.gl.ONE_MINUS_SRC_ALPHA]
      });
    }
  }
  delete() {
    this.generatedTextures.forEach((texture) => texture.delete());
  }
};

// node_modules/@luma.gl/experimental/dist/esm/gltf/create-gltf-model.js
var vs = "\n#if (__VERSION__ < 300)\n  #define _attr attribute\n#else\n  #define _attr in\n#endif\n\n  _attr vec4 POSITION;\n\n  #ifdef HAS_NORMALS\n    _attr vec4 NORMAL;\n  #endif\n\n  #ifdef HAS_TANGENTS\n    _attr vec4 TANGENT;\n  #endif\n\n  #ifdef HAS_UV\n    _attr vec2 TEXCOORD_0;\n  #endif\n\n  void main(void) {\n    vec4 _NORMAL = vec4(0.);\n    vec4 _TANGENT = vec4(0.);\n    vec2 _TEXCOORD_0 = vec2(0.);\n\n    #ifdef HAS_NORMALS\n      _NORMAL = NORMAL;\n    #endif\n\n    #ifdef HAS_TANGENTS\n      _TANGENT = TANGENT;\n    #endif\n\n    #ifdef HAS_UV\n      _TEXCOORD_0 = TEXCOORD_0;\n    #endif\n\n    pbr_setPositionNormalTangentUV(POSITION, _NORMAL, _TANGENT, _TEXCOORD_0);\n    gl_Position = u_MVPMatrix * POSITION;\n  }\n";
var fs = "\n#if (__VERSION__ < 300)\n  #define fragmentColor gl_FragColor\n#else\n  out vec4 fragmentColor;\n#endif\n\n  void main(void) {\n    fragmentColor = pbr_filterColor(vec4(0));\n  }\n";
function addVersionToShader(gl, source) {
  if (isWebGL2(gl)) {
    return "#version 300 es\n".concat(source);
  }
  return source;
}
function createGLTFModel(gl, options) {
  const {
    id,
    drawMode,
    vertexCount,
    attributes,
    modelOptions
  } = options;
  const materialParser = new GLTFMaterialParser(gl, options);
  log.info(4, "createGLTFModel defines: ", materialParser.defines)();
  const managedResources = [];
  managedResources.push(...materialParser.generatedTextures);
  managedResources.push(...Object.values(attributes).map((attribute) => attribute.buffer));
  const model = new ModelNode(gl, Object.assign({
    id,
    drawMode,
    vertexCount,
    modules: [pbr],
    defines: materialParser.defines,
    parameters: materialParser.parameters,
    vs: addVersionToShader(gl, vs),
    fs: addVersionToShader(gl, fs),
    managedResources
  }, modelOptions));
  model.setProps({
    attributes
  });
  model.setUniforms(materialParser.uniforms);
  return model;
}

// node_modules/@luma.gl/experimental/dist/esm/gltf/gltf-instantiator.js
var ATTRIBUTE_TYPE_TO_COMPONENTS2 = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
};
var DEFAULT_OPTIONS = {
  modelOptions: {},
  pbrDebug: false,
  imageBasedLightingEnvironment: null,
  lights: true,
  useTangents: false
};
var GLTFInstantiator = class {
  constructor(gl) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.gl = gl;
    this.options = Object.assign({}, DEFAULT_OPTIONS, options);
  }
  instantiate(gltf) {
    this.gltf = gltf;
    const scenes = (gltf.scenes || []).map((scene) => this.createScene(scene));
    return scenes;
  }
  createAnimator() {
    if (Array.isArray(this.gltf.animations)) {
      return new GLTFAnimator(this.gltf);
    }
    return null;
  }
  createScene(gltfScene) {
    const gltfNodes = gltfScene.nodes || [];
    const nodes = gltfNodes.map((node) => this.createNode(node));
    const scene = new GroupNode({
      id: gltfScene.name || gltfScene.id,
      children: nodes
    });
    return scene;
  }
  createNode(gltfNode) {
    if (!gltfNode._node) {
      const gltfChildren = gltfNode.children || [];
      const children = gltfChildren.map((child) => this.createNode(child));
      if (gltfNode.mesh) {
        children.push(this.createMesh(gltfNode.mesh));
      }
      const node = new GroupNode({
        id: gltfNode.name || gltfNode.id,
        children
      });
      if (gltfNode.matrix) {
        node.setMatrix(gltfNode.matrix);
      } else {
        node.matrix.identity();
        if (gltfNode.translation) {
          node.matrix.translate(gltfNode.translation);
        }
        if (gltfNode.rotation) {
          const rotationMatrix = new Matrix4().fromQuaternion(gltfNode.rotation);
          node.matrix.multiplyRight(rotationMatrix);
        }
        if (gltfNode.scale) {
          node.matrix.scale(gltfNode.scale);
        }
      }
      gltfNode._node = node;
    }
    return gltfNode._node;
  }
  createMesh(gltfMesh) {
    if (!gltfMesh._mesh) {
      const gltfPrimitives = gltfMesh.primitives || [];
      const primitives = gltfPrimitives.map((gltfPrimitive, i) => this.createPrimitive(gltfPrimitive, i, gltfMesh));
      const mesh = new GroupNode({
        id: gltfMesh.name || gltfMesh.id,
        children: primitives
      });
      gltfMesh._mesh = mesh;
    }
    return gltfMesh._mesh;
  }
  getVertexCount(attributes) {
    log.warn("getVertexCount() not found")();
  }
  createPrimitive(gltfPrimitive, i, gltfMesh) {
    const model = createGLTFModel(this.gl, Object.assign({
      id: gltfPrimitive.name || "".concat(gltfMesh.name || gltfMesh.id, "-primitive-").concat(i),
      drawMode: gltfPrimitive.mode || 4,
      vertexCount: gltfPrimitive.indices ? gltfPrimitive.indices.count : this.getVertexCount(gltfPrimitive.attributes),
      attributes: this.createAttributes(gltfPrimitive.attributes, gltfPrimitive.indices),
      material: gltfPrimitive.material
    }, this.options));
    model.bounds = [gltfPrimitive.attributes.POSITION.min, gltfPrimitive.attributes.POSITION.max];
    return model;
  }
  createAttributes(attributes, indices) {
    const loadedAttributes = {};
    Object.keys(attributes).forEach((attrName) => {
      loadedAttributes[attrName] = this.createAccessor(attributes[attrName], this.createBuffer(attributes[attrName], this.gl.ARRAY_BUFFER));
    });
    if (indices) {
      loadedAttributes.indices = this.createAccessor(indices, this.createBuffer(indices, this.gl.ELEMENT_ARRAY_BUFFER));
    }
    log.info(4, "glTF Attributes", {
      attributes,
      indices,
      generated: loadedAttributes
    })();
    return loadedAttributes;
  }
  createBuffer(attribute, target) {
    if (!attribute.bufferView) {
      attribute.bufferView = {};
    }
    const {
      bufferView
    } = attribute;
    if (!bufferView.lumaBuffers) {
      bufferView.lumaBuffers = {};
    }
    if (!bufferView.lumaBuffers[target]) {
      bufferView.lumaBuffers[target] = new Buffer(this.gl, {
        id: "from-".concat(bufferView.id),
        data: bufferView.data || attribute.value,
        target
      });
    }
    return bufferView.lumaBuffers[target];
  }
  createAccessor(accessor, buffer) {
    return new Accessor({
      buffer,
      offset: accessor.byteOffset || 0,
      stride: accessor.bufferView.byteStride || 0,
      type: accessor.componentType,
      size: ATTRIBUTE_TYPE_TO_COMPONENTS2[accessor.type]
    });
  }
  createSampler(gltfSampler) {
    return gltfSampler;
  }
  needsPOT() {
    return false;
  }
};

// node_modules/@luma.gl/experimental/dist/esm/gltf/create-gltf-objects.js
function createGLTFObjects(gl, gltf, options) {
  const instantiator = new GLTFInstantiator(gl, options);
  const scenes = instantiator.instantiate(gltf);
  const animator = instantiator.createAnimator();
  return {
    scenes,
    animator
  };
}

// node_modules/@luma.gl/experimental/dist/esm/gpgpu/point-in-polygon/polygon.js
var import_earcut = __toESM(require_earcut());
var PI_4 = Math.PI / 4;
var DEGREES_TO_RADIANS_HALF = Math.PI / 360;

// node_modules/@deck.gl/mesh-layers/dist/esm/scenegraph-layer/gltf-utils.js
async function waitForGLTFAssets(gltfObjects) {
  const remaining = [];
  gltfObjects.scenes.forEach((scene) => {
    scene.traverse((model) => {
      Object.values(model.model.getUniforms()).forEach((uniform) => {
        if (uniform.loaded === false) {
          remaining.push(uniform);
        }
      });
    });
  });
  return await waitWhileCondition(() => remaining.some((uniform) => !uniform.loaded));
}
async function waitWhileCondition(condition) {
  while (condition()) {
    await new Promise((resolve) => requestAnimationFrame(resolve));
  }
}

// node_modules/@deck.gl/mesh-layers/dist/esm/scenegraph-layer/scenegraph-layer-vertex.glsl.js
var scenegraph_layer_vertex_glsl_default = "#version 300 es\nin vec3 instancePositions;\nin vec3 instancePositions64Low;\nin vec4 instanceColors;\nin vec3 instancePickingColors;\nin mat3 instanceModelMatrix;\nin vec3 instanceTranslation;\nuniform float sizeScale;\nuniform float sizeMinPixels;\nuniform float sizeMaxPixels;\nuniform mat4 sceneModelMatrix;\nuniform bool composeModelMatrix;\nin vec4 POSITION;\n\n#ifdef HAS_UV\n  in vec2 TEXCOORD_0;\n#endif\n\n#ifdef MODULE_PBR\n  #ifdef HAS_NORMALS\n    in vec4 NORMAL;\n  #endif\n#endif\nout vec4 vColor;\n#ifndef MODULE_PBR\n  #ifdef HAS_UV\n    out vec2 vTEXCOORD_0;\n  #endif\n#endif\nvoid main(void) {\n  #if defined(HAS_UV) && !defined(MODULE_PBR)\n    vTEXCOORD_0 = TEXCOORD_0;\n    geometry.uv = vTEXCOORD_0;\n  #endif\n\n  geometry.worldPosition = instancePositions;\n  geometry.pickingColor = instancePickingColors;\n\n  vec3 normal = vec3(0.0, 0.0, 1.0);\n  #ifdef MODULE_PBR\n    #ifdef HAS_NORMALS\n      normal = instanceModelMatrix * (sceneModelMatrix * vec4(NORMAL.xyz, 0.0)).xyz;\n    #endif\n  #endif\n\n  float originalSize = project_size_to_pixel(sizeScale);\n  float clampedSize = clamp(originalSize, sizeMinPixels, sizeMaxPixels);\n\n  vec3 pos = (instanceModelMatrix * (sceneModelMatrix * POSITION).xyz) * sizeScale * (clampedSize / originalSize) + instanceTranslation;\n  if(composeModelMatrix) {\n    DECKGL_FILTER_SIZE(pos, geometry);\n    geometry.normal = project_normal(normal);\n    geometry.worldPosition += pos;\n    gl_Position = project_position_to_clipspace(pos + instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n  }\n  else {\n    pos = project_size(pos);\n    DECKGL_FILTER_SIZE(pos, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, pos, geometry.position);\n    geometry.normal = project_normal(normal);\n  }\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  #ifdef MODULE_PBR\n    pbr_vPosition = geometry.position.xyz;\n    #ifdef HAS_NORMALS\n      pbr_vNormal = geometry.normal;\n    #endif\n\n    #ifdef HAS_UV\n      pbr_vUV = TEXCOORD_0;\n    #else\n      pbr_vUV = vec2(0., 0.);\n    #endif\n    geometry.uv = pbr_vUV;\n  #endif\n\n  vColor = instanceColors;\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n";

// node_modules/@deck.gl/mesh-layers/dist/esm/scenegraph-layer/scenegraph-layer-fragment.glsl.js
var scenegraph_layer_fragment_glsl_default = "#version 300 es\nuniform float opacity;\nin vec4 vColor;\n\nout vec4 fragmentColor;\n#ifndef MODULE_PBR\n  #if defined(HAS_UV) && defined(HAS_BASECOLORMAP)\n    in vec2 vTEXCOORD_0;\n    uniform sampler2D u_BaseColorSampler;\n  #endif\n#endif\n\nvoid main(void) {\n  #ifdef MODULE_PBR\n    fragmentColor = vColor * pbr_filterColor(vec4(0));\n    geometry.uv = pbr_vUV;\n  #else\n    #if defined(HAS_UV) && defined(HAS_BASECOLORMAP)\n      fragmentColor = vColor * texture2D(u_BaseColorSampler, vTEXCOORD_0);\n      geometry.uv = vTEXCOORD_0;\n    #else\n      fragmentColor = vColor;\n    #endif\n  #endif\n\n  fragmentColor.a *= opacity;\n  DECKGL_FILTER_COLOR(fragmentColor, geometry);\n}\n";

// node_modules/@deck.gl/mesh-layers/dist/esm/scenegraph-layer/scenegraph-layer.js
var DEFAULT_COLOR2 = [255, 255, 255, 255];
var defaultProps2 = {
  scenegraph: {
    type: "object",
    value: null,
    async: true
  },
  getScene: (gltf) => {
    if (gltf && gltf.scenes) {
      return typeof gltf.scene === "object" ? gltf.scene : gltf.scenes[gltf.scene || 0];
    }
    return gltf;
  },
  getAnimator: (scenegraph) => scenegraph && scenegraph.animator,
  _animations: null,
  sizeScale: {
    type: "number",
    value: 1,
    min: 0
  },
  sizeMinPixels: {
    type: "number",
    min: 0,
    value: 0
  },
  sizeMaxPixels: {
    type: "number",
    min: 0,
    value: Number.MAX_SAFE_INTEGER
  },
  getPosition: {
    type: "accessor",
    value: (x) => x.position
  },
  getColor: {
    type: "accessor",
    value: DEFAULT_COLOR2
  },
  _lighting: "flat",
  _imageBasedLightingEnvironment: null,
  getOrientation: {
    type: "accessor",
    value: [0, 0, 0]
  },
  getScale: {
    type: "accessor",
    value: [1, 1, 1]
  },
  getTranslation: {
    type: "accessor",
    value: [0, 0, 0]
  },
  getTransformMatrix: {
    type: "accessor",
    value: []
  },
  loaders: [GLTFLoader]
};
var ScenegraphLayer = class extends Layer {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "state", void 0);
  }
  getShaders() {
    const modules = [project32_default, picking_default];
    if (this.props._lighting === "pbr") {
      modules.push(pbr);
    }
    return {
      vs: scenegraph_layer_vertex_glsl_default,
      fs: scenegraph_layer_fragment_glsl_default,
      modules
    };
  }
  initializeState() {
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      instancePositions: {
        size: 3,
        type: 5130,
        fp64: this.use64bitPositions(),
        accessor: "getPosition",
        transition: true
      },
      instanceColors: {
        type: 5121,
        size: this.props.colorFormat.length,
        accessor: "getColor",
        normalized: true,
        defaultValue: DEFAULT_COLOR2,
        transition: true
      },
      instanceModelMatrix: MATRIX_ATTRIBUTES
    });
  }
  updateState(params) {
    super.updateState(params);
    const {
      props,
      oldProps
    } = params;
    if (props.scenegraph !== oldProps.scenegraph) {
      this._updateScenegraph();
    } else if (props._animations !== oldProps._animations) {
      this._applyAnimationsProp(this.state.scenegraph, this.state.animator, props._animations);
    }
  }
  finalizeState(context) {
    super.finalizeState(context);
    this._deleteScenegraph();
  }
  _updateScenegraph() {
    const props = this.props;
    const {
      gl
    } = this.context;
    let scenegraphData = null;
    if (props.scenegraph instanceof ScenegraphNode) {
      scenegraphData = {
        scenes: [props.scenegraph]
      };
    } else if (props.scenegraph && !props.scenegraph.gltf) {
      const gltf = props.scenegraph;
      const gltfObjects = createGLTFObjects(gl, gltf, this._getModelOptions());
      scenegraphData = {
        gltf,
        ...gltfObjects
      };
      waitForGLTFAssets(gltfObjects).then(() => this.setNeedsRedraw());
    } else if (props.scenegraph) {
      log_default.deprecated("ScenegraphLayer.props.scenegraph", "Use GLTFLoader instead of GLTFScenegraphLoader")();
      scenegraphData = props.scenegraph;
    }
    const options = {
      layer: this,
      gl
    };
    const scenegraph = props.getScene(scenegraphData, options);
    const animator = props.getAnimator(scenegraphData, options);
    if (scenegraph instanceof ScenegraphNode) {
      this._deleteScenegraph();
      this._applyAllAttributes(scenegraph);
      this._applyAnimationsProp(scenegraph, animator, props._animations);
      this.setState({
        scenegraph,
        animator
      });
    } else if (scenegraph !== null) {
      log_default.warn("invalid scenegraph:", scenegraph)();
    }
  }
  _applyAllAttributes(scenegraph) {
    if (this.state.attributesAvailable) {
      const allAttributes = this.getAttributeManager().getAttributes();
      scenegraph.traverse((model) => {
        this._setModelAttributes(model.model, allAttributes);
      });
    }
  }
  _applyAnimationsProp(scenegraph, animator, animationsProp) {
    if (!scenegraph || !animator || !animationsProp) {
      return;
    }
    const animations = animator.getAnimations();
    Object.keys(animationsProp).sort().forEach((key) => {
      const value = animationsProp[key];
      if (key === "*") {
        animations.forEach((animation) => {
          Object.assign(animation, value);
        });
      } else if (Number.isFinite(Number(key))) {
        const number = Number(key);
        if (number >= 0 && number < animations.length) {
          Object.assign(animations[number], value);
        } else {
          log_default.warn("animation ".concat(key, " not found"))();
        }
      } else {
        const findResult = animations.find(({
          name
        }) => name === key);
        if (findResult) {
          Object.assign(findResult, value);
        } else {
          log_default.warn("animation ".concat(key, " not found"))();
        }
      }
    });
  }
  _deleteScenegraph() {
    const {
      scenegraph
    } = this.state;
    if (scenegraph instanceof ScenegraphNode) {
      scenegraph.delete();
    }
  }
  _getModelOptions() {
    const {
      _imageBasedLightingEnvironment
    } = this.props;
    let env = null;
    if (_imageBasedLightingEnvironment) {
      if (typeof _imageBasedLightingEnvironment === "function") {
        env = _imageBasedLightingEnvironment({
          gl: this.context.gl,
          layer: this
        });
      } else {
        env = _imageBasedLightingEnvironment;
      }
    }
    return {
      gl: this.context.gl,
      waitForFullLoad: true,
      imageBasedLightingEnvironment: env,
      modelOptions: {
        isInstanced: true,
        transpileToGLSL100: !isWebGL2(this.context.gl),
        ...this.getShaders()
      },
      useTangents: false
    };
  }
  updateAttributes(changedAttributes) {
    this.setState({
      attributesAvailable: true
    });
    if (!this.state.scenegraph)
      return;
    this.state.scenegraph.traverse((model) => {
      this._setModelAttributes(model.model, changedAttributes);
    });
  }
  draw({
    moduleParameters = null,
    parameters = {},
    context
  }) {
    if (!this.state.scenegraph)
      return;
    if (this.props._animations && this.state.animator) {
      this.state.animator.animate(context.timeline.getTime());
      this.setNeedsRedraw();
    }
    const {
      viewport
    } = this.context;
    const {
      sizeScale,
      sizeMinPixels,
      sizeMaxPixels,
      opacity,
      coordinateSystem
    } = this.props;
    const numInstances = this.getNumInstances();
    this.state.scenegraph.traverse((model, {
      worldMatrix
    }) => {
      model.model.setInstanceCount(numInstances);
      model.updateModuleSettings(moduleParameters);
      model.draw({
        parameters,
        uniforms: {
          sizeScale,
          opacity,
          sizeMinPixels,
          sizeMaxPixels,
          composeModelMatrix: shouldComposeModelMatrix(viewport, coordinateSystem),
          sceneModelMatrix: worldMatrix,
          u_Camera: model.model.getUniforms().project_uCameraPosition
        }
      });
    });
  }
};
_defineProperty(ScenegraphLayer, "defaultProps", defaultProps2);
_defineProperty(ScenegraphLayer, "layerName", "ScenegraphLayer");
export {
  ScenegraphLayer,
  SimpleMeshLayer
};
//# sourceMappingURL=@deck__gl_mesh-layers.js.map
