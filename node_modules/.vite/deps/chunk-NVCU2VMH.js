import {
  __commonJS,
  __export,
  __toESM
} from "./chunk-BHN6OJC3.js";

// (disabled):node_modules/@loaders.gl/worker-utils/dist/esm/lib/node/require-utils.node
var require_require_utils = __commonJS({
  "(disabled):node_modules/@loaders.gl/worker-utils/dist/esm/lib/node/require-utils.node"() {
  }
});

// (disabled):node_modules/@loaders.gl/worker-utils/dist/esm/lib/process-utils/child-process-proxy
var require_child_process_proxy = __commonJS({
  "(disabled):node_modules/@loaders.gl/worker-utils/dist/esm/lib/process-utils/child-process-proxy"() {
  }
});

// (disabled):node_modules/@loaders.gl/loader-utils/dist/esm/lib/node/buffer
var require_buffer = __commonJS({
  "(disabled):node_modules/@loaders.gl/loader-utils/dist/esm/lib/node/buffer"() {
  }
});

// (disabled):node_modules/@loaders.gl/loader-utils/dist/esm/lib/node/fs
var require_fs = __commonJS({
  "(disabled):node_modules/@loaders.gl/loader-utils/dist/esm/lib/node/fs"() {
  }
});

// browser-external:stream
var require_stream = __commonJS({
  "browser-external:stream"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "stream" has been externalized for browser compatibility. Cannot access "stream.${key}" in client code.`);
        }
      }
    }));
  }
});

// node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/assert.js
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || "loader assertion failed.");
  }
}

// node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/globals.js
var globals = {
  self: typeof self !== "undefined" && self,
  window: typeof window !== "undefined" && window,
  global: typeof global !== "undefined" && global,
  document: typeof document !== "undefined" && document
};
var self_ = globals.self || globals.window || globals.global || {};
var window_ = globals.window || globals.self || globals.global || {};
var global_ = globals.global || globals.self || globals.window || {};
var document_ = globals.document || {};
var isBrowser = Boolean(typeof process !== "object" || String(process) !== "[object process]" || process.browser);
var isWorker = typeof importScripts === "function";
var matches = typeof process !== "undefined" && process.version && /v([0-9]*)/.exec(process.version);
var nodeVersion = matches && parseFloat(matches[1]) || 0;

// node_modules/@loaders.gl/loader-utils/dist/esm/lib/iterators/text-iterators.js
async function* makeTextDecoderIterator(arrayBufferIterator) {
  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const textDecoder = new TextDecoder(void 0, options);
  for await (const arrayBuffer of arrayBufferIterator) {
    yield typeof arrayBuffer === "string" ? arrayBuffer : textDecoder.decode(arrayBuffer, {
      stream: true
    });
  }
}
async function* makeTextEncoderIterator(textIterator) {
  const textEncoder = new TextEncoder();
  for await (const text of textIterator) {
    yield typeof text === "string" ? textEncoder.encode(text) : text;
  }
}
async function* makeLineIterator(textIterator) {
  let previous = "";
  for await (const textChunk of textIterator) {
    previous += textChunk;
    let eolIndex;
    while ((eolIndex = previous.indexOf("\n")) >= 0) {
      const line = previous.slice(0, eolIndex + 1);
      previous = previous.slice(eolIndex + 1);
      yield line;
    }
  }
  if (previous.length > 0) {
    yield previous;
  }
}
async function* makeNumberedLineIterator(lineIterator) {
  let counter = 1;
  for await (const line of lineIterator) {
    yield {
      counter,
      line
    };
    counter++;
  }
}

// node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/array-buffer-utils.js
function compareArrayBuffers(arrayBuffer1, arrayBuffer2, byteLength) {
  byteLength = byteLength || arrayBuffer1.byteLength;
  if (arrayBuffer1.byteLength < byteLength || arrayBuffer2.byteLength < byteLength) {
    return false;
  }
  const array1 = new Uint8Array(arrayBuffer1);
  const array2 = new Uint8Array(arrayBuffer2);
  for (let i = 0; i < array1.length; ++i) {
    if (array1[i] !== array2[i]) {
      return false;
    }
  }
  return true;
}
function concatenateArrayBuffers() {
  for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {
    sources[_key] = arguments[_key];
  }
  const sourceArrays = sources.map((source2) => source2 instanceof ArrayBuffer ? new Uint8Array(source2) : source2);
  const byteLength = sourceArrays.reduce((length, typedArray) => length + typedArray.byteLength, 0);
  const result = new Uint8Array(byteLength);
  let offset = 0;
  for (const sourceArray of sourceArrays) {
    result.set(sourceArray, offset);
    offset += sourceArray.byteLength;
  }
  return result.buffer;
}
function sliceArrayBuffer(arrayBuffer, byteOffset, byteLength) {
  const subArray = byteLength !== void 0 ? new Uint8Array(arrayBuffer).subarray(byteOffset, byteOffset + byteLength) : new Uint8Array(arrayBuffer).subarray(byteOffset);
  const arrayCopy = new Uint8Array(subArray);
  return arrayCopy.buffer;
}

// node_modules/@loaders.gl/loader-utils/dist/esm/lib/iterators/async-iteration.js
async function forEach(iterator, visitor) {
  while (true) {
    const {
      done,
      value
    } = await iterator.next();
    if (done) {
      iterator.return();
      return;
    }
    const cancel = visitor(value);
    if (cancel) {
      return;
    }
  }
}
async function concatenateArrayBuffersAsync(asyncIterator) {
  const arrayBuffers = [];
  for await (const chunk of asyncIterator) {
    arrayBuffers.push(chunk);
  }
  return concatenateArrayBuffers(...arrayBuffers);
}

// node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}

// node_modules/@babel/runtime/helpers/esm/toPrimitive.js
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}

// node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}

// node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

// node_modules/@probe.gl/stats/dist/esm/utils/hi-res-timestamp.js
function getHiResTimestamp() {
  let timestamp;
  if (typeof window !== "undefined" && window.performance) {
    timestamp = window.performance.now();
  } else if (typeof process !== "undefined" && process.hrtime) {
    const timeParts = process.hrtime();
    timestamp = timeParts[0] * 1e3 + timeParts[1] / 1e6;
  } else {
    timestamp = Date.now();
  }
  return timestamp;
}

// node_modules/@probe.gl/stats/dist/esm/lib/stat.js
var Stat = class {
  constructor(name, type) {
    _defineProperty(this, "name", void 0);
    _defineProperty(this, "type", void 0);
    _defineProperty(this, "sampleSize", 1);
    _defineProperty(this, "time", void 0);
    _defineProperty(this, "count", void 0);
    _defineProperty(this, "samples", void 0);
    _defineProperty(this, "lastTiming", void 0);
    _defineProperty(this, "lastSampleTime", void 0);
    _defineProperty(this, "lastSampleCount", void 0);
    _defineProperty(this, "_count", 0);
    _defineProperty(this, "_time", 0);
    _defineProperty(this, "_samples", 0);
    _defineProperty(this, "_startTime", 0);
    _defineProperty(this, "_timerPending", false);
    this.name = name;
    this.type = type;
    this.reset();
  }
  setSampleSize(samples) {
    this.sampleSize = samples;
    return this;
  }
  incrementCount() {
    this.addCount(1);
    return this;
  }
  decrementCount() {
    this.subtractCount(1);
    return this;
  }
  addCount(value) {
    this._count += value;
    this._samples++;
    this._checkSampling();
    return this;
  }
  subtractCount(value) {
    this._count -= value;
    this._samples++;
    this._checkSampling();
    return this;
  }
  addTime(time) {
    this._time += time;
    this.lastTiming = time;
    this._samples++;
    this._checkSampling();
    return this;
  }
  timeStart() {
    this._startTime = getHiResTimestamp();
    this._timerPending = true;
    return this;
  }
  timeEnd() {
    if (!this._timerPending) {
      return this;
    }
    this.addTime(getHiResTimestamp() - this._startTime);
    this._timerPending = false;
    this._checkSampling();
    return this;
  }
  getSampleAverageCount() {
    return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0;
  }
  getSampleAverageTime() {
    return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0;
  }
  getSampleHz() {
    return this.lastSampleTime > 0 ? this.sampleSize / (this.lastSampleTime / 1e3) : 0;
  }
  getAverageCount() {
    return this.samples > 0 ? this.count / this.samples : 0;
  }
  getAverageTime() {
    return this.samples > 0 ? this.time / this.samples : 0;
  }
  getHz() {
    return this.time > 0 ? this.samples / (this.time / 1e3) : 0;
  }
  reset() {
    this.time = 0;
    this.count = 0;
    this.samples = 0;
    this.lastTiming = 0;
    this.lastSampleTime = 0;
    this.lastSampleCount = 0;
    this._count = 0;
    this._time = 0;
    this._samples = 0;
    this._startTime = 0;
    this._timerPending = false;
    return this;
  }
  _checkSampling() {
    if (this._samples === this.sampleSize) {
      this.lastSampleTime = this._time;
      this.lastSampleCount = this._count;
      this.count += this._count;
      this.time += this._time;
      this.samples += this._samples;
      this._time = 0;
      this._count = 0;
      this._samples = 0;
    }
  }
};

// node_modules/@probe.gl/stats/dist/esm/lib/stats.js
var Stats = class {
  constructor(options) {
    _defineProperty(this, "id", void 0);
    _defineProperty(this, "stats", {});
    this.id = options.id;
    this.stats = {};
    this._initializeStats(options.stats);
    Object.seal(this);
  }
  get(name) {
    let type = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "count";
    return this._getOrCreate({
      name,
      type
    });
  }
  get size() {
    return Object.keys(this.stats).length;
  }
  reset() {
    for (const key in this.stats) {
      this.stats[key].reset();
    }
    return this;
  }
  forEach(fn) {
    for (const key in this.stats) {
      fn(this.stats[key]);
    }
  }
  getTable() {
    const table = {};
    this.forEach((stat2) => {
      table[stat2.name] = {
        time: stat2.time || 0,
        count: stat2.count || 0,
        average: stat2.getAverageTime() || 0,
        hz: stat2.getHz() || 0
      };
    });
    return table;
  }
  _initializeStats() {
    let stats = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    stats.forEach((stat2) => this._getOrCreate(stat2));
  }
  _getOrCreate(stat2) {
    if (!stat2 || !stat2.name) {
      return null;
    }
    const {
      name,
      type
    } = stat2;
    if (!this.stats[name]) {
      if (stat2 instanceof Stat) {
        this.stats[name] = stat2;
      } else {
        this.stats[name] = new Stat(name, type);
      }
    }
    return this.stats[name];
  }
};

// node_modules/@loaders.gl/loader-utils/dist/esm/lib/request-utils/request-scheduler.js
var STAT_QUEUED_REQUESTS = "Queued Requests";
var STAT_ACTIVE_REQUESTS = "Active Requests";
var STAT_CANCELLED_REQUESTS = "Cancelled Requests";
var STAT_QUEUED_REQUESTS_EVER = "Queued Requests Ever";
var STAT_ACTIVE_REQUESTS_EVER = "Active Requests Ever";
var DEFAULT_PROPS = {
  id: "request-scheduler",
  throttleRequests: true,
  maxRequests: 6
};
var RequestScheduler = class {
  constructor() {
    let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _defineProperty(this, "props", void 0);
    _defineProperty(this, "stats", void 0);
    _defineProperty(this, "activeRequestCount", 0);
    _defineProperty(this, "requestQueue", []);
    _defineProperty(this, "requestMap", /* @__PURE__ */ new Map());
    _defineProperty(this, "deferredUpdate", null);
    this.props = {
      ...DEFAULT_PROPS,
      ...props
    };
    this.stats = new Stats({
      id: this.props.id
    });
    this.stats.get(STAT_QUEUED_REQUESTS);
    this.stats.get(STAT_ACTIVE_REQUESTS);
    this.stats.get(STAT_CANCELLED_REQUESTS);
    this.stats.get(STAT_QUEUED_REQUESTS_EVER);
    this.stats.get(STAT_ACTIVE_REQUESTS_EVER);
  }
  scheduleRequest(handle) {
    let getPriority = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : () => 0;
    if (!this.props.throttleRequests) {
      return Promise.resolve({
        done: () => {
        }
      });
    }
    if (this.requestMap.has(handle)) {
      return this.requestMap.get(handle);
    }
    const request = {
      handle,
      priority: 0,
      getPriority
    };
    const promise = new Promise((resolve) => {
      request.resolve = resolve;
      return request;
    });
    this.requestQueue.push(request);
    this.requestMap.set(handle, promise);
    this._issueNewRequests();
    return promise;
  }
  _issueRequest(request) {
    const {
      handle,
      resolve
    } = request;
    let isDone = false;
    const done = () => {
      if (!isDone) {
        isDone = true;
        this.requestMap.delete(handle);
        this.activeRequestCount--;
        this._issueNewRequests();
      }
    };
    this.activeRequestCount++;
    return resolve ? resolve({
      done
    }) : Promise.resolve({
      done
    });
  }
  _issueNewRequests() {
    if (!this.deferredUpdate) {
      this.deferredUpdate = setTimeout(() => this._issueNewRequestsAsync(), 0);
    }
  }
  _issueNewRequestsAsync() {
    this.deferredUpdate = null;
    const freeSlots = Math.max(this.props.maxRequests - this.activeRequestCount, 0);
    if (freeSlots === 0) {
      return;
    }
    this._updateAllRequests();
    for (let i = 0; i < freeSlots; ++i) {
      const request = this.requestQueue.shift();
      if (request) {
        this._issueRequest(request);
      }
    }
  }
  _updateAllRequests() {
    const requestQueue = this.requestQueue;
    for (let i = 0; i < requestQueue.length; ++i) {
      const request = requestQueue[i];
      if (!this._updateRequest(request)) {
        requestQueue.splice(i, 1);
        this.requestMap.delete(request.handle);
        i--;
      }
    }
    requestQueue.sort((a, b) => a.priority - b.priority);
  }
  _updateRequest(request) {
    request.priority = request.getPriority(request.handle);
    if (request.priority < 0) {
      request.resolve(null);
      return false;
    }
    return true;
  }
};

// node_modules/@loaders.gl/loader-utils/dist/esm/lib/path-utils/file-aliases.js
var pathPrefix = "";
var fileAliases = {};
function setPathPrefix(prefix) {
  pathPrefix = prefix;
}
function getPathPrefix() {
  return pathPrefix;
}
function resolvePath(filename2) {
  for (const alias in fileAliases) {
    if (filename2.startsWith(alias)) {
      const replacement = fileAliases[alias];
      filename2 = filename2.replace(alias, replacement);
    }
  }
  if (!filename2.startsWith("http://") && !filename2.startsWith("https://")) {
    filename2 = "".concat(pathPrefix).concat(filename2);
  }
  return filename2;
}

// node_modules/@loaders.gl/loader-utils/dist/esm/json-loader.js
var VERSION = true ? "3.3.3" : "latest";
var JSONLoader = {
  name: "JSON",
  id: "json",
  module: "json",
  version: VERSION,
  extensions: ["json", "geojson"],
  mimeTypes: ["application/json"],
  category: "json",
  text: true,
  parseTextSync,
  parse: async (arrayBuffer) => parseTextSync(new TextDecoder().decode(arrayBuffer)),
  options: {}
};
function parseTextSync(text) {
  return JSON.parse(text);
}

// node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/version.js
var VERSION2 = true ? "3.3.3" : DEFAULT_VERSION;
if (false) {
  console.error("loaders.gl: The __VERSION__ variable is not injected using babel plugin. Latest unstable workers would be fetched from the CDN.");
}

// node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/assert.js
function assert2(condition, message) {
  if (!condition) {
    throw new Error(message || "loaders.gl assertion failed.");
  }
}

// node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/globals.js
var globals2 = {
  self: typeof self !== "undefined" && self,
  window: typeof window !== "undefined" && window,
  global: typeof global !== "undefined" && global,
  document: typeof document !== "undefined" && document
};
var self_2 = globals2.self || globals2.window || globals2.global || {};
var window_2 = globals2.window || globals2.self || globals2.global || {};
var global_2 = globals2.global || globals2.self || globals2.window || {};
var document_2 = globals2.document || {};
var isBrowser2 = typeof process !== "object" || String(process) !== "[object process]" || process.browser;
var isWorker2 = typeof importScripts === "function";
var isMobile = typeof window !== "undefined" && typeof window.orientation !== "undefined";
var matches2 = typeof process !== "undefined" && process.version && /v([0-9]*)/.exec(process.version);
var nodeVersion2 = matches2 && parseFloat(matches2[1]) || 0;

// node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-job.js
var WorkerJob = class {
  constructor(jobName, workerThread) {
    _defineProperty(this, "name", void 0);
    _defineProperty(this, "workerThread", void 0);
    _defineProperty(this, "isRunning", true);
    _defineProperty(this, "result", void 0);
    _defineProperty(this, "_resolve", () => {
    });
    _defineProperty(this, "_reject", () => {
    });
    this.name = jobName;
    this.workerThread = workerThread;
    this.result = new Promise((resolve, reject) => {
      this._resolve = resolve;
      this._reject = reject;
    });
  }
  postMessage(type, payload) {
    this.workerThread.postMessage({
      source: "loaders.gl",
      type,
      payload
    });
  }
  done(value) {
    assert2(this.isRunning);
    this.isRunning = false;
    this._resolve(value);
  }
  error(error) {
    assert2(this.isRunning);
    this.isRunning = false;
    this._reject(error);
  }
};

// node_modules/@loaders.gl/worker-utils/dist/esm/lib/node/worker_threads-browser.js
var Worker2 = class {
  terminate() {
  }
};

// node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-utils/get-loadable-worker-url.js
var workerURLCache = /* @__PURE__ */ new Map();
function getLoadableWorkerURL(props) {
  assert2(props.source && !props.url || !props.source && props.url);
  let workerURL = workerURLCache.get(props.source || props.url);
  if (!workerURL) {
    if (props.url) {
      workerURL = getLoadableWorkerURLFromURL(props.url);
      workerURLCache.set(props.url, workerURL);
    }
    if (props.source) {
      workerURL = getLoadableWorkerURLFromSource(props.source);
      workerURLCache.set(props.source, workerURL);
    }
  }
  assert2(workerURL);
  return workerURL;
}
function getLoadableWorkerURLFromURL(url) {
  if (!url.startsWith("http")) {
    return url;
  }
  const workerSource = buildScriptSource(url);
  return getLoadableWorkerURLFromSource(workerSource);
}
function getLoadableWorkerURLFromSource(workerSource) {
  const blob = new Blob([workerSource], {
    type: "application/javascript"
  });
  return URL.createObjectURL(blob);
}
function buildScriptSource(workerUrl) {
  return "try {\n  importScripts('".concat(workerUrl, "');\n} catch (error) {\n  console.error(error);\n  throw error;\n}");
}

// node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-utils/get-transfer-list.js
function getTransferList(object) {
  let recursive = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  let transfers = arguments.length > 2 ? arguments[2] : void 0;
  const transfersSet = transfers || /* @__PURE__ */ new Set();
  if (!object) {
  } else if (isTransferable(object)) {
    transfersSet.add(object);
  } else if (isTransferable(object.buffer)) {
    transfersSet.add(object.buffer);
  } else if (ArrayBuffer.isView(object)) {
  } else if (recursive && typeof object === "object") {
    for (const key in object) {
      getTransferList(object[key], recursive, transfersSet);
    }
  }
  return transfers === void 0 ? Array.from(transfersSet) : [];
}
function isTransferable(object) {
  if (!object) {
    return false;
  }
  if (object instanceof ArrayBuffer) {
    return true;
  }
  if (typeof MessagePort !== "undefined" && object instanceof MessagePort) {
    return true;
  }
  if (typeof ImageBitmap !== "undefined" && object instanceof ImageBitmap) {
    return true;
  }
  if (typeof OffscreenCanvas !== "undefined" && object instanceof OffscreenCanvas) {
    return true;
  }
  return false;
}
function getTransferListForWriter(object) {
  if (object === null) {
    return {};
  }
  const clone = Object.assign({}, object);
  Object.keys(clone).forEach((key) => {
    if (typeof object[key] === "object" && !ArrayBuffer.isView(object[key]) && !(object[key] instanceof Array)) {
      clone[key] = getTransferListForWriter(object[key]);
    } else if (typeof clone[key] === "function" || clone[key] instanceof RegExp) {
      clone[key] = {};
    } else {
      clone[key] = object[key];
    }
  });
  return clone;
}

// node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-thread.js
var NOOP = () => {
};
var WorkerThread = class {
  static isSupported() {
    return typeof Worker !== "undefined" && isBrowser2 || typeof Worker2 !== "undefined" && !isBrowser2;
  }
  constructor(props) {
    _defineProperty(this, "name", void 0);
    _defineProperty(this, "source", void 0);
    _defineProperty(this, "url", void 0);
    _defineProperty(this, "terminated", false);
    _defineProperty(this, "worker", void 0);
    _defineProperty(this, "onMessage", void 0);
    _defineProperty(this, "onError", void 0);
    _defineProperty(this, "_loadableURL", "");
    const {
      name,
      source,
      url
    } = props;
    assert2(source || url);
    this.name = name;
    this.source = source;
    this.url = url;
    this.onMessage = NOOP;
    this.onError = (error) => console.log(error);
    this.worker = isBrowser2 ? this._createBrowserWorker() : this._createNodeWorker();
  }
  destroy() {
    this.onMessage = NOOP;
    this.onError = NOOP;
    this.worker.terminate();
    this.terminated = true;
  }
  get isRunning() {
    return Boolean(this.onMessage);
  }
  postMessage(data, transferList) {
    transferList = transferList || getTransferList(data);
    this.worker.postMessage(data, transferList);
  }
  _getErrorFromErrorEvent(event) {
    let message = "Failed to load ";
    message += "worker ".concat(this.name, " from ").concat(this.url, ". ");
    if (event.message) {
      message += "".concat(event.message, " in ");
    }
    if (event.lineno) {
      message += ":".concat(event.lineno, ":").concat(event.colno);
    }
    return new Error(message);
  }
  _createBrowserWorker() {
    this._loadableURL = getLoadableWorkerURL({
      source: this.source,
      url: this.url
    });
    const worker = new Worker(this._loadableURL, {
      name: this.name
    });
    worker.onmessage = (event) => {
      if (!event.data) {
        this.onError(new Error("No data received"));
      } else {
        this.onMessage(event.data);
      }
    };
    worker.onerror = (error) => {
      this.onError(this._getErrorFromErrorEvent(error));
      this.terminated = true;
    };
    worker.onmessageerror = (event) => console.error(event);
    return worker;
  }
  _createNodeWorker() {
    let worker;
    if (this.url) {
      const absolute = this.url.includes(":/") || this.url.startsWith("/");
      const url = absolute ? this.url : "./".concat(this.url);
      worker = new Worker2(url, {
        eval: false
      });
    } else if (this.source) {
      worker = new Worker2(this.source, {
        eval: true
      });
    } else {
      throw new Error("no worker");
    }
    worker.on("message", (data) => {
      this.onMessage(data);
    });
    worker.on("error", (error) => {
      this.onError(error);
    });
    worker.on("exit", (code) => {
    });
    return worker;
  }
};

// node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-pool.js
var WorkerPool = class {
  static isSupported() {
    return WorkerThread.isSupported();
  }
  constructor(props) {
    _defineProperty(this, "name", "unnamed");
    _defineProperty(this, "source", void 0);
    _defineProperty(this, "url", void 0);
    _defineProperty(this, "maxConcurrency", 1);
    _defineProperty(this, "maxMobileConcurrency", 1);
    _defineProperty(this, "onDebug", () => {
    });
    _defineProperty(this, "reuseWorkers", true);
    _defineProperty(this, "props", {});
    _defineProperty(this, "jobQueue", []);
    _defineProperty(this, "idleQueue", []);
    _defineProperty(this, "count", 0);
    _defineProperty(this, "isDestroyed", false);
    this.source = props.source;
    this.url = props.url;
    this.setProps(props);
  }
  destroy() {
    this.idleQueue.forEach((worker) => worker.destroy());
    this.isDestroyed = true;
  }
  setProps(props) {
    this.props = {
      ...this.props,
      ...props
    };
    if (props.name !== void 0) {
      this.name = props.name;
    }
    if (props.maxConcurrency !== void 0) {
      this.maxConcurrency = props.maxConcurrency;
    }
    if (props.maxMobileConcurrency !== void 0) {
      this.maxMobileConcurrency = props.maxMobileConcurrency;
    }
    if (props.reuseWorkers !== void 0) {
      this.reuseWorkers = props.reuseWorkers;
    }
    if (props.onDebug !== void 0) {
      this.onDebug = props.onDebug;
    }
  }
  async startJob(name) {
    let onMessage3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : (job, type, data) => job.done(data);
    let onError = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : (job, error) => job.error(error);
    const startPromise = new Promise((onStart) => {
      this.jobQueue.push({
        name,
        onMessage: onMessage3,
        onError,
        onStart
      });
      return this;
    });
    this._startQueuedJob();
    return await startPromise;
  }
  async _startQueuedJob() {
    if (!this.jobQueue.length) {
      return;
    }
    const workerThread = this._getAvailableWorker();
    if (!workerThread) {
      return;
    }
    const queuedJob = this.jobQueue.shift();
    if (queuedJob) {
      this.onDebug({
        message: "Starting job",
        name: queuedJob.name,
        workerThread,
        backlog: this.jobQueue.length
      });
      const job = new WorkerJob(queuedJob.name, workerThread);
      workerThread.onMessage = (data) => queuedJob.onMessage(job, data.type, data.payload);
      workerThread.onError = (error) => queuedJob.onError(job, error);
      queuedJob.onStart(job);
      try {
        await job.result;
      } finally {
        this.returnWorkerToQueue(workerThread);
      }
    }
  }
  returnWorkerToQueue(worker) {
    const shouldDestroyWorker = this.isDestroyed || !this.reuseWorkers || this.count > this._getMaxConcurrency();
    if (shouldDestroyWorker) {
      worker.destroy();
      this.count--;
    } else {
      this.idleQueue.push(worker);
    }
    if (!this.isDestroyed) {
      this._startQueuedJob();
    }
  }
  _getAvailableWorker() {
    if (this.idleQueue.length > 0) {
      return this.idleQueue.shift() || null;
    }
    if (this.count < this._getMaxConcurrency()) {
      this.count++;
      const name = "".concat(this.name.toLowerCase(), " (#").concat(this.count, " of ").concat(this.maxConcurrency, ")");
      return new WorkerThread({
        name,
        source: this.source,
        url: this.url
      });
    }
    return null;
  }
  _getMaxConcurrency() {
    return isMobile ? this.maxMobileConcurrency : this.maxConcurrency;
  }
};

// node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-farm.js
var DEFAULT_PROPS2 = {
  maxConcurrency: 3,
  maxMobileConcurrency: 1,
  reuseWorkers: true,
  onDebug: () => {
  }
};
var WorkerFarm = class {
  static isSupported() {
    return WorkerThread.isSupported();
  }
  static getWorkerFarm() {
    let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    WorkerFarm._workerFarm = WorkerFarm._workerFarm || new WorkerFarm({});
    WorkerFarm._workerFarm.setProps(props);
    return WorkerFarm._workerFarm;
  }
  constructor(props) {
    _defineProperty(this, "props", void 0);
    _defineProperty(this, "workerPools", /* @__PURE__ */ new Map());
    this.props = {
      ...DEFAULT_PROPS2
    };
    this.setProps(props);
    this.workerPools = /* @__PURE__ */ new Map();
  }
  destroy() {
    for (const workerPool of this.workerPools.values()) {
      workerPool.destroy();
    }
    this.workerPools = /* @__PURE__ */ new Map();
  }
  setProps(props) {
    this.props = {
      ...this.props,
      ...props
    };
    for (const workerPool of this.workerPools.values()) {
      workerPool.setProps(this._getWorkerPoolProps());
    }
  }
  getWorkerPool(options) {
    const {
      name,
      source,
      url
    } = options;
    let workerPool = this.workerPools.get(name);
    if (!workerPool) {
      workerPool = new WorkerPool({
        name,
        source,
        url
      });
      workerPool.setProps(this._getWorkerPoolProps());
      this.workerPools.set(name, workerPool);
    }
    return workerPool;
  }
  _getWorkerPoolProps() {
    return {
      maxConcurrency: this.props.maxConcurrency,
      maxMobileConcurrency: this.props.maxMobileConcurrency,
      reuseWorkers: this.props.reuseWorkers,
      onDebug: this.props.onDebug
    };
  }
};
_defineProperty(WorkerFarm, "_workerFarm", void 0);

// node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-body.js
function getParentPort() {
  let parentPort;
  try {
    eval("globalThis.parentPort = require('worker_threads').parentPort");
    parentPort = globalThis.parentPort;
  } catch {
  }
  return parentPort;
}
var onMessageWrapperMap = /* @__PURE__ */ new Map();
var WorkerBody = class {
  static inWorkerThread() {
    return typeof self !== "undefined" || Boolean(getParentPort());
  }
  static set onmessage(onMessage3) {
    function handleMessage(message) {
      const parentPort3 = getParentPort();
      const {
        type,
        payload
      } = parentPort3 ? message : message.data;
      onMessage3(type, payload);
    }
    const parentPort2 = getParentPort();
    if (parentPort2) {
      parentPort2.on("message", handleMessage);
      parentPort2.on("exit", () => console.debug("Node worker closing"));
    } else {
      globalThis.onmessage = handleMessage;
    }
  }
  static addEventListener(onMessage3) {
    let onMessageWrapper = onMessageWrapperMap.get(onMessage3);
    if (!onMessageWrapper) {
      onMessageWrapper = (message) => {
        if (!isKnownMessage(message)) {
          return;
        }
        const parentPort3 = getParentPort();
        const {
          type,
          payload
        } = parentPort3 ? message : message.data;
        onMessage3(type, payload);
      };
    }
    const parentPort2 = getParentPort();
    if (parentPort2) {
      console.error("not implemented");
    } else {
      globalThis.addEventListener("message", onMessageWrapper);
    }
  }
  static removeEventListener(onMessage3) {
    const onMessageWrapper = onMessageWrapperMap.get(onMessage3);
    onMessageWrapperMap.delete(onMessage3);
    const parentPort2 = getParentPort();
    if (parentPort2) {
      console.error("not implemented");
    } else {
      globalThis.removeEventListener("message", onMessageWrapper);
    }
  }
  static postMessage(type, payload) {
    const data = {
      source: "loaders.gl",
      type,
      payload
    };
    const transferList = getTransferList(payload);
    const parentPort2 = getParentPort();
    if (parentPort2) {
      parentPort2.postMessage(data, transferList);
    } else {
      globalThis.postMessage(data, transferList);
    }
  }
};
function isKnownMessage(message) {
  const {
    type,
    data
  } = message;
  return type === "message" && data && typeof data.source === "string" && data.source.startsWith("loaders.gl");
}

// node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-api/get-worker-url.js
var NPM_TAG = "latest";
var VERSION3 = true ? "3.3.3" : NPM_TAG;
function getWorkerName(worker) {
  const warning = worker.version !== VERSION3 ? " (worker-utils@".concat(VERSION3, ")") : "";
  return "".concat(worker.name, "@").concat(worker.version).concat(warning);
}
function getWorkerURL(worker) {
  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const workerOptions = options[worker.id] || {};
  const workerFile = "".concat(worker.id, "-worker.js");
  let url = workerOptions.workerUrl;
  if (!url && worker.id === "compression") {
    url = options.workerUrl;
  }
  if (options._workerType === "test") {
    url = "modules/".concat(worker.module, "/dist/").concat(workerFile);
  }
  if (!url) {
    let version = worker.version;
    if (version === "latest") {
      version = NPM_TAG;
    }
    const versionTag = version ? "@".concat(version) : "";
    url = "https://unpkg.com/@loaders.gl/".concat(worker.module).concat(versionTag, "/dist/").concat(workerFile);
  }
  assert2(url);
  return url;
}

// node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-api/process-on-worker.js
async function processOnWorker(worker, data) {
  let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  let context = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  const name = getWorkerName(worker);
  const workerFarm = WorkerFarm.getWorkerFarm(options);
  const {
    source
  } = options;
  const workerPoolProps = {
    name,
    source
  };
  if (!source) {
    workerPoolProps.url = getWorkerURL(worker, options);
  }
  const workerPool = workerFarm.getWorkerPool(workerPoolProps);
  const jobName = options.jobName || worker.name;
  const job = await workerPool.startJob(
    jobName,
    onMessage.bind(null, context)
  );
  const transferableOptions = getTransferListForWriter(options);
  job.postMessage("process", {
    input: data,
    options: transferableOptions
  });
  const result = await job.result;
  return result.result;
}
async function onMessage(context, job, type, payload) {
  switch (type) {
    case "done":
      job.done(payload);
      break;
    case "error":
      job.error(new Error(payload.error));
      break;
    case "process":
      const {
        id,
        input,
        options
      } = payload;
      try {
        if (!context.process) {
          job.postMessage("error", {
            id,
            error: "Worker not set up to process on main thread"
          });
          return;
        }
        const result = await context.process(input, options);
        job.postMessage("done", {
          id,
          result
        });
      } catch (error) {
        const message = error instanceof Error ? error.message : "unknown error";
        job.postMessage("error", {
          id,
          error: message
        });
      }
      break;
    default:
      console.warn("process-on-worker: unknown message ".concat(type));
  }
}

// node_modules/@loaders.gl/worker-utils/dist/esm/lib/async-queue/async-queue.js
var _Symbol$asyncIterator;
_Symbol$asyncIterator = Symbol.asyncIterator;
var AsyncQueue = class {
  constructor() {
    _defineProperty(this, "_values", void 0);
    _defineProperty(this, "_settlers", void 0);
    _defineProperty(this, "_closed", void 0);
    this._values = [];
    this._settlers = [];
    this._closed = false;
  }
  [_Symbol$asyncIterator]() {
    return this;
  }
  push(value) {
    return this.enqueue(value);
  }
  enqueue(value) {
    if (this._closed) {
      throw new Error("Closed");
    }
    if (this._settlers.length > 0) {
      if (this._values.length > 0) {
        throw new Error("Illegal internal state");
      }
      const settler = this._settlers.shift();
      if (value instanceof Error) {
        settler.reject(value);
      } else {
        settler.resolve({
          value
        });
      }
    } else {
      this._values.push(value);
    }
  }
  close() {
    while (this._settlers.length > 0) {
      const settler = this._settlers.shift();
      settler.resolve({
        done: true
      });
    }
    this._closed = true;
  }
  next() {
    if (this._values.length > 0) {
      const value = this._values.shift();
      if (value instanceof Error) {
        return Promise.reject(value);
      }
      return Promise.resolve({
        done: false,
        value
      });
    }
    if (this._closed) {
      if (this._settlers.length > 0) {
        throw new Error("Illegal internal state");
      }
      return Promise.resolve({
        done: true,
        value: void 0
      });
    }
    return new Promise((resolve, reject) => {
      this._settlers.push({
        resolve,
        reject
      });
    });
  }
};

// node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-api/validate-worker-version.js
function validateWorkerVersion(worker) {
  let coreVersion = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : VERSION2;
  assert2(worker, "no worker provided");
  const workerVersion = worker.version;
  if (!coreVersion || !workerVersion) {
    return false;
  }
  return true;
}

// node_modules/@loaders.gl/worker-utils/dist/esm/lib/library-utils/library-utils.js
var node = __toESM(require_require_utils());
var VERSION4 = true ? "3.3.3" : LATEST;
var loadLibraryPromises = {};
async function loadLibrary(libraryUrl) {
  let moduleName = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (moduleName) {
    libraryUrl = getLibraryUrl(libraryUrl, moduleName, options);
  }
  loadLibraryPromises[libraryUrl] = loadLibraryPromises[libraryUrl] || loadLibraryFromFile(libraryUrl);
  return await loadLibraryPromises[libraryUrl];
}
function getLibraryUrl(library, moduleName, options) {
  if (library.startsWith("http")) {
    return library;
  }
  const modules = options.modules || {};
  if (modules[library]) {
    return modules[library];
  }
  if (!isBrowser2) {
    return "modules/".concat(moduleName, "/dist/libs/").concat(library);
  }
  if (options.CDN) {
    assert2(options.CDN.startsWith("http"));
    return "".concat(options.CDN, "/").concat(moduleName, "@").concat(VERSION4, "/dist/libs/").concat(library);
  }
  if (isWorker2) {
    return "../src/libs/".concat(library);
  }
  return "modules/".concat(moduleName, "/src/libs/").concat(library);
}
async function loadLibraryFromFile(libraryUrl) {
  if (libraryUrl.endsWith("wasm")) {
    const response2 = await fetch(libraryUrl);
    return await response2.arrayBuffer();
  }
  if (!isBrowser2) {
    try {
      return node && void 0 && await (void 0)(libraryUrl);
    } catch {
      return null;
    }
  }
  if (isWorker2) {
    return importScripts(libraryUrl);
  }
  const response = await fetch(libraryUrl);
  const scriptSource = await response.text();
  return loadLibraryFromString(scriptSource, libraryUrl);
}
function loadLibraryFromString(scriptSource, id) {
  if (!isBrowser2) {
    return void 0 && (void 0)(scriptSource, id);
  }
  if (isWorker2) {
    eval.call(global_2, scriptSource);
    return null;
  }
  const script = document.createElement("script");
  script.id = id;
  try {
    script.appendChild(document.createTextNode(scriptSource));
  } catch (e) {
    script.text = scriptSource;
  }
  document.body.appendChild(script);
  return null;
}

// node_modules/@loaders.gl/worker-utils/dist/esm/index.js
var import_child_process_proxy = __toESM(require_child_process_proxy());

// node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-loader-utils/parse-with-worker.js
function canParseWithWorker(loader, options) {
  if (!WorkerFarm.isSupported()) {
    return false;
  }
  if (!isBrowser2 && !(options !== null && options !== void 0 && options._nodeWorkers)) {
    return false;
  }
  return loader.worker && (options === null || options === void 0 ? void 0 : options.worker);
}
async function parseWithWorker(loader, data, options, context, parseOnMainThread) {
  const name = loader.id;
  const url = getWorkerURL(loader, options);
  const workerFarm = WorkerFarm.getWorkerFarm(options);
  const workerPool = workerFarm.getWorkerPool({
    name,
    url
  });
  options = JSON.parse(JSON.stringify(options));
  context = JSON.parse(JSON.stringify(context || {}));
  const job = await workerPool.startJob(
    "process-on-worker",
    onMessage2.bind(null, parseOnMainThread)
  );
  job.postMessage("process", {
    input: data,
    options,
    context
  });
  const result = await job.result;
  return await result.result;
}
async function onMessage2(parseOnMainThread, job, type, payload) {
  switch (type) {
    case "done":
      job.done(payload);
      break;
    case "error":
      job.error(new Error(payload.error));
      break;
    case "process":
      const {
        id,
        input,
        options
      } = payload;
      try {
        const result = await parseOnMainThread(input, options);
        job.postMessage("done", {
          id,
          result
        });
      } catch (error) {
        const message = error instanceof Error ? error.message : "unknown error";
        job.postMessage("error", {
          id,
          error: message
        });
      }
      break;
    default:
      console.warn("parse-with-worker unknown message ".concat(type));
  }
}

// node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-loader-utils/encode-with-worker.js
function canEncodeWithWorker(writer, options) {
  if (!WorkerFarm.isSupported()) {
    return false;
  }
  if (!isBrowser && !(options !== null && options !== void 0 && options._nodeWorkers)) {
    return false;
  }
  return writer.worker && (options === null || options === void 0 ? void 0 : options.worker);
}

// node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/get-first-characters.js
function getFirstCharacters(data) {
  let length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5;
  if (typeof data === "string") {
    return data.slice(0, length);
  } else if (ArrayBuffer.isView(data)) {
    return getMagicString(data.buffer, data.byteOffset, length);
  } else if (data instanceof ArrayBuffer) {
    const byteOffset = 0;
    return getMagicString(data, byteOffset, length);
  }
  return "";
}
function getMagicString(arrayBuffer, byteOffset, length) {
  if (arrayBuffer.byteLength <= byteOffset + length) {
    return "";
  }
  const dataView = new DataView(arrayBuffer);
  let magic = "";
  for (let i = 0; i < length; i++) {
    magic += String.fromCharCode(dataView.getUint8(byteOffset + i));
  }
  return magic;
}

// node_modules/@loaders.gl/loader-utils/dist/esm/lib/parser-utils/parse-json.js
function parseJSON(string) {
  try {
    return JSON.parse(string);
  } catch (_) {
    throw new Error('Failed to parse JSON from data starting with "'.concat(getFirstCharacters(string), '"'));
  }
}

// node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/memory-copy-utils.js
function padToNBytes(byteLength, padding) {
  assert(byteLength >= 0);
  assert(padding > 0);
  return byteLength + (padding - 1) & ~(padding - 1);
}
function copyToArray(source, target, targetOffset) {
  let sourceArray;
  if (source instanceof ArrayBuffer) {
    sourceArray = new Uint8Array(source);
  } else {
    const srcByteOffset = source.byteOffset;
    const srcByteLength = source.byteLength;
    sourceArray = new Uint8Array(source.buffer || source.arrayBuffer, srcByteOffset, srcByteLength);
  }
  target.set(sourceArray, targetOffset);
  return targetOffset + padToNBytes(sourceArray.byteLength, 4);
}

// node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/dataview-copy-utils.js
function copyPaddedArrayBufferToDataView(dataView, byteOffset, sourceBuffer, padding) {
  const paddedLength = padToNBytes(sourceBuffer.byteLength, padding);
  const padLength = paddedLength - sourceBuffer.byteLength;
  if (dataView) {
    const targetArray = new Uint8Array(dataView.buffer, dataView.byteOffset + byteOffset, sourceBuffer.byteLength);
    const sourceArray = new Uint8Array(sourceBuffer);
    targetArray.set(sourceArray);
    for (let i = 0; i < padLength; ++i) {
      dataView.setUint8(byteOffset + sourceBuffer.byteLength + i, 32);
    }
  }
  byteOffset += paddedLength;
  return byteOffset;
}
function copyPaddedStringToDataView(dataView, byteOffset, string, padding) {
  const textEncoder = new TextEncoder();
  const stringBuffer = textEncoder.encode(string);
  byteOffset = copyPaddedArrayBufferToDataView(dataView, byteOffset, stringBuffer, padding);
  return byteOffset;
}

// node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/memory-conversion-utils.js
var node2 = __toESM(require_buffer());
function isBuffer(value) {
  return value && typeof value === "object" && value.isBuffer;
}
function toBuffer2(data) {
  return void 0 ? (void 0)(data) : data;
}
function toArrayBuffer2(data) {
  if (isBuffer(data)) {
    return (void 0)(data);
  }
  if (data instanceof ArrayBuffer) {
    return data;
  }
  if (ArrayBuffer.isView(data)) {
    if (data.byteOffset === 0 && data.byteLength === data.buffer.byteLength) {
      return data.buffer;
    }
    return data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);
  }
  if (typeof data === "string") {
    const text = data;
    const uint8Array = new TextEncoder().encode(text);
    return uint8Array.buffer;
  }
  if (data && typeof data === "object" && data._toArrayBuffer) {
    return data._toArrayBuffer();
  }
  throw new Error("toArrayBuffer");
}

// node_modules/@loaders.gl/loader-utils/dist/esm/lib/path-utils/path.js
var path_exports = {};
__export(path_exports, {
  dirname: () => dirname,
  filename: () => filename,
  join: () => join
});
function filename(url) {
  const slashIndex = url && url.lastIndexOf("/");
  return slashIndex >= 0 ? url.substr(slashIndex + 1) : "";
}
function dirname(url) {
  const slashIndex = url && url.lastIndexOf("/");
  return slashIndex >= 0 ? url.substr(0, slashIndex) : "";
}
function join() {
  for (var _len = arguments.length, parts = new Array(_len), _key = 0; _key < _len; _key++) {
    parts[_key] = arguments[_key];
  }
  const separator = "/";
  parts = parts.map((part, index) => {
    if (index) {
      part = part.replace(new RegExp("^".concat(separator)), "");
    }
    if (index !== parts.length - 1) {
      part = part.replace(new RegExp("".concat(separator, "$")), "");
    }
    return part;
  });
  return parts.join(separator);
}

// node_modules/@loaders.gl/loader-utils/dist/esm/index.js
var fs3 = __toESM(require_fs());

// node_modules/@loaders.gl/loader-utils/dist/esm/lib/node/stream.js
var import_stream = __toESM(require_stream());
var Transform;
var isSupported = Boolean(import_stream.default);
try {
  Transform = import_stream.default.Transform;
} catch {
}

// node_modules/@loaders.gl/loader-utils/dist/esm/lib/filesystems/writable-file.js
var fs = __toESM(require_fs());

// node_modules/@loaders.gl/loader-utils/dist/esm/lib/filesystems/node-filesystem.js
var fs2 = __toESM(require_fs());

export {
  assert,
  self_,
  window_,
  global_,
  document_,
  isBrowser,
  isWorker,
  assert2,
  isBrowser2,
  _defineProperty,
  processOnWorker,
  validateWorkerVersion,
  loadLibrary,
  canParseWithWorker,
  parseWithWorker,
  canEncodeWithWorker,
  parseJSON,
  compareArrayBuffers,
  concatenateArrayBuffers,
  sliceArrayBuffer,
  padToNBytes,
  copyToArray,
  copyPaddedArrayBufferToDataView,
  copyPaddedStringToDataView,
  makeTextDecoderIterator,
  makeTextEncoderIterator,
  makeLineIterator,
  makeNumberedLineIterator,
  forEach,
  concatenateArrayBuffersAsync,
  Stats,
  RequestScheduler,
  setPathPrefix,
  getPathPrefix,
  resolvePath,
  JSONLoader,
  toBuffer2 as toBuffer,
  toArrayBuffer2 as toArrayBuffer,
  path_exports,
  fs3 as fs
};
//# sourceMappingURL=chunk-NVCU2VMH.js.map
