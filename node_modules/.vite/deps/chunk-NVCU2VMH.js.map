{
  "version": 3,
  "sources": ["browser-external:stream", "../../@loaders.gl/loader-utils/src/lib/env-utils/assert.ts", "../../@loaders.gl/loader-utils/src/lib/env-utils/globals.ts", "../../@loaders.gl/loader-utils/src/lib/iterators/text-iterators.ts", "../../@loaders.gl/loader-utils/src/lib/binary-utils/array-buffer-utils.ts", "../../@loaders.gl/loader-utils/src/lib/iterators/async-iteration.ts", "../../@babel/runtime/helpers/esm/typeof.js", "../../@babel/runtime/helpers/esm/toPrimitive.js", "../../@babel/runtime/helpers/esm/toPropertyKey.js", "../../@babel/runtime/helpers/esm/defineProperty.js", "../../@probe.gl/stats/src/utils/hi-res-timestamp.ts", "../../@probe.gl/stats/src/lib/stat.ts", "../../@probe.gl/stats/src/lib/stats.ts", "../../@loaders.gl/loader-utils/src/lib/request-utils/request-scheduler.ts", "../../@loaders.gl/loader-utils/src/lib/path-utils/file-aliases.ts", "../../@loaders.gl/loader-utils/src/json-loader.ts", "../../@loaders.gl/worker-utils/src/lib/env-utils/version.ts", "../../@loaders.gl/worker-utils/src/lib/env-utils/assert.ts", "../../@loaders.gl/worker-utils/src/lib/env-utils/globals.ts", "../../@loaders.gl/worker-utils/src/lib/worker-farm/worker-job.ts", "../../@loaders.gl/worker-utils/src/lib/node/worker_threads-browser.ts", "../../@loaders.gl/worker-utils/src/lib/worker-utils/get-loadable-worker-url.ts", "../../@loaders.gl/worker-utils/src/lib/worker-utils/get-transfer-list.ts", "../../@loaders.gl/worker-utils/src/lib/worker-farm/worker-thread.ts", "../../@loaders.gl/worker-utils/src/lib/worker-farm/worker-pool.ts", "../../@loaders.gl/worker-utils/src/lib/worker-farm/worker-farm.ts", "../../@loaders.gl/worker-utils/src/lib/worker-farm/worker-body.ts", "../../@loaders.gl/worker-utils/src/lib/worker-api/get-worker-url.ts", "../../@loaders.gl/worker-utils/src/lib/worker-api/process-on-worker.ts", "../../@loaders.gl/worker-utils/src/lib/async-queue/async-queue.ts", "../../@loaders.gl/worker-utils/src/lib/worker-api/validate-worker-version.ts", "../../@loaders.gl/worker-utils/src/lib/library-utils/library-utils.ts", "../../@loaders.gl/worker-utils/src/index.ts", "../../@loaders.gl/loader-utils/src/lib/worker-loader-utils/parse-with-worker.ts", "../../@loaders.gl/loader-utils/src/lib/worker-loader-utils/encode-with-worker.ts", "../../@loaders.gl/loader-utils/src/lib/binary-utils/get-first-characters.ts", "../../@loaders.gl/loader-utils/src/lib/parser-utils/parse-json.ts", "../../@loaders.gl/loader-utils/src/lib/binary-utils/memory-copy-utils.ts", "../../@loaders.gl/loader-utils/src/lib/binary-utils/dataview-copy-utils.ts", "../../@loaders.gl/loader-utils/src/lib/binary-utils/memory-conversion-utils.ts", "../../@loaders.gl/loader-utils/src/lib/path-utils/path.ts", "../../@loaders.gl/loader-utils/src/index.ts", "../../@loaders.gl/loader-utils/src/lib/node/stream.ts", "../../@loaders.gl/loader-utils/src/lib/filesystems/writable-file.ts", "../../@loaders.gl/loader-utils/src/lib/filesystems/node-filesystem.ts"],
  "sourcesContent": ["module.exports = Object.create(new Proxy({}, {\n  get(_, key) {\n    if (\n      key !== '__esModule' &&\n      key !== '__proto__' &&\n      key !== 'constructor' &&\n      key !== 'splice'\n    ) {\n      console.warn(`Module \"stream\" has been externalized for browser compatibility. Cannot access \"stream.${key}\" in client code.`)\n    }\n  }\n}))", "/**\n * Throws an `Error` with the optional `message` if `condition` is falsy\n * @note Replacement for the external assert method to reduce bundle size\n */\nexport function assert(condition: any, message?: string): void {\n  if (!condition) {\n    throw new Error(message || 'loader assertion failed.');\n  }\n}\n", "// Purpose: include this in your module to avoid\n// dependencies on micro modules like 'global' and 'is-browser';\n\n/* eslint-disable no-restricted-globals */\nconst globals = {\n  self: typeof self !== 'undefined' && self,\n  window: typeof window !== 'undefined' && window,\n  global: typeof global !== 'undefined' && global,\n  document: typeof document !== 'undefined' && document\n};\n\ntype obj = {[key: string]: any};\nconst self_: obj = globals.self || globals.window || globals.global || {};\nconst window_: obj = globals.window || globals.self || globals.global || {};\nconst global_: obj = globals.global || globals.self || globals.window || {};\nconst document_: obj = globals.document || {};\n\nexport {self_ as self, window_ as window, global_ as global, document_ as document};\n\n/** true if running in a browser */\nexport const isBrowser: boolean =\n  // @ts-ignore process does not exist on browser\n  Boolean(typeof process !== 'object' || String(process) !== '[object process]' || process.browser);\n\n/** true if running in a worker thread */\nexport const isWorker: boolean = typeof importScripts === 'function';\n\n// Extract node major version\nconst matches =\n  typeof process !== 'undefined' && process.version && /v([0-9]*)/.exec(process.version);\n/** Major Node version (as a number) */\nexport const nodeVersion: number = (matches && parseFloat(matches[1])) || 0;\n", "// TextDecoder iterators\n// TextDecoder will keep any partial undecoded bytes between calls to `decode`\n\nexport async function* makeTextDecoderIterator(\n  arrayBufferIterator: AsyncIterable<ArrayBuffer> | Iterable<ArrayBuffer>,\n  options: TextDecoderOptions = {}\n): AsyncIterable<string> {\n  const textDecoder = new TextDecoder(undefined, options);\n  for await (const arrayBuffer of arrayBufferIterator) {\n    yield typeof arrayBuffer === 'string'\n      ? arrayBuffer\n      : textDecoder.decode(arrayBuffer, {stream: true});\n  }\n}\n\n// TextEncoder iterator\n// TODO - this is not useful unless min chunk size is given\n// TextEncoder will keep any partial undecoded bytes between calls to `encode`\n// If iterator does not yield strings, assume arrayBuffer and return unencoded\n\nexport async function* makeTextEncoderIterator(\n  textIterator: AsyncIterable<string> | Iterable<ArrayBuffer>\n): AsyncIterable<ArrayBuffer> {\n  const textEncoder = new TextEncoder();\n  for await (const text of textIterator) {\n    yield typeof text === 'string' ? textEncoder.encode(text) : text;\n  }\n}\n\n/**\n * @param textIterator async iterable yielding strings\n * @returns an async iterable over lines\n * See http://2ality.com/2018/04/async-iter-nodejs.html\n */\n\nexport async function* makeLineIterator(\n  textIterator: AsyncIterable<string>\n): AsyncIterable<string> {\n  let previous = '';\n  for await (const textChunk of textIterator) {\n    previous += textChunk;\n    let eolIndex;\n    while ((eolIndex = previous.indexOf('\\n')) >= 0) {\n      // line includes the EOL\n      const line = previous.slice(0, eolIndex + 1);\n      previous = previous.slice(eolIndex + 1);\n      yield line;\n    }\n  }\n\n  if (previous.length > 0) {\n    yield previous;\n  }\n}\n\n/**\n * @param lineIterator async iterable yielding lines\n * @returns async iterable yielding numbered lines\n *\n * See http://2ality.com/2018/04/async-iter-nodejs.html\n */\nexport async function* makeNumberedLineIterator(\n  lineIterator: AsyncIterable<string>\n): AsyncIterable<{counter: number; line: string}> {\n  let counter = 1;\n  for await (const line of lineIterator) {\n    yield {counter, line};\n    counter++;\n  }\n}\n", "import {TypedArray} from '../../types';\n\n/**\n * compare two binary arrays for equality\n * @param a\n * @param b\n * @param byteLength\n */\nexport function compareArrayBuffers(\n  arrayBuffer1: ArrayBuffer,\n  arrayBuffer2: ArrayBuffer,\n  byteLength?: number\n): boolean {\n  byteLength = byteLength || arrayBuffer1.byteLength;\n  if (arrayBuffer1.byteLength < byteLength || arrayBuffer2.byteLength < byteLength) {\n    return false;\n  }\n  const array1 = new Uint8Array(arrayBuffer1);\n  const array2 = new Uint8Array(arrayBuffer2);\n  for (let i = 0; i < array1.length; ++i) {\n    if (array1[i] !== array2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Concatenate a sequence of ArrayBuffers\n * @return A concatenated ArrayBuffer\n */\nexport function concatenateArrayBuffers(...sources: (ArrayBuffer | Uint8Array)[]): ArrayBuffer {\n  // Make sure all inputs are wrapped in typed arrays\n  const sourceArrays = sources.map((source2) =>\n    source2 instanceof ArrayBuffer ? new Uint8Array(source2) : source2\n  );\n\n  // Get length of all inputs\n  const byteLength = sourceArrays.reduce((length, typedArray) => length + typedArray.byteLength, 0);\n\n  // Allocate array with space for all inputs\n  const result = new Uint8Array(byteLength);\n\n  // Copy the subarrays\n  let offset = 0;\n  for (const sourceArray of sourceArrays) {\n    result.set(sourceArray, offset);\n    offset += sourceArray.byteLength;\n  }\n\n  // We work with ArrayBuffers, discard the typed array wrapper\n  return result.buffer;\n}\n\n/**\n * Concatenate arbitrary count of typed arrays\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays\n * @param - list of arrays. All arrays should be the same type\n * @return A concatenated TypedArray\n */\nexport function concatenateTypedArrays<T>(...typedArrays: T[]): T {\n  // @ts-ignore\n  const arrays = typedArrays as TypedArray[];\n  // @ts-ignore\n  const TypedArrayConstructor = (arrays && arrays.length > 1 && arrays[0].constructor) || null;\n  if (!TypedArrayConstructor) {\n    throw new Error(\n      '\"concatenateTypedArrays\" - incorrect quantity of arguments or arguments have incompatible data types'\n    );\n  }\n\n  const sumLength = arrays.reduce((acc, value) => acc + value.length, 0);\n  // @ts-ignore typescript does not like dynamic constructors\n  const result = new TypedArrayConstructor(sumLength);\n  let offset = 0;\n  for (const array of arrays) {\n    result.set(array, offset);\n    offset += array.length;\n  }\n  return result;\n}\n\n/**\n * Copy a view of an ArrayBuffer into new ArrayBuffer with byteOffset = 0\n * @param arrayBuffer\n * @param byteOffset\n * @param byteLength\n */\nexport function sliceArrayBuffer(\n  arrayBuffer: ArrayBuffer,\n  byteOffset: number,\n  byteLength?: number\n): ArrayBuffer {\n  const subArray =\n    byteLength !== undefined\n      ? new Uint8Array(arrayBuffer).subarray(byteOffset, byteOffset + byteLength)\n      : new Uint8Array(arrayBuffer).subarray(byteOffset);\n  const arrayCopy = new Uint8Array(subArray);\n  return arrayCopy.buffer;\n}\n", "import {concatenateArrayBuffers} from '../binary-utils/array-buffer-utils';\n\n// GENERAL UTILITIES\n\n/**\n * Iterate over async iterator, without resetting iterator if end is not reached\n * - forEach intentionally does not reset iterator if exiting loop prematurely\n *   so that iteration can continue in a second loop\n * - It is recommended to use a standard for-await as last loop to ensure\n *   iterator gets properly reset\n *\n * TODO - optimize using sync iteration if argument is an Iterable?\n *\n * @param iterator\n * @param visitor\n */\nexport async function forEach(iterator, visitor) {\n  // eslint-disable-next-line\n  while (true) {\n    const {done, value} = await iterator.next();\n    if (done) {\n      iterator.return();\n      return;\n    }\n    const cancel = visitor(value);\n    if (cancel) {\n      return;\n    }\n  }\n}\n\n// Breaking big data into iterable chunks, concatenating iterable chunks into big data objects\n\n/**\n * Concatenates all data chunks yielded by an (async) iterator\n * This function can e.g. be used to enable atomic parsers to work on (async) iterator inputs\n */\n\nexport async function concatenateArrayBuffersAsync(\n  asyncIterator: AsyncIterable<ArrayBuffer> | Iterable<ArrayBuffer>\n): Promise<ArrayBuffer> {\n  const arrayBuffers: ArrayBuffer[] = [];\n  for await (const chunk of asyncIterator) {\n    arrayBuffers.push(chunk);\n  }\n  return concatenateArrayBuffers(...arrayBuffers);\n}\n\nexport async function concatenateStringsAsync(\n  asyncIterator: AsyncIterable<string> | Iterable<string>\n): Promise<string> {\n  const strings: string[] = [];\n  for await (const chunk of asyncIterator) {\n    strings.push(chunk);\n  }\n  return strings.join('');\n}\n", "export default function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}", "import _typeof from \"./typeof.js\";\nexport default function _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}", "import _typeof from \"./typeof.js\";\nimport toPrimitive from \"./toPrimitive.js\";\nexport default function _toPropertyKey(arg) {\n  var key = toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}", "import toPropertyKey from \"./toPropertyKey.js\";\nexport default function _defineProperty(obj, key, value) {\n  key = toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}", "// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nexport default function getHiResTimestamp(): number {\n  let timestamp;\n  // Get best timer available.\n  if (typeof window !== 'undefined' && window.performance) {\n    timestamp = window.performance.now();\n  } else if (typeof process !== 'undefined' && process.hrtime) {\n    const timeParts = process.hrtime();\n    timestamp = timeParts[0] * 1000 + timeParts[1] / 1e6;\n  } else {\n    timestamp = Date.now();\n  }\n\n  return timestamp;\n}\n", "import getHiResTimestamp from '../utils/hi-res-timestamp';\n\nexport default class Stat {\n  readonly name: string;\n  readonly type: string;\n  sampleSize: number = 1;\n  time: number;\n  count: number;\n  samples: number;\n  lastTiming: number;\n  lastSampleTime: number;\n  lastSampleCount: number;\n\n  _count: number = 0;\n  _time: number = 0;\n  _samples: number = 0;\n  _startTime: number = 0;\n  _timerPending: boolean = false;\n\n  constructor(name: string, type?: string) {\n    this.name = name;\n    this.type = type;\n    this.reset();\n  }\n\n  setSampleSize(samples: number): this {\n    this.sampleSize = samples;\n    return this;\n  }\n\n  /** Call to increment count (+1) */\n  incrementCount(): this {\n    this.addCount(1);\n\n    return this;\n  }\n\n  /** Call to decrement count (-1) */\n  decrementCount(): this {\n    this.subtractCount(1);\n\n    return this;\n  }\n\n  /** Increase count */\n  addCount(value: number): this {\n    this._count += value;\n    this._samples++;\n    this._checkSampling();\n\n    return this;\n  }\n\n  /** Decrease count */\n  subtractCount(value: number): this {\n    this._count -= value;\n    this._samples++;\n    this._checkSampling();\n\n    return this;\n  }\n\n  /** Add an arbitrary timing and bump the count */\n  addTime(time: number): this {\n    this._time += time;\n    this.lastTiming = time;\n    this._samples++;\n    this._checkSampling();\n\n    return this;\n  }\n\n  /** Start a timer */\n  timeStart(): this {\n    this._startTime = getHiResTimestamp();\n    this._timerPending = true;\n\n    return this;\n  }\n\n  /** End a timer. Adds to time and bumps the timing count. */\n  timeEnd(): this {\n    if (!this._timerPending) {\n      return this;\n    }\n    this.addTime(getHiResTimestamp() - this._startTime);\n    this._timerPending = false;\n    this._checkSampling();\n\n    return this;\n  }\n\n  getSampleAverageCount(): number {\n    return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0;\n  }\n\n  /** Calculate average time / count for the previous window */\n  getSampleAverageTime(): number {\n    return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0;\n  }\n\n  /** Calculate counts per second for the previous window */\n  getSampleHz(): number {\n    return this.lastSampleTime > 0 ? this.sampleSize / (this.lastSampleTime / 1000) : 0;\n  }\n\n  getAverageCount(): number {\n    return this.samples > 0 ? this.count / this.samples : 0;\n  }\n\n  /** Calculate average time / count */\n  getAverageTime(): number {\n    return this.samples > 0 ? this.time / this.samples : 0;\n  }\n\n  /** Calculate counts per second */\n  getHz(): number {\n    return this.time > 0 ? this.samples / (this.time / 1000) : 0;\n  }\n\n  reset(): this {\n    this.time = 0;\n    this.count = 0;\n    this.samples = 0;\n    this.lastTiming = 0;\n    this.lastSampleTime = 0;\n    this.lastSampleCount = 0;\n    this._count = 0;\n    this._time = 0;\n    this._samples = 0;\n    this._startTime = 0;\n    this._timerPending = false;\n\n    return this;\n  }\n\n  _checkSampling(): void {\n    if (this._samples === this.sampleSize) {\n      this.lastSampleTime = this._time;\n      this.lastSampleCount = this._count;\n      this.count += this._count;\n      this.time += this._time;\n      this.samples += this._samples;\n      this._time = 0;\n      this._count = 0;\n      this._samples = 0;\n    }\n  }\n}\n", "import Stat from './stat';\n\n/** A \"bag\" of `Stat` objects, can be visualized using `StatsWidget` */\nexport default class Stats {\n  readonly id: string;\n  readonly stats: Record<string, Stat> = {};\n\n  constructor(options: {id: string; stats?: Stats | Stat[] | {name: string; type?: string}[]}) {\n    this.id = options.id;\n    this.stats = {};\n\n    this._initializeStats(options.stats);\n\n    Object.seal(this);\n  }\n\n  /** Acquire a stat. Create if it doesn't exist. */\n  get(name: string, type: string = 'count'): Stat {\n    return this._getOrCreate({name, type});\n  }\n\n  get size(): number {\n    return Object.keys(this.stats).length;\n  }\n\n  /** Reset all stats */\n  reset(): this {\n    for (const key in this.stats) {\n      this.stats[key].reset();\n    }\n\n    return this;\n  }\n\n  forEach(fn: (stat: Stat) => void): void {\n    for (const key in this.stats) {\n      fn(this.stats[key]);\n    }\n  }\n\n  getTable(): Record<\n    string,\n    {\n      time: number;\n      count: number;\n      average: number;\n      hz: number;\n    }\n    > {\n    const table = {};\n    this.forEach(stat => {\n      table[stat.name] = {\n        time: stat.time || 0,\n        count: stat.count || 0,\n        average: stat.getAverageTime() || 0,\n        hz: stat.getHz() || 0\n      };\n    });\n\n    return table;\n  }\n\n  _initializeStats(stats: Stats | Stat[] | {name: string; type?: string}[] = []): void {\n    stats.forEach(stat => this._getOrCreate(stat));\n  }\n\n  _getOrCreate(stat): Stat {\n    if (!stat || !stat.name) {\n      return null;\n    }\n\n    const {name, type} = stat;\n    if (!this.stats[name]) {\n      if (stat instanceof Stat) {\n        this.stats[name] = stat;\n      } else {\n        this.stats[name] = new Stat(name, type);\n      }\n    }\n    return this.stats[name];\n  }\n}\n", "import {Stats} from '@probe.gl/stats';\n\ntype Handle = any;\ntype DoneFunction = () => any;\ntype GetPriorityFunction = () => number;\ntype RequestResult = {\n  done: DoneFunction;\n} | null;\n\n/** RequestScheduler Options */\nexport type RequestSchedulerProps = {\n  id?: string;\n  throttleRequests?: boolean;\n  maxRequests?: number;\n};\n\nconst STAT_QUEUED_REQUESTS = 'Queued Requests';\nconst STAT_ACTIVE_REQUESTS = 'Active Requests';\nconst STAT_CANCELLED_REQUESTS = 'Cancelled Requests';\nconst STAT_QUEUED_REQUESTS_EVER = 'Queued Requests Ever';\nconst STAT_ACTIVE_REQUESTS_EVER = 'Active Requests Ever';\n\nconst DEFAULT_PROPS: Required<RequestSchedulerProps> = {\n  id: 'request-scheduler',\n  // Specifies if the request scheduler should throttle incoming requests, mainly for comparative testing\n  throttleRequests: true,\n  // The maximum number of simultaneous active requests. Un-throttled requests do not observe this limit.\n  maxRequests: 6\n};\n\n/** Tracks one request */\ntype Request = {\n  handle: Handle;\n  priority: number;\n  getPriority: GetPriorityFunction;\n  resolve?: (value: any) => any;\n};\n\n/**\n * Used to issue a request, without having them \"deeply queued\" by the browser.\n * @todo - Track requests globally, across multiple servers\n */\nexport default class RequestScheduler {\n  readonly props: Required<RequestSchedulerProps>;\n  readonly stats: Stats;\n  activeRequestCount: number = 0;\n\n  /** Tracks the number of active requests and prioritizes/cancels queued requests. */\n  private requestQueue: Request[] = [];\n  private requestMap: Map<Handle, Promise<RequestResult>> = new Map();\n  private deferredUpdate: any = null;\n\n  constructor(props: RequestSchedulerProps = {}) {\n    this.props = {...DEFAULT_PROPS, ...props};\n\n    // Returns the statistics used by the request scheduler.\n    this.stats = new Stats({id: this.props.id});\n    this.stats.get(STAT_QUEUED_REQUESTS);\n    this.stats.get(STAT_ACTIVE_REQUESTS);\n    this.stats.get(STAT_CANCELLED_REQUESTS);\n    this.stats.get(STAT_QUEUED_REQUESTS_EVER);\n    this.stats.get(STAT_ACTIVE_REQUESTS_EVER);\n  }\n\n  /**\n   * Called by an application that wants to issue a request, without having it deeply queued by the browser\n   *\n   * When the returned promise resolved, it is OK for the application to issue a request.\n   * The promise resolves to an object that contains a `done` method.\n   * When the application's request has completed (or failed), the application must call the `done` function\n   *\n   * @param handle\n   * @param getPriority will be called when request \"slots\" open up,\n   *    allowing the caller to update priority or cancel the request\n   *    Highest priority executes first, priority < 0 cancels the request\n   * @returns a promise\n   *   - resolves to a object (with a `done` field) when the request can be issued without queueing,\n   *   - resolves to `null` if the request has been cancelled (by the callback return < 0).\n   *     In this case the application should not issue the request\n   */\n  scheduleRequest(\n    handle: Handle,\n    getPriority: GetPriorityFunction = () => 0\n  ): Promise<RequestResult> {\n    // Allows throttling to be disabled\n    if (!this.props.throttleRequests) {\n      return Promise.resolve({done: () => {}});\n    }\n\n    // dedupe\n    if (this.requestMap.has(handle)) {\n      return this.requestMap.get(handle) as Promise<any>;\n    }\n\n    const request: Request = {handle, priority: 0, getPriority};\n    const promise = new Promise<RequestResult>((resolve) => {\n      // @ts-ignore\n      request.resolve = resolve;\n      return request;\n    });\n\n    this.requestQueue.push(request);\n    this.requestMap.set(handle, promise);\n    this._issueNewRequests();\n    return promise;\n  }\n\n  // PRIVATE\n\n  _issueRequest(request: Request): Promise<any> {\n    const {handle, resolve} = request;\n    let isDone = false;\n\n    const done = () => {\n      // can only be called once\n      if (!isDone) {\n        isDone = true;\n\n        // Stop tracking a request - it has completed, failed, cancelled etc\n        this.requestMap.delete(handle);\n        this.activeRequestCount--;\n        // A slot just freed up, see if any queued requests are waiting\n        this._issueNewRequests();\n      }\n    };\n\n    // Track this request\n    this.activeRequestCount++;\n\n    return resolve ? resolve({done}) : Promise.resolve({done});\n  }\n\n  /** We check requests asynchronously, to prevent multiple updates */\n  _issueNewRequests(): void {\n    if (!this.deferredUpdate) {\n      this.deferredUpdate = setTimeout(() => this._issueNewRequestsAsync(), 0);\n    }\n  }\n\n  /** Refresh all requests  */\n  _issueNewRequestsAsync() {\n    // TODO - shouldn't we clear the timeout?\n    this.deferredUpdate = null;\n\n    const freeSlots = Math.max(this.props.maxRequests - this.activeRequestCount, 0);\n\n    if (freeSlots === 0) {\n      return;\n    }\n\n    this._updateAllRequests();\n\n    // Resolve pending promises for the top-priority requests\n    for (let i = 0; i < freeSlots; ++i) {\n      const request = this.requestQueue.shift();\n      if (request) {\n        this._issueRequest(request); // eslint-disable-line @typescript-eslint/no-floating-promises\n      }\n    }\n\n    // Uncomment to debug\n    // console.log(`${freeSlots} free slots, ${this.requestQueue.length} queued requests`);\n  }\n\n  /** Ensure all requests have updated priorities, and that no longer valid requests are cancelled */\n  _updateAllRequests() {\n    const requestQueue = this.requestQueue;\n    for (let i = 0; i < requestQueue.length; ++i) {\n      const request = requestQueue[i];\n      if (!this._updateRequest(request)) {\n        // Remove the element and make sure to adjust the counter to account for shortened array\n        requestQueue.splice(i, 1);\n        this.requestMap.delete(request.handle);\n        i--;\n      }\n    }\n\n    // Sort the remaining requests based on priority\n    requestQueue.sort((a, b) => a.priority - b.priority);\n  }\n\n  /** Update a single request by calling the callback */\n  _updateRequest(request) {\n    request.priority = request.getPriority(request.handle); // eslint-disable-line callback-return\n\n    // by returning a negative priority, the callback cancels the request\n    if (request.priority < 0) {\n      request.resolve(null);\n      return false;\n    }\n    return true;\n  }\n}\n", "// Simple file alias mechanisms for tests.\n\nlet pathPrefix = '';\nconst fileAliases: {[aliasPath: string]: string} = {};\n\n/*\n * Set a relative path prefix\n */\nexport function setPathPrefix(prefix: string): void {\n  pathPrefix = prefix;\n}\n\n/*\n * Get the relative path prefix\n */\nexport function getPathPrefix(): string {\n  return pathPrefix;\n}\n\n/**\n *\n * @param aliases\n *\n * Note: addAliases are an experimental export, they are only for testing of loaders.gl loaders\n * not intended as a generic aliasing mechanism\n */\nexport function addAliases(aliases: {[aliasPath: string]: string}): void {\n  Object.assign(fileAliases, aliases);\n}\n\n/**\n * Resolves aliases and adds path-prefix to paths\n */\nexport function resolvePath(filename: string): string {\n  for (const alias in fileAliases) {\n    if (filename.startsWith(alias)) {\n      const replacement = fileAliases[alias];\n      filename = filename.replace(alias, replacement);\n    }\n  }\n  if (!filename.startsWith('http://') && !filename.startsWith('https://')) {\n    filename = `${pathPrefix}${filename}`;\n  }\n  return filename;\n}\n", "import type {LoaderWithParser} from './types';\n\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nconst VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'latest';\n\n/**\n * A JSON Micro loader (minimal bundle size)\n * Alternative to `@loaders.gl/json`\n */\nexport const JSONLoader = {\n  name: 'JSON',\n  id: 'json',\n  module: 'json',\n  version: VERSION,\n  extensions: ['json', 'geojson'],\n  mimeTypes: ['application/json'],\n  category: 'json',\n  text: true,\n  parseTextSync,\n  parse: async (arrayBuffer) => parseTextSync(new TextDecoder().decode(arrayBuffer)),\n  options: {}\n};\n\n// TODO - deprecated\nfunction parseTextSync(text) {\n  return JSON.parse(text);\n}\n\nexport const _typecheckJSONLoader: LoaderWithParser = JSONLoader;\n", "// Version constant cannot be imported, it needs to correspond to the build version of **this** module.\n// __VERSION__ is injected by babel-plugin-version-inline\n\n// Change to `latest` on production branches\nconst DEFAULT_VERSION = 'beta';\ndeclare let __VERSION__: string;\nexport const VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : DEFAULT_VERSION;\nif (typeof __VERSION__ === 'undefined') {\n  // eslint-disable-next-line\n  console.error(\n    'loaders.gl: The __VERSION__ variable is not injected using babel plugin. Latest unstable workers would be fetched from the CDN.'\n  );\n}\n", "// Replacement for the external assert method to reduce bundle size\n// Note: We don't use the second \"message\" argument in calling code,\n// so no need to support it here\n\n/** Throws an `Error` with the optional `message` if `condition` is falsy */\nexport function assert(condition: any, message?: string): void {\n  if (!condition) {\n    throw new Error(message || 'loaders.gl assertion failed.');\n  }\n}\n", "// Purpose: include this in your module to avoids adding dependencies on\n// micro modules like 'global' and 'is-browser';\n\n/* eslint-disable no-restricted-globals */\nconst globals = {\n  self: typeof self !== 'undefined' && self,\n  window: typeof window !== 'undefined' && window,\n  global: typeof global !== 'undefined' && global,\n  document: typeof document !== 'undefined' && document\n};\n\nconst self_: {[key: string]: any} = globals.self || globals.window || globals.global || {};\nconst window_: {[key: string]: any} = globals.window || globals.self || globals.global || {};\nconst global_: {[key: string]: any} = globals.global || globals.self || globals.window || {};\nconst document_: {[key: string]: any} = globals.document || {};\n\nexport {self_ as self, window_ as window, global_ as global, document_ as document};\n\n/** true if running in the browser, false if running in Node.js */\nexport const isBrowser: boolean =\n  // @ts-ignore process.browser\n  typeof process !== 'object' || String(process) !== '[object process]' || process.browser;\n\n/** true if running on a worker thread */\nexport const isWorker: boolean = typeof importScripts === 'function';\n\n/** true if running on a mobile device */\nexport const isMobile: boolean =\n  typeof window !== 'undefined' && typeof window.orientation !== 'undefined';\n\n// Extract node major version\nconst matches =\n  typeof process !== 'undefined' && process.version && /v([0-9]*)/.exec(process.version);\n\n/** Version of Node.js if running under Node, otherwise 0 */\nexport const nodeVersion: number = (matches && parseFloat(matches[1])) || 0;\n", "import type {WorkerMessageType, WorkerMessagePayload} from '../../types';\nimport WorkerThread from './worker-thread';\nimport {assert} from '../env-utils/assert';\n\n/**\n * Represents one Job handled by a WorkerPool or WorkerFarm\n */\nexport default class WorkerJob {\n  readonly name: string;\n  readonly workerThread: WorkerThread;\n  isRunning: boolean = true;\n  /** Promise that resolves when Job is done */\n  readonly result: Promise<any>;\n\n  private _resolve: (value: any) => void = () => {};\n  private _reject: (reason?: any) => void = () => {};\n\n  constructor(jobName: string, workerThread: WorkerThread) {\n    this.name = jobName;\n    this.workerThread = workerThread;\n    this.result = new Promise((resolve, reject) => {\n      this._resolve = resolve;\n      this._reject = reject;\n    });\n  }\n\n  /**\n   * Send a message to the job's worker thread\n   * @param data any data structure, ideally consisting mostly of transferrable objects\n   */\n  postMessage(type: WorkerMessageType, payload: WorkerMessagePayload): void {\n    this.workerThread.postMessage({\n      source: 'loaders.gl', // Lets worker ignore unrelated messages\n      type,\n      payload\n    });\n  }\n\n  /**\n   * Call to resolve the `result` Promise with the supplied value\n   */\n  done(value: any): void {\n    assert(this.isRunning);\n    this.isRunning = false;\n    this._resolve(value);\n  }\n\n  /**\n   * Call to reject the `result` Promise with the supplied error\n   */\n  error(error: Error): void {\n    assert(this.isRunning);\n    this.isRunning = false;\n    this._reject(error);\n  }\n}\n", "// Browser fills for Node.js built-in `worker_threads` module.\n// These fills are non-functional, and just intended to ensure that\n// `import 'worker_threads` doesn't break browser builds.\n// The replacement is done in package.json browser field\nexport class Worker {\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  terminate() {}\n}\n\nexport {Worker as NodeWorker};\nexport {Worker as NodeWorkerType};\n\nexport const parentPort = null;\n", "import {assert} from '../env-utils/assert';\n\nconst workerURLCache = new Map();\n\n/**\n * Creates a loadable URL from worker source or URL\n * that can be used to create `Worker` instances.\n * Due to CORS issues it may be necessary to wrap a URL in a small importScripts\n * @param props\n * @param props.source Worker source\n * @param props.url Worker URL\n * @returns loadable url\n */\nexport function getLoadableWorkerURL(props: {source?: string; url?: string}) {\n  assert((props.source && !props.url) || (!props.source && props.url)); // Either source or url must be defined\n\n  let workerURL = workerURLCache.get(props.source || props.url);\n  if (!workerURL) {\n    // Differentiate worker urls from worker source code\n    if (props.url) {\n      workerURL = getLoadableWorkerURLFromURL(props.url);\n      workerURLCache.set(props.url, workerURL);\n    }\n\n    if (props.source) {\n      workerURL = getLoadableWorkerURLFromSource(props.source);\n      workerURLCache.set(props.source, workerURL);\n    }\n  }\n\n  assert(workerURL);\n  return workerURL;\n}\n\n/**\n * Build a loadable worker URL from worker URL\n * @param url\n * @returns loadable URL\n */\nfunction getLoadableWorkerURLFromURL(url: string): string {\n  // A local script url, we can use it to initialize a Worker directly\n  if (!url.startsWith('http')) {\n    return url;\n  }\n\n  // A remote script, we need to use `importScripts` to load from different origin\n  const workerSource = buildScriptSource(url);\n  return getLoadableWorkerURLFromSource(workerSource);\n}\n\n/**\n * Build a loadable worker URL from worker source\n * @param workerSource\n * @returns loadable url\n */\nfunction getLoadableWorkerURLFromSource(workerSource: string): string {\n  const blob = new Blob([workerSource], {type: 'application/javascript'});\n  return URL.createObjectURL(blob);\n}\n\n/**\n * Per spec, worker cannot be initialized with a script from a different origin\n * However a local worker script can still import scripts from other origins,\n * so we simply build a wrapper script.\n *\n * @param workerUrl\n * @returns source\n */\nfunction buildScriptSource(workerUrl: string): string {\n  return `\\\ntry {\n  importScripts('${workerUrl}');\n} catch (error) {\n  console.error(error);\n  throw error;\n}`;\n}\n", "// NOTE - there is a copy of this function is both in core and loader-utils\n// core does not need all the utils in loader-utils, just this one.\n\n/**\n * Returns an array of Transferrable objects that can be used with postMessage\n * https://developer.mozilla.org/en-US/docs/Web/API/Worker/postMessage\n * @param object data to be sent via postMessage\n * @param recursive - not for application use\n * @param transfers - not for application use\n * @returns a transfer list that can be passed to postMessage\n */\nexport function getTransferList(\n  object: any,\n  recursive: boolean = true,\n  transfers?: Set<any>\n): Transferable[] {\n  // Make sure that items in the transfer list is unique\n  const transfersSet = transfers || new Set();\n\n  if (!object) {\n    // ignore\n  } else if (isTransferable(object)) {\n    transfersSet.add(object);\n  } else if (isTransferable(object.buffer)) {\n    // Typed array\n    transfersSet.add(object.buffer);\n  } else if (ArrayBuffer.isView(object)) {\n    // object is a TypeArray viewing into a SharedArrayBuffer (not transferable)\n    // Do not iterate through the content in this case\n  } else if (recursive && typeof object === 'object') {\n    for (const key in object) {\n      // Avoid perf hit - only go one level deep\n      getTransferList(object[key], recursive, transfersSet);\n    }\n  }\n\n  // If transfers is defined, is internal recursive call\n  // Otherwise it's called by the user\n  return transfers === undefined ? Array.from(transfersSet) : [];\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/API/Transferable\nfunction isTransferable(object: unknown) {\n  if (!object) {\n    return false;\n  }\n  if (object instanceof ArrayBuffer) {\n    return true;\n  }\n  if (typeof MessagePort !== 'undefined' && object instanceof MessagePort) {\n    return true;\n  }\n  if (typeof ImageBitmap !== 'undefined' && object instanceof ImageBitmap) {\n    return true;\n  }\n  // @ts-ignore\n  if (typeof OffscreenCanvas !== 'undefined' && object instanceof OffscreenCanvas) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Recursively drop non serializable values like functions and regexps.\n * @param object\n */\nexport function getTransferListForWriter(object: object | null): object {\n  if (object === null) {\n    return {};\n  }\n  const clone = Object.assign({}, object);\n\n  Object.keys(clone).forEach((key) => {\n    // Typed Arrays and Arrays are passed with no change\n    if (\n      typeof object[key] === 'object' &&\n      !ArrayBuffer.isView(object[key]) &&\n      !(object[key] instanceof Array)\n    ) {\n      clone[key] = getTransferListForWriter(object[key]);\n    } else if (typeof clone[key] === 'function' || clone[key] instanceof RegExp) {\n      clone[key] = {};\n    } else {\n      clone[key] = object[key];\n    }\n  });\n\n  return clone;\n}\n", "// loaders.gl, MIT license\n\nimport {NodeWorker, NodeWorkerType} from '../node/worker_threads';\nimport {isBrowser} from '../env-utils/globals';\nimport {assert} from '../env-utils/assert';\nimport {getLoadableWorkerURL} from '../worker-utils/get-loadable-worker-url';\nimport {getTransferList} from '../worker-utils/get-transfer-list';\n\nconst NOOP = () => {};\n\nexport type WorkerThreadProps = {\n  name: string;\n  source?: string;\n  url?: string;\n};\n\n/**\n * Represents one worker thread\n */\nexport default class WorkerThread {\n  readonly name: string;\n  readonly source: string | undefined;\n  readonly url: string | undefined;\n  terminated: boolean = false;\n  worker: Worker | NodeWorkerType;\n  onMessage: (message: any) => void;\n  onError: (error: Error) => void;\n\n  private _loadableURL: string = '';\n\n  /** Checks if workers are supported on this platform */\n  static isSupported(): boolean {\n    return (\n      (typeof Worker !== 'undefined' && isBrowser) ||\n      (typeof NodeWorker !== 'undefined' && !isBrowser)\n    );\n  }\n\n  constructor(props: WorkerThreadProps) {\n    const {name, source, url} = props;\n    assert(source || url); // Either source or url must be defined\n    this.name = name;\n    this.source = source;\n    this.url = url;\n    this.onMessage = NOOP;\n    this.onError = (error) => console.log(error); // eslint-disable-line\n\n    this.worker = isBrowser ? this._createBrowserWorker() : this._createNodeWorker();\n  }\n\n  /**\n   * Terminate this worker thread\n   * @note Can free up significant memory\n   */\n  destroy(): void {\n    this.onMessage = NOOP;\n    this.onError = NOOP;\n    this.worker.terminate(); // eslint-disable-line @typescript-eslint/no-floating-promises\n    this.terminated = true;\n  }\n\n  get isRunning() {\n    return Boolean(this.onMessage);\n  }\n\n  /**\n   * Send a message to this worker thread\n   * @param data any data structure, ideally consisting mostly of transferrable objects\n   * @param transferList If not supplied, calculated automatically by traversing data\n   */\n  postMessage(data: any, transferList?: any[]): void {\n    transferList = transferList || getTransferList(data);\n    // @ts-ignore\n    this.worker.postMessage(data, transferList);\n  }\n\n  // PRIVATE\n\n  /**\n   * Generate a standard Error from an ErrorEvent\n   * @param event\n   */\n  _getErrorFromErrorEvent(event: ErrorEvent): Error {\n    // Note Error object does not have the expected fields if loading failed completely\n    // https://developer.mozilla.org/en-US/docs/Web/API/Worker#Event_handlers\n    // https://developer.mozilla.org/en-US/docs/Web/API/ErrorEvent\n    let message = 'Failed to load ';\n    message += `worker ${this.name} from ${this.url}. `;\n    if (event.message) {\n      message += `${event.message} in `;\n    }\n    // const hasFilename = event.filename && !event.filename.startsWith('blob:');\n    // message += hasFilename ? event.filename : this.source.slice(0, 100);\n    if (event.lineno) {\n      message += `:${event.lineno}:${event.colno}`;\n    }\n    return new Error(message);\n  }\n\n  /**\n   * Creates a worker thread on the browser\n   */\n  _createBrowserWorker(): Worker {\n    this._loadableURL = getLoadableWorkerURL({source: this.source, url: this.url});\n    const worker = new Worker(this._loadableURL, {name: this.name});\n\n    worker.onmessage = (event) => {\n      if (!event.data) {\n        this.onError(new Error('No data received'));\n      } else {\n        this.onMessage(event.data);\n      }\n    };\n    // This callback represents an uncaught exception in the worker thread\n    worker.onerror = (error: ErrorEvent): void => {\n      this.onError(this._getErrorFromErrorEvent(error));\n      this.terminated = true;\n    };\n    // TODO - not clear when this would be called, for now just log in case it happens\n    worker.onmessageerror = (event) => console.error(event); // eslint-disable-line\n\n    return worker;\n  }\n\n  /**\n   * Creates a worker thread in node.js\n   * @todo https://nodejs.org/api/async_hooks.html#async-resource-worker-pool\n   */\n  _createNodeWorker(): NodeWorkerType {\n    let worker: NodeWorkerType;\n    if (this.url) {\n      // Make sure relative URLs start with './'\n      const absolute = this.url.includes(':/') || this.url.startsWith('/');\n      const url = absolute ? this.url : `./${this.url}`;\n      // console.log('Starting work from', url);\n      worker = new NodeWorker(url, {eval: false});\n    } else if (this.source) {\n      worker = new NodeWorker(this.source, {eval: true});\n    } else {\n      throw new Error('no worker');\n    }\n    worker.on('message', (data) => {\n      // console.error('message', data);\n      this.onMessage(data);\n    });\n    worker.on('error', (error) => {\n      // console.error('error', error);\n      this.onError(error);\n    });\n    worker.on('exit', (code) => {\n      // console.error('exit', code);\n    });\n    return worker;\n  }\n}\n", "import type {WorkerMessageType, WorkerMessagePayload} from '../../types';\nimport {isMobile} from '../env-utils/globals';\nimport WorkerThread from './worker-thread';\nimport WorkerJob from './worker-job';\n\n/** WorkerPool onDebug Callback Parameters */\ntype OnDebugParameters = {\n  message: string;\n  worker: string;\n  name: string;\n  job: string;\n  backlog: number;\n  workerThread: WorkerThread;\n};\n\n/** WorkerPool Properties */\nexport type WorkerPoolProps = {\n  name?: string;\n  source?: string; // | Function;\n  url?: string;\n  maxConcurrency?: number;\n  maxMobileConcurrency?: number;\n  onDebug?: (options: OnDebugParameters) => any;\n  reuseWorkers?: boolean;\n};\n\n/** Private helper types */\ntype OnMessage = (job: WorkerJob, type: WorkerMessageType, payload: WorkerMessagePayload) => void;\ntype OnError = (job: WorkerJob, error: Error) => void;\n\ntype QueuedJob = {\n  name: string;\n  onMessage: OnMessage;\n  onError: OnError;\n  onStart: (value: any) => void; // Resolve job start promise\n};\n\n/**\n * Process multiple data messages with small pool of identical workers\n */\nexport default class WorkerPool {\n  name: string = 'unnamed';\n  source?: string; // | Function;\n  url?: string;\n  maxConcurrency: number = 1;\n  maxMobileConcurrency: number = 1;\n  onDebug: (options: OnDebugParameters) => any = () => {};\n  reuseWorkers: boolean = true;\n\n  private props: WorkerPoolProps = {};\n  private jobQueue: QueuedJob[] = [];\n  private idleQueue: WorkerThread[] = [];\n  private count = 0;\n  private isDestroyed = false;\n\n  /** Checks if workers are supported on this platform */\n  static isSupported(): boolean {\n    return WorkerThread.isSupported();\n  }\n\n  /**\n   * @param processor - worker function\n   * @param maxConcurrency - max count of workers\n   */\n  constructor(props: WorkerPoolProps) {\n    this.source = props.source;\n    this.url = props.url;\n    this.setProps(props);\n  }\n\n  /**\n   * Terminates all workers in the pool\n   * @note Can free up significant memory\n   */\n  destroy(): void {\n    // Destroy idle workers, active Workers will be destroyed on completion\n    this.idleQueue.forEach((worker) => worker.destroy());\n    this.isDestroyed = true;\n  }\n\n  setProps(props: WorkerPoolProps) {\n    this.props = {...this.props, ...props};\n\n    if (props.name !== undefined) {\n      this.name = props.name;\n    }\n    if (props.maxConcurrency !== undefined) {\n      this.maxConcurrency = props.maxConcurrency;\n    }\n    if (props.maxMobileConcurrency !== undefined) {\n      this.maxMobileConcurrency = props.maxMobileConcurrency;\n    }\n    if (props.reuseWorkers !== undefined) {\n      this.reuseWorkers = props.reuseWorkers;\n    }\n    if (props.onDebug !== undefined) {\n      this.onDebug = props.onDebug;\n    }\n  }\n\n  async startJob(\n    name: string,\n    onMessage: OnMessage = (job, type, data) => job.done(data),\n    onError: OnError = (job, error) => job.error(error)\n  ): Promise<WorkerJob> {\n    // Promise resolves when thread starts working on this job\n    const startPromise = new Promise<WorkerJob>((onStart) => {\n      // Promise resolves when thread completes or fails working on this job\n      this.jobQueue.push({name, onMessage, onError, onStart});\n      return this;\n    });\n    this._startQueuedJob(); // eslint-disable-line @typescript-eslint/no-floating-promises\n    return await startPromise;\n  }\n\n  // PRIVATE\n\n  /**\n   * Starts first queued job if worker is available or can be created\n   * Called when job is started and whenever a worker returns to the idleQueue\n   */\n  async _startQueuedJob(): Promise<void> {\n    if (!this.jobQueue.length) {\n      return;\n    }\n\n    const workerThread = this._getAvailableWorker();\n    if (!workerThread) {\n      return;\n    }\n\n    // We have a worker, dequeue and start the job\n    const queuedJob = this.jobQueue.shift();\n    if (queuedJob) {\n      // Emit a debug event\n      // @ts-ignore\n      this.onDebug({\n        message: 'Starting job',\n        name: queuedJob.name,\n        workerThread,\n        backlog: this.jobQueue.length\n      });\n\n      // Create a worker job to let the app access thread and manage job completion\n      const job = new WorkerJob(queuedJob.name, workerThread);\n\n      // Set the worker thread's message handlers\n      workerThread.onMessage = (data) => queuedJob.onMessage(job, data.type, data.payload);\n      workerThread.onError = (error) => queuedJob.onError(job, error);\n\n      // Resolve the start promise so that the app can start sending messages to worker\n      queuedJob.onStart(job);\n\n      // Wait for the app to signal that the job is complete, then return worker to queue\n      try {\n        await job.result;\n      } finally {\n        this.returnWorkerToQueue(workerThread);\n      }\n    }\n  }\n\n  /**\n   * Returns a worker to the idle queue\n   * Destroys the worker if\n   *  - pool is destroyed\n   *  - if this pool doesn't reuse workers\n   *  - if maxConcurrency has been lowered\n   * @param worker\n   */\n  returnWorkerToQueue(worker: WorkerThread) {\n    const shouldDestroyWorker =\n      this.isDestroyed || !this.reuseWorkers || this.count > this._getMaxConcurrency();\n\n    if (shouldDestroyWorker) {\n      worker.destroy();\n      this.count--;\n    } else {\n      this.idleQueue.push(worker);\n    }\n\n    if (!this.isDestroyed) {\n      this._startQueuedJob(); // eslint-disable-line @typescript-eslint/no-floating-promises\n    }\n  }\n\n  /**\n   * Returns idle worker or creates new worker if maxConcurrency has not been reached\n   */\n  _getAvailableWorker(): WorkerThread | null {\n    // If a worker has completed and returned to the queue, it can be used\n    if (this.idleQueue.length > 0) {\n      return this.idleQueue.shift() || null;\n    }\n\n    // Create fresh worker if we haven't yet created the max amount of worker threads for this worker source\n    if (this.count < this._getMaxConcurrency()) {\n      this.count++;\n      const name = `${this.name.toLowerCase()} (#${this.count} of ${this.maxConcurrency})`;\n      return new WorkerThread({name, source: this.source, url: this.url});\n    }\n\n    // No worker available, have to wait\n    return null;\n  }\n\n  _getMaxConcurrency() {\n    return isMobile ? this.maxMobileConcurrency : this.maxConcurrency;\n  }\n}\n", "import WorkerPool from './worker-pool';\nimport WorkerThread from './worker-thread';\n\n/**\n * @param maxConcurrency - max count of workers\n * @param maxMobileConcurrency - max count of workers on mobile\n * @param maxConcurrency - max count of workers\n * @param reuseWorkers - if false, destroys workers when task is completed\n * @param onDebug - callback intended to allow application to log worker pool activity\n */\nexport type WorkerFarmProps = {\n  maxConcurrency?: number;\n  maxMobileConcurrency?: number;\n  reuseWorkers?: boolean;\n  onDebug?: () => void;\n};\n\nconst DEFAULT_PROPS: Required<WorkerFarmProps> = {\n  maxConcurrency: 3,\n  maxMobileConcurrency: 1,\n  reuseWorkers: true,\n  onDebug: () => {}\n};\n\n/**\n * Process multiple jobs with a \"farm\" of different workers in worker pools.\n */\nexport default class WorkerFarm {\n  private props: WorkerFarmProps;\n  private workerPools = new Map<string, WorkerPool>();\n  // singleton\n  private static _workerFarm?: WorkerFarm;\n\n  /** Checks if workers are supported on this platform */\n  static isSupported(): boolean {\n    return WorkerThread.isSupported();\n  }\n\n  /** Get the singleton instance of the global worker farm */\n  static getWorkerFarm(props: WorkerFarmProps = {}): WorkerFarm {\n    WorkerFarm._workerFarm = WorkerFarm._workerFarm || new WorkerFarm({});\n    WorkerFarm._workerFarm.setProps(props);\n    return WorkerFarm._workerFarm;\n  }\n\n  /** get global instance with WorkerFarm.getWorkerFarm() */\n  private constructor(props: WorkerFarmProps) {\n    this.props = {...DEFAULT_PROPS};\n    this.setProps(props);\n    /** @type Map<string, WorkerPool>} */\n    this.workerPools = new Map();\n  }\n\n  /**\n   * Terminate all workers in the farm\n   * @note Can free up significant memory\n   */\n  destroy(): void {\n    for (const workerPool of this.workerPools.values()) {\n      workerPool.destroy();\n    }\n    this.workerPools = new Map<string, WorkerPool>();\n  }\n\n  /**\n   * Set props used when initializing worker pools\n   * @param props\n   */\n  setProps(props: WorkerFarmProps): void {\n    this.props = {...this.props, ...props};\n    // Update worker pool props\n    for (const workerPool of this.workerPools.values()) {\n      workerPool.setProps(this._getWorkerPoolProps());\n    }\n  }\n\n  /**\n   * Returns a worker pool for the specified worker\n   * @param options - only used first time for a specific worker name\n   * @param options.name - the name of the worker - used to identify worker pool\n   * @param options.url -\n   * @param options.source -\n   * @example\n   *   const job = WorkerFarm.getWorkerFarm().getWorkerPool({name, url}).startJob(...);\n   */\n  getWorkerPool(options: {name: string; source?: string; url?: string}): WorkerPool {\n    const {name, source, url} = options;\n    let workerPool = this.workerPools.get(name);\n    if (!workerPool) {\n      workerPool = new WorkerPool({\n        name,\n        source,\n        url\n      });\n      workerPool.setProps(this._getWorkerPoolProps());\n      this.workerPools.set(name, workerPool);\n    }\n    return workerPool;\n  }\n\n  _getWorkerPoolProps() {\n    return {\n      maxConcurrency: this.props.maxConcurrency,\n      maxMobileConcurrency: this.props.maxMobileConcurrency,\n      reuseWorkers: this.props.reuseWorkers,\n      onDebug: this.props.onDebug\n    };\n  }\n}\n", "import type {WorkerMessageData, WorkerMessageType, WorkerMessagePayload} from '../../types';\nimport {getTransferList} from '../worker-utils/get-transfer-list';\n\n/** Vile hack to defeat over-zealous bundlers from stripping out the require */\nfunction getParentPort() {\n  // const isNode = globalThis.process;\n  let parentPort;\n  try {\n    // prettier-ignore\n    eval('globalThis.parentPort = require(\\'worker_threads\\').parentPort'); // eslint-disable-line no-eval\n    parentPort = globalThis.parentPort;\n    // eslint-disable-next-line no-empty\n  } catch {}\n  return parentPort;\n}\n\nconst onMessageWrapperMap = new Map();\n\n/**\n * Type safe wrapper for worker code\n */\nexport default class WorkerBody {\n  /** Check that we are actually in a worker thread */\n  static inWorkerThread(): boolean {\n    return typeof self !== 'undefined' || Boolean(getParentPort());\n  }\n\n  /*\n   * (type: WorkerMessageType, payload: WorkerMessagePayload) => any\n   */\n  static set onmessage(onMessage: (type: WorkerMessageType, payload: WorkerMessagePayload) => any) {\n    function handleMessage(message) {\n      // Confusingly the message itself also has a 'type' field which is always set to 'message'\n      const parentPort = getParentPort();\n      const {type, payload} = parentPort ? message : message.data;\n      // if (!isKnownMessage(message)) {\n      //   return;\n      // }\n      onMessage(type, payload);\n    }\n\n    const parentPort = getParentPort();\n    if (parentPort) {\n      parentPort.on('message', handleMessage);\n      // if (message == 'exit') { parentPort.unref(); }\n      // eslint-disable-next-line\n      parentPort.on('exit', () => console.debug('Node worker closing'));\n    } else {\n      // eslint-disable-next-line no-restricted-globals\n      globalThis.onmessage = handleMessage;\n    }\n  }\n\n  static addEventListener(\n    onMessage: (type: WorkerMessageType, payload: WorkerMessagePayload) => any\n  ) {\n    let onMessageWrapper = onMessageWrapperMap.get(onMessage);\n\n    if (!onMessageWrapper) {\n      onMessageWrapper = (message: MessageEvent<any>) => {\n        if (!isKnownMessage(message)) {\n          return;\n        }\n\n        // Confusingly in the browser, the message itself also has a 'type' field which is always set to 'message'\n        const parentPort = getParentPort();\n        const {type, payload} = parentPort ? message : message.data;\n        onMessage(type, payload);\n      };\n    }\n\n    const parentPort = getParentPort();\n    if (parentPort) {\n      console.error('not implemented'); // eslint-disable-line\n    } else {\n      globalThis.addEventListener('message', onMessageWrapper);\n    }\n  }\n\n  static removeEventListener(\n    onMessage: (type: WorkerMessageType, payload: WorkerMessagePayload) => any\n  ) {\n    const onMessageWrapper = onMessageWrapperMap.get(onMessage);\n    onMessageWrapperMap.delete(onMessage);\n    const parentPort = getParentPort();\n    if (parentPort) {\n      console.error('not implemented'); // eslint-disable-line\n    } else {\n      globalThis.removeEventListener('message', onMessageWrapper);\n    }\n  }\n\n  /**\n   * Send a message from a worker to creating thread (main thread)\n   * @param type\n   * @param payload\n   */\n  static postMessage(type: WorkerMessageType, payload: WorkerMessagePayload): void {\n    const data: WorkerMessageData = {source: 'loaders.gl', type, payload};\n    // console.log('posting message', data);\n    const transferList = getTransferList(payload);\n\n    const parentPort = getParentPort();\n    if (parentPort) {\n      parentPort.postMessage(data, transferList);\n      // console.log('posted message', data);\n    } else {\n      // @ts-ignore\n      globalThis.postMessage(data, transferList);\n    }\n  }\n}\n\n// Filter out noise messages sent to workers\nfunction isKnownMessage(message: MessageEvent<any>) {\n  const {type, data} = message;\n  return (\n    type === 'message' &&\n    data &&\n    typeof data.source === 'string' &&\n    data.source.startsWith('loaders.gl')\n  );\n}\n", "// loaders.gl, MIT license\n\nimport type {WorkerObject, WorkerOptions} from '../../types';\nimport {assert} from '../env-utils/assert';\nimport {VERSION as __VERSION__} from '../env-utils/version';\n\nconst NPM_TAG = 'latest'; // 'beta', or 'latest' on release-branch\nconst VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : NPM_TAG;\n\n/**\n * Gets worker object's name (for debugging in Chrome thread inspector window)\n */\nexport function getWorkerName(worker: WorkerObject): string {\n  const warning = worker.version !== VERSION ? ` (worker-utils@${VERSION})` : '';\n  return `${worker.name}@${worker.version}${warning}`;\n}\n\n/**\n * Generate a worker URL based on worker object and options\n * @returns A URL to one of the following:\n * - a published worker on unpkg CDN\n * - a local test worker\n * - a URL provided by the user in options\n */\nexport function getWorkerURL(worker: WorkerObject, options: WorkerOptions = {}): string {\n  const workerOptions = options[worker.id] || {};\n\n  const workerFile = `${worker.id}-worker.js`;\n\n  let url = workerOptions.workerUrl;\n\n  // HACK: Allow for non-nested workerUrl for the CompressionWorker.\n  // For the compression worker, workerOptions is currently not nested correctly. For most loaders,\n  // you'd have options within an object, i.e. `{mvt: {coordinates: ...}}` but the CompressionWorker\n  // puts options at the top level, not within a `compression` key (its `id`). For this reason, the\n  // above `workerOptions` will always be a string (i.e. `'gzip'`) for the CompressionWorker. To not\n  // break backwards compatibility, we allow the CompressionWorker to have options at the top level.\n  if (!url && worker.id === 'compression') {\n    url = options.workerUrl;\n  }\n\n  // If URL is test, generate local loaders.gl url\n  // @ts-ignore _workerType\n  if (options._workerType === 'test') {\n    url = `modules/${worker.module}/dist/${workerFile}`;\n  }\n\n  // If url override is not provided, generate a URL to published version on npm CDN unpkg.com\n  if (!url) {\n    // GENERATE\n    let version = worker.version;\n    // On master we need to load npm alpha releases published with the `beta` tag\n    if (version === 'latest') {\n      // throw new Error('latest worker version specified');\n      version = NPM_TAG;\n    }\n    const versionTag = version ? `@${version}` : '';\n    url = `https://unpkg.com/@loaders.gl/${worker.module}${versionTag}/dist/${workerFile}`;\n  }\n\n  assert(url);\n\n  // Allow user to override location\n  return url;\n}\n", "import type {\n  WorkerObject,\n  WorkerOptions,\n  WorkerContext,\n  WorkerMessageType,\n  WorkerMessagePayload\n} from '../../types';\nimport type WorkerJob from '../worker-farm/worker-job';\nimport WorkerFarm from '../worker-farm/worker-farm';\nimport {getWorkerURL, getWorkerName} from './get-worker-url';\nimport {getTransferListForWriter} from '../worker-utils/get-transfer-list';\n\ntype ProcessOnWorkerOptions = WorkerOptions & {\n  jobName?: string;\n  [key: string]: any;\n};\n\n/**\n * Determines if we can parse with worker\n * @param loader\n * @param data\n * @param options\n */\nexport function canProcessOnWorker(worker: WorkerObject, options?: WorkerOptions) {\n  if (!WorkerFarm.isSupported()) {\n    return false;\n  }\n\n  return worker.worker && options?.worker;\n}\n\n/**\n * This function expects that the worker thread sends certain messages,\n * Creating such a worker can be automated if the worker is wrapper by a call to\n * createWorker in @loaders.gl/worker-utils.\n */\nexport async function processOnWorker(\n  worker: WorkerObject,\n  data: any,\n  options: ProcessOnWorkerOptions = {},\n  context: WorkerContext = {}\n): Promise<any> {\n  const name = getWorkerName(worker);\n\n  const workerFarm = WorkerFarm.getWorkerFarm(options);\n  const {source} = options;\n  const workerPoolProps: {name: string; source?: string; url?: string} = {name, source};\n  if (!source) {\n    workerPoolProps.url = getWorkerURL(worker, options);\n  }\n  const workerPool = workerFarm.getWorkerPool(workerPoolProps);\n\n  const jobName = options.jobName || worker.name;\n  const job = await workerPool.startJob(\n    jobName,\n    // eslint-disable-next-line\n    onMessage.bind(null, context)\n  );\n\n  // Kick off the processing in the worker\n  const transferableOptions = getTransferListForWriter(options);\n  job.postMessage('process', {input: data, options: transferableOptions});\n\n  const result = await job.result;\n  return result.result;\n}\n\n/**\n * Job completes when we receive the result\n * @param job\n * @param message\n */\nasync function onMessage(\n  context: WorkerContext,\n  job: WorkerJob,\n  type: WorkerMessageType,\n  payload: WorkerMessagePayload\n) {\n  switch (type) {\n    case 'done':\n      // Worker is done\n      job.done(payload);\n      break;\n\n    case 'error':\n      // Worker encountered an error\n      job.error(new Error(payload.error));\n      break;\n\n    case 'process':\n      // Worker is asking for us (main thread) to process something\n      const {id, input, options} = payload;\n      try {\n        if (!context.process) {\n          job.postMessage('error', {id, error: 'Worker not set up to process on main thread'});\n          return;\n        }\n        const result = await context.process(input, options);\n        job.postMessage('done', {id, result});\n      } catch (error) {\n        const message = error instanceof Error ? error.message : 'unknown error';\n        job.postMessage('error', {id, error: message});\n      }\n      break;\n\n    default:\n      // eslint-disable-next-line\n      console.warn(`process-on-worker: unknown message ${type}`);\n  }\n}\n", "// From https://github.com/rauschma/async-iter-demo/tree/master/src under MIT license\n// http://2ality.com/2016/10/asynchronous-iteration.html\n\n/**\n * Async Queue\n * - AsyncIterable: An async iterator can be\n * - Values can be pushed onto the queue\n * @example\n *   const asyncQueue = new AsyncQueue();\n *   setTimeout(() => asyncQueue.enqueue('tick'), 1000);\n *   setTimeout(() => asyncQueue.enqueue(new Error('done')), 10000);\n *   for await (const value of asyncQueue) {\n *     console.log(value); // tick\n *   }\n */\nexport default class AsyncQueue<T> {\n  private _values: any[];\n  private _settlers: any[];\n  private _closed: boolean;\n\n  constructor() {\n    this._values = []; // enqueues > dequeues\n    this._settlers = []; // dequeues > enqueues\n    this._closed = false;\n  }\n\n  /** Return an async iterator for this queue */\n  [Symbol.asyncIterator](): AsyncIterator<T> {\n    return this;\n  }\n\n  /** Push a new value - the async iterator will yield a promise resolved to this value */\n  push(value: T): void {\n    return this.enqueue(value);\n  }\n\n  /**\n   * Push a new value - the async iterator will yield a promise resolved to this value\n   * Add an error - the async iterator will yield a promise rejected with this value\n   */\n  enqueue(value: T | Error): void {\n    if (this._closed) {\n      throw new Error('Closed');\n    }\n\n    if (this._settlers.length > 0) {\n      if (this._values.length > 0) {\n        throw new Error('Illegal internal state');\n      }\n      const settler = this._settlers.shift();\n      if (value instanceof Error) {\n        settler.reject(value);\n      } else {\n        settler.resolve({value});\n      }\n    } else {\n      this._values.push(value);\n    }\n  }\n\n  /** Indicate that we not waiting for more values - The async iterator will be done */\n  close(): void {\n    while (this._settlers.length > 0) {\n      const settler = this._settlers.shift();\n      settler.resolve({done: true});\n    }\n    this._closed = true;\n  }\n\n  // ITERATOR IMPLEMENTATION\n\n  /** @returns a Promise for an IteratorResult */\n  next(): Promise<IteratorResult<T, any>> {\n    // If values in queue, yield the first value\n    if (this._values.length > 0) {\n      const value = this._values.shift();\n      if (value instanceof Error) {\n        return Promise.reject(value);\n      }\n      return Promise.resolve({done: false, value});\n    }\n\n    // If queue is closed, the iterator is done\n    if (this._closed) {\n      if (this._settlers.length > 0) {\n        throw new Error('Illegal internal state');\n      }\n      return Promise.resolve({done: true, value: undefined});\n    }\n\n    // Yield a promise that waits for new values to be enqueued\n    return new Promise((resolve, reject) => {\n      this._settlers.push({resolve, reject});\n    });\n  }\n}\n", "import type {WorkerObject} from '../../types';\nimport {assert} from '../env-utils/assert';\nimport {VERSION} from '../env-utils/version';\n\n/**\n * Check if worker is compatible with this library version\n * @param worker\n * @param libVersion\n * @returns `true` if the two versions are compatible\n */\nexport function validateWorkerVersion(\n  worker: WorkerObject,\n  coreVersion: string = VERSION\n): boolean {\n  assert(worker, 'no worker provided');\n\n  const workerVersion = worker.version;\n  if (!coreVersion || !workerVersion) {\n    return false;\n  }\n\n  // TODO enable when fix the __version__ injection\n  // const coreVersions = parseVersion(coreVersion);\n  // const workerVersions = parseVersion(workerVersion);\n  // assert(\n  //   coreVersion.major === workerVersion.major && coreVersion.minor <= workerVersion.minor,\n  //   `worker: ${worker.name} is not compatible. ${coreVersion.major}.${\n  //     coreVersion.minor\n  //   }+ is required.`\n  // );\n\n  return true;\n}\n\n// @ts-ignore\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction parseVersion(version) {\n  const parts = version.split('.').map(Number);\n  return {major: parts[0], minor: parts[1]};\n}\n", "/* global importScripts */\nimport {global, isBrowser, isWorker} from '../env-utils/globals';\nimport * as node from '../node/require-utils.node';\nimport {assert} from '../env-utils/assert';\nimport {VERSION as __VERSION__} from '../env-utils/version';\n\n/**\n * TODO - unpkg.com doesn't seem to have a `latest` specifier for alpha releases...\n * 'beta' on beta branch, 'latest' on prod branch\n */\nconst LATEST = 'latest';\nconst VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : LATEST;\n\nconst loadLibraryPromises: Record<string, Promise<any>> = {}; // promises\n\n/**\n * Dynamically loads a library (\"module\")\n *\n * - wasm library: Array buffer is returned\n * - js library: Parse JS is returned\n *\n * Method depends on environment\n * - browser - script element is created and installed on document\n * - worker - eval is called on global context\n * - node - file is required\n *\n * @param libraryUrl\n * @param moduleName\n * @param options\n */\nexport async function loadLibrary(\n  libraryUrl: string,\n  moduleName: string | null = null,\n  options: object = {}\n): Promise<any> {\n  if (moduleName) {\n    libraryUrl = getLibraryUrl(libraryUrl, moduleName, options);\n  }\n\n  // Ensure libraries are only loaded once\n\n  loadLibraryPromises[libraryUrl] =\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    loadLibraryPromises[libraryUrl] || loadLibraryFromFile(libraryUrl);\n  return await loadLibraryPromises[libraryUrl];\n}\n\n// TODO - sort out how to resolve paths for main/worker and dev/prod\nexport function getLibraryUrl(library: string, moduleName?: string, options?: any): string {\n  // Check if already a URL\n  if (library.startsWith('http')) {\n    return library;\n  }\n\n  // Allow application to import and supply libraries through `options.modules`\n  const modules = options.modules || {};\n  if (modules[library]) {\n    return modules[library];\n  }\n\n  // Load from local files, not from CDN scripts in Node.js\n  // TODO - needs to locate the modules directory when installed!\n  if (!isBrowser) {\n    return `modules/${moduleName}/dist/libs/${library}`;\n  }\n\n  // In browser, load from external scripts\n  if (options.CDN) {\n    assert(options.CDN.startsWith('http'));\n    return `${options.CDN}/${moduleName}@${VERSION}/dist/libs/${library}`;\n  }\n\n  // TODO - loading inside workers requires paths relative to worker script location...\n  if (isWorker) {\n    return `../src/libs/${library}`;\n  }\n\n  return `modules/${moduleName}/src/libs/${library}`;\n}\n\nasync function loadLibraryFromFile(libraryUrl: string): Promise<any> {\n  if (libraryUrl.endsWith('wasm')) {\n    const response = await fetch(libraryUrl);\n    return await response.arrayBuffer();\n  }\n\n  if (!isBrowser) {\n    try {\n      return node && node.requireFromFile && (await node.requireFromFile(libraryUrl));\n    } catch {\n      return null;\n    }\n  }\n  if (isWorker) {\n    return importScripts(libraryUrl);\n  }\n  // TODO - fix - should be more secure than string parsing since observes CORS\n  // if (isBrowser) {\n  //   return await loadScriptFromFile(libraryUrl);\n  // }\n\n  const response = await fetch(libraryUrl);\n  const scriptSource = await response.text();\n  return loadLibraryFromString(scriptSource, libraryUrl);\n}\n\n/*\nasync function loadScriptFromFile(libraryUrl) {\n  const script = document.createElement('script');\n  script.src = libraryUrl;\n  return await new Promise((resolve, reject) => {\n    script.onload = data => {\n      resolve(data);\n    };\n    script.onerror = reject;\n  });\n}\n*/\n\n// TODO - Needs security audit...\n//  - Raw eval call\n//  - Potentially bypasses CORS\n// Upside is that this separates fetching and parsing\n// we could create a`LibraryLoader` or`ModuleLoader`\nfunction loadLibraryFromString(scriptSource: string, id: string): null | any {\n  if (!isBrowser) {\n    return node.requireFromString && node.requireFromString(scriptSource, id);\n  }\n\n  if (isWorker) {\n    // Use lvalue trick to make eval run in global scope\n    eval.call(global, scriptSource); // eslint-disable-line no-eval\n    // https://stackoverflow.com/questions/9107240/1-evalthis-vs-evalthis-in-javascript\n    // http://perfectionkills.com/global-eval-what-are-the-options/\n    return null;\n  }\n\n  const script = document.createElement('script');\n  script.id = id;\n  // most browsers like a separate text node but some throw an error. The second method covers those.\n  try {\n    script.appendChild(document.createTextNode(scriptSource));\n  } catch (e) {\n    script.text = scriptSource;\n  }\n  document.body.appendChild(script);\n  return null;\n}\n\n// TODO - technique for module injection into worker, from THREE.DracoLoader...\n/*\nfunction combineWorkerWithLibrary(worker, jsContent) {\n  var fn = wWorker.toString();\n  var body = [\n    '// injected',\n    jsContent,\n    '',\n    '// worker',\n    fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}'))\n  ].join('\\n');\n  this.workerSourceURL = URL.createObjectURL(new Blob([body]));\n}\n*/\n", "import type {WorkerObject} from './types';\nimport {VERSION} from './lib/env-utils/version';\n\n// TYPES\nexport type {\n  WorkerObject,\n  WorkerOptions,\n  // Protocol\n  WorkerMessage,\n  WorkerMessageType,\n  WorkerMessageData,\n  WorkerMessagePayload\n} from './types';\n\n// GENERAL UTILS\nexport {assert} from './lib/env-utils/assert';\nexport {isBrowser, isWorker} from './lib/env-utils/globals';\n\n// WORKER UTILS - TYPES\nexport {default as WorkerJob} from './lib/worker-farm/worker-job';\nexport {default as WorkerThread} from './lib/worker-farm/worker-thread';\n\n// WORKER FARMS\nexport {default as WorkerFarm} from './lib/worker-farm/worker-farm';\nexport {default as WorkerPool} from './lib/worker-farm/worker-pool';\nexport {default as WorkerBody} from './lib/worker-farm/worker-body';\n\nexport {processOnWorker, canProcessOnWorker} from './lib/worker-api/process-on-worker';\nexport {createWorker} from './lib/worker-api/create-worker';\n\n// WORKER UTILS - EXPORTS\nexport {getWorkerURL} from './lib/worker-api/get-worker-url';\nexport {validateWorkerVersion} from './lib/worker-api/validate-worker-version';\nexport {getTransferList, getTransferListForWriter} from './lib/worker-utils/get-transfer-list';\n\n// LIBRARY UTILS\nexport {getLibraryUrl, loadLibrary} from './lib/library-utils/library-utils';\n\n// PARSER UTILS\nexport {default as AsyncQueue} from './lib/async-queue/async-queue';\n\n// PROCESS UTILS\nexport {default as ChildProcessProxy} from './lib/process-utils/child-process-proxy';\n\n// WORKER OBJECTS\n\n/** A null worker to test that worker processing is functional */\nexport const NullWorker: WorkerObject = {\n  id: 'null',\n  name: 'null',\n  module: 'worker-utils',\n  version: VERSION,\n  options: {\n    null: {}\n  }\n};\n", "import {\n  WorkerJob,\n  WorkerMessageType,\n  WorkerMessagePayload,\n  isBrowser\n} from '@loaders.gl/worker-utils';\nimport type {Loader, LoaderOptions, LoaderContext} from '../../types';\nimport {WorkerFarm, getWorkerURL} from '@loaders.gl/worker-utils';\n\n/**\n * Determines if a loader can parse with worker\n * @param loader\n * @param options\n */\nexport function canParseWithWorker(loader: Loader, options?: LoaderOptions) {\n  if (!WorkerFarm.isSupported()) {\n    return false;\n  }\n\n  // Node workers are still experimental\n  if (!isBrowser && !options?._nodeWorkers) {\n    return false;\n  }\n\n  return loader.worker && options?.worker;\n}\n\n/**\n * this function expects that the worker function sends certain messages,\n * this can be automated if the worker is wrapper by a call to createLoaderWorker in @loaders.gl/loader-utils.\n */\nexport async function parseWithWorker(\n  loader: Loader,\n  data: any,\n  options?: LoaderOptions,\n  context?: LoaderContext,\n  parseOnMainThread?: (arrayBuffer: ArrayBuffer, options: {[key: string]: any}) => Promise<void>\n) {\n  const name = loader.id; // TODO\n  const url = getWorkerURL(loader, options);\n\n  const workerFarm = WorkerFarm.getWorkerFarm(options);\n  const workerPool = workerFarm.getWorkerPool({name, url});\n\n  // options.log object contains functions which cannot be transferred\n  // context.fetch & context.parse functions cannot be transferred\n  // TODO - decide how to handle logging on workers\n  options = JSON.parse(JSON.stringify(options));\n  context = JSON.parse(JSON.stringify(context || {}));\n\n  const job = await workerPool.startJob(\n    'process-on-worker',\n    // @ts-expect-error\n    onMessage.bind(null, parseOnMainThread) // eslint-disable-line @typescript-eslint/no-misused-promises\n  );\n\n  job.postMessage('process', {\n    // @ts-ignore\n    input: data,\n    options,\n    context\n  });\n\n  const result = await job.result;\n  // TODO - what is going on here?\n  return await result.result;\n}\n\n/**\n * Handle worker's responses to the main thread\n * @param job\n * @param type\n * @param payload\n */\nasync function onMessage(\n  parseOnMainThread: (arrayBuffer: ArrayBuffer, options?: {[key: string]: any}) => Promise<void>,\n  job: WorkerJob,\n  type: WorkerMessageType,\n  payload: WorkerMessagePayload\n) {\n  switch (type) {\n    case 'done':\n      job.done(payload);\n      break;\n\n    case 'error':\n      job.error(new Error(payload.error));\n      break;\n\n    case 'process':\n      // Worker is asking for main thread to parseO\n      const {id, input, options} = payload;\n      try {\n        const result = await parseOnMainThread(input, options);\n        job.postMessage('done', {id, result});\n      } catch (error) {\n        const message = error instanceof Error ? error.message : 'unknown error';\n        job.postMessage('error', {id, error: message});\n      }\n      break;\n\n    default:\n      // eslint-disable-next-line\n      console.warn(`parse-with-worker unknown message ${type}`);\n  }\n}\n", "import {WorkerFarm} from '@loaders.gl/worker-utils';\nimport {Writer, WriterOptions} from '../../types';\nimport {isBrowser} from '../env-utils/globals';\n\n/**\n * Determines if a loader can parse with worker\n * @param loader\n * @param options\n */\nexport function canEncodeWithWorker(writer: Writer, options?: WriterOptions) {\n  if (!WorkerFarm.isSupported()) {\n    return false;\n  }\n\n  // Node workers are still experimental\n  if (!isBrowser && !options?._nodeWorkers) {\n    return false;\n  }\n\n  return writer.worker && options?.worker;\n}\n", "// loaders.gl, MIT license\n\n/**\n * Get the first characters from a binary file (interpret the first bytes as an ASCII string)\n * @param data\n * @param length\n * @returns\n */\nexport function getFirstCharacters(data: string | ArrayBuffer, length: number = 5): string {\n  if (typeof data === 'string') {\n    return data.slice(0, length);\n  } else if (ArrayBuffer.isView(data)) {\n    // Typed Arrays can have offsets into underlying buffer\n    return getMagicString(data.buffer, data.byteOffset, length);\n  } else if (data instanceof ArrayBuffer) {\n    const byteOffset = 0;\n    return getMagicString(data, byteOffset, length);\n  }\n  return '';\n}\n\n/**\n * Gets a magic string from a \"file\"\n * Typically used to check or detect file format\n * @param arrayBuffer\n * @param byteOffset\n * @param length\n * @returns\n */\nexport function getMagicString(\n  arrayBuffer: ArrayBuffer,\n  byteOffset: number,\n  length: number\n): string {\n  if (arrayBuffer.byteLength <= byteOffset + length) {\n    return '';\n  }\n  const dataView = new DataView(arrayBuffer);\n  let magic = '';\n  for (let i = 0; i < length; i++) {\n    magic += String.fromCharCode(dataView.getUint8(byteOffset + i));\n  }\n  return magic;\n}\n", "import {getFirstCharacters} from '../binary-utils/get-first-characters';\n\n/**\n * Minimal JSON parser that throws more meaningful error messages\n */\nexport function parseJSON(string: string): any {\n  try {\n    return JSON.parse(string);\n  } catch (_) {\n    throw new Error(`Failed to parse JSON from data starting with \"${getFirstCharacters(string)}\"`);\n  }\n}\n", "import {assert} from '../env-utils/assert';\n\n/**\n * Calculate new size of an arrayBuffer to be aligned to an n-byte boundary\n * This function increases `byteLength` by the minimum delta,\n * allowing the total length to be divided by `padding`\n * @param byteLength\n * @param padding\n */\nexport function padToNBytes(byteLength: number, padding: number): number {\n  assert(byteLength >= 0); // `Incorrect 'byteLength' value: ${byteLength}`\n  assert(padding > 0); // `Incorrect 'padding' value: ${padding}`\n  return (byteLength + (padding - 1)) & ~(padding - 1);\n}\n\n/**\n * Creates a new Uint8Array based on two different ArrayBuffers\n * @param targetBuffer The first buffer.\n * @param sourceBuffer The second buffer.\n * @return The new ArrayBuffer created out of the two.\n */\nexport function copyArrayBuffer(\n  targetBuffer: ArrayBuffer,\n  sourceBuffer: ArrayBuffer,\n  byteOffset: number,\n  byteLength: number = sourceBuffer.byteLength\n): ArrayBuffer {\n  const targetArray = new Uint8Array(targetBuffer, byteOffset, byteLength);\n  const sourceArray = new Uint8Array(sourceBuffer);\n  targetArray.set(sourceArray);\n  return targetBuffer;\n}\n\n/**\n * Copy from source to target at the targetOffset\n *\n * @param source - The data to copy\n * @param target - The destination to copy data into\n * @param targetOffset - The start offset into target to place the copied data\n * @returns the new offset taking into account proper padding\n */\nexport function copyToArray(source: ArrayBuffer | any, target: any, targetOffset: number): number {\n  let sourceArray;\n\n  if (source instanceof ArrayBuffer) {\n    sourceArray = new Uint8Array(source);\n  } else {\n    // Pack buffer onto the big target array\n    //\n    // 'source.data.buffer' could be a view onto a larger buffer.\n    // We MUST use this constructor to ensure the byteOffset and byteLength is\n    // set to correct values from 'source.data' and not the underlying\n    // buffer for target.set() to work properly.\n    const srcByteOffset = source.byteOffset;\n    const srcByteLength = source.byteLength;\n    // In gltf parser it is set as \"arrayBuffer\" instead of \"buffer\"\n    // https://github.com/visgl/loaders.gl/blob/1e3a82a0a65d7b6a67b1e60633453e5edda2960a/modules/gltf/src/lib/parse-gltf.js#L85\n    sourceArray = new Uint8Array(source.buffer || source.arrayBuffer, srcByteOffset, srcByteLength);\n  }\n\n  // Pack buffer onto the big target array\n  target.set(sourceArray, targetOffset);\n\n  return targetOffset + padToNBytes(sourceArray.byteLength, 4);\n}\n", "// loaders./gl, MIT license\n\nimport {TypedArray} from '../../types';\nimport {padToNBytes} from './memory-copy-utils';\n\n/**\n * Helper function that pads a string with spaces to fit a certain byte alignment\n * @param string\n * @param byteAlignment\n * @returns\n *\n * @todo PERFORMANCE IDEA: No need to copy string twice...\n */\nexport function padStringToByteAlignment(string: string, byteAlignment: number): string {\n  const length = string.length;\n  const paddedLength = Math.ceil(length / byteAlignment) * byteAlignment; // Round up to the required alignment\n  const padding = paddedLength - length;\n  let whitespace = '';\n  for (let i = 0; i < padding; ++i) {\n    whitespace += ' ';\n  }\n  return string + whitespace;\n}\n\n/**\n *\n * @param dataView\n * @param byteOffset\n * @param string\n * @param byteLength\n * @returns\n */\nexport function copyStringToDataView(\n  dataView: DataView,\n  byteOffset: number,\n  string: string,\n  byteLength: number\n): number {\n  if (dataView) {\n    for (let i = 0; i < byteLength; i++) {\n      dataView.setUint8(byteOffset + i, string.charCodeAt(i));\n    }\n  }\n  return byteOffset + byteLength;\n}\n\nexport function copyBinaryToDataView(dataView, byteOffset, binary, byteLength) {\n  if (dataView) {\n    for (let i = 0; i < byteLength; i++) {\n      dataView.setUint8(byteOffset + i, binary[i]);\n    }\n  }\n  return byteOffset + byteLength;\n}\n\n/**\n * Copy sourceBuffer to dataView with some padding\n *\n * @param dataView - destination data container. If null - only new offset is calculated\n * @param byteOffset - destination byte offset to copy to\n * @param sourceBuffer - source data buffer\n * @param padding - pad the resulting array to multiple of \"padding\" bytes. Additional bytes are filled with 0x20 (ASCII space)\n *\n * @return new byteOffset of resulting dataView\n */\nexport function copyPaddedArrayBufferToDataView(\n  dataView: DataView | null,\n  byteOffset: number,\n  sourceBuffer: TypedArray,\n  padding: number\n): number {\n  const paddedLength = padToNBytes(sourceBuffer.byteLength, padding);\n  const padLength = paddedLength - sourceBuffer.byteLength;\n\n  if (dataView) {\n    // Copy array\n    const targetArray = new Uint8Array(\n      dataView.buffer,\n      dataView.byteOffset + byteOffset,\n      sourceBuffer.byteLength\n    );\n    const sourceArray = new Uint8Array(sourceBuffer);\n    targetArray.set(sourceArray);\n\n    // Add PADDING\n    for (let i = 0; i < padLength; ++i) {\n      // json chunk is padded with spaces (ASCII 0x20)\n      dataView.setUint8(byteOffset + sourceBuffer.byteLength + i, 0x20);\n    }\n  }\n  byteOffset += paddedLength;\n  return byteOffset;\n}\n\n/**\n * Copy string to dataView with some padding\n *\n * @param {DataView | null} dataView - destination data container. If null - only new offset is calculated\n * @param {number} byteOffset - destination byte offset to copy to\n * @param {string} string - source string\n * @param {number} padding - pad the resulting array to multiple of \"padding\" bytes. Additional bytes are filled with 0x20 (ASCII space)\n *\n * @return new byteOffset of resulting dataView\n */\nexport function copyPaddedStringToDataView(\n  dataView: DataView | null,\n  byteOffset: number,\n  string: string,\n  padding: number\n): number {\n  const textEncoder = new TextEncoder();\n  // PERFORMANCE IDEA: We encode twice, once to get size and once to store\n  // PERFORMANCE IDEA: Use TextEncoder.encodeInto() to avoid temporary copy\n  const stringBuffer = textEncoder.encode(string);\n\n  byteOffset = copyPaddedArrayBufferToDataView(dataView, byteOffset, stringBuffer, padding);\n\n  return byteOffset;\n}\n", "// loaders.gl, MIT license\n\nimport * as node from '../node/buffer';\n\n/**\n * Check for Node.js `Buffer` (without triggering bundler to include Buffer polyfill on browser)\n */\nexport function isBuffer(value: any): boolean {\n  return value && typeof value === 'object' && value.isBuffer;\n}\n\n/**\n * Converts to Node.js `Buffer` (without triggering bundler to include Buffer polyfill on browser)\n * @todo better data type\n */\nexport function toBuffer(data: any): Buffer {\n  return node.toBuffer ? node.toBuffer(data) : data;\n}\n\n/**\n * Convert an object to an array buffer\n */\nexport function toArrayBuffer(data: unknown): ArrayBuffer {\n  // Note: Should be called first, Buffers can trigger other detections below\n  if (isBuffer(data)) {\n    return node.toArrayBuffer(data);\n  }\n\n  if (data instanceof ArrayBuffer) {\n    return data;\n  }\n\n  // Careful - Node Buffers look like Uint8Arrays (keep after isBuffer)\n  if (ArrayBuffer.isView(data)) {\n    if (data.byteOffset === 0 && data.byteLength === data.buffer.byteLength) {\n      return data.buffer;\n    }\n    return data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);\n  }\n\n  if (typeof data === 'string') {\n    const text = data;\n    const uint8Array = new TextEncoder().encode(text);\n    return uint8Array.buffer;\n  }\n\n  // HACK to support Blob polyfill\n  if (data && typeof data === 'object' && (data as any)._toArrayBuffer) {\n    return (data as any)._toArrayBuffer();\n  }\n\n  throw new Error('toArrayBuffer');\n}\n", "// Beginning of a minimal implementation of the Node.js path API, that doesn't pull in big polyfills.\n\n/**\n * Replacement for Node.js path.filename\n * @param url\n */\nexport function filename(url: string): string {\n  const slashIndex = url && url.lastIndexOf('/');\n  return slashIndex >= 0 ? url.substr((slashIndex as number) + 1) : '';\n}\n\n/**\n * Replacement for Node.js path.dirname\n * @param url\n */\nexport function dirname(url: string): string {\n  const slashIndex = url && url.lastIndexOf('/');\n  return slashIndex >= 0 ? url.substr(0, slashIndex as number) : '';\n}\n\n/**\n * Replacement for Node.js path.join\n * @param parts\n */\nexport function join(...parts: string[]): string {\n  const separator = '/';\n  parts = parts.map((part, index) => {\n    if (index) {\n      part = part.replace(new RegExp(`^${separator}`), '');\n    }\n    if (index !== parts.length - 1) {\n      part = part.replace(new RegExp(`${separator}$`), '');\n    }\n    return part;\n  });\n  return parts.join(separator);\n}\n", "// TYPES\nexport type {\n  Loader,\n  LoaderWithParser,\n  LoaderContext,\n  LoaderOptions,\n  Writer,\n  WriterOptions,\n  DataType,\n  SyncDataType,\n  BatchableDataType,\n  IFileSystem,\n  IRandomAccessReadFileSystem\n} from './types';\n\n// GENERAL UTILS\nexport {assert} from './lib/env-utils/assert';\nexport {\n  isBrowser,\n  isWorker,\n  nodeVersion,\n  self,\n  window,\n  global,\n  document\n} from './lib/env-utils/globals';\n\n// LOADERS.GL-SPECIFIC WORKER UTILS\nexport {createLoaderWorker} from './lib/worker-loader-utils/create-loader-worker';\nexport {parseWithWorker, canParseWithWorker} from './lib/worker-loader-utils/parse-with-worker';\nexport {canEncodeWithWorker} from './lib/worker-loader-utils/encode-with-worker';\n\n// PARSER UTILS\nexport {parseJSON} from './lib/parser-utils/parse-json';\n\n// MEMORY COPY UTILS\nexport {\n  sliceArrayBuffer,\n  concatenateArrayBuffers,\n  concatenateTypedArrays,\n  compareArrayBuffers\n} from './lib/binary-utils/array-buffer-utils';\nexport {padToNBytes, copyToArray, copyArrayBuffer} from './lib/binary-utils/memory-copy-utils';\nexport {\n  padStringToByteAlignment,\n  copyStringToDataView,\n  copyBinaryToDataView,\n  copyPaddedArrayBufferToDataView,\n  copyPaddedStringToDataView\n} from './lib/binary-utils/dataview-copy-utils';\nexport {getFirstCharacters, getMagicString} from './lib/binary-utils/get-first-characters';\n\n// ITERATOR UTILS\nexport {\n  makeTextEncoderIterator,\n  makeTextDecoderIterator,\n  makeLineIterator,\n  makeNumberedLineIterator\n} from './lib/iterators/text-iterators';\nexport {forEach, concatenateArrayBuffersAsync} from './lib/iterators/async-iteration';\n\n// REQUEST UTILS\nexport {default as RequestScheduler} from './lib/request-utils/request-scheduler';\n\n// PATH HELPERS\nexport {setPathPrefix, getPathPrefix, resolvePath} from './lib/path-utils/file-aliases';\nexport {addAliases as _addAliases} from './lib/path-utils/file-aliases';\n\n// MICRO LOADERS\nexport {JSONLoader} from './json-loader';\n\n// NODE support\n\n// Node.js emulation (can be used in browser)\n\n// Avoid direct use of `Buffer` which pulls in 50KB polyfill\nexport {isBuffer, toBuffer, toArrayBuffer} from './lib/binary-utils/memory-conversion-utils';\n\n// Note.js wrappers (can be safely imported, but not used in browser)\n\n// Use instead of importing 'util' to avoid node dependencies\nexport {promisify1, promisify2} from './lib/node/promisify';\n\n// `path` replacement (avoids bundling big path polyfill)\nimport * as path from './lib/path-utils/path';\nexport {path};\n\n// Use instead of importing 'fs' to avoid node dependencies`\nimport * as fs from './lib/node/fs';\nexport {fs};\n\n// Use instead of importing 'stream' to avoid node dependencies`\nimport * as stream from './lib/node/stream';\nexport {stream};\n\n// EXPERIMENTAL\nexport type {ReadableFile} from './lib/filesystems/readable-file';\nexport {makeReadableFile} from './lib/filesystems/readable-file';\n\nexport type {WritableFile} from './lib/filesystems/writable-file';\nexport {makeWritableFile} from './lib/filesystems/writable-file';\n\nexport {default as _NodeFileSystem} from './lib/filesystems/node-filesystem';\n", "// loaders.gl, MIT license\n\nimport stream from 'stream';\n\nexport type {Writable} from 'stream';\n\nexport let Transform;\n\nexport const isSupported = Boolean(stream);\n\n// paths\n\ntry {\n  /** Wrapper for Node.js fs method */\n  Transform = stream.Transform;\n} catch {\n  // ignore\n}\n", "// Forked from https://github.com/kbajalc/parquets under MIT license (Copyright (c) 2017 ironSource Ltd.)\nimport {isBrowser} from '@loaders.gl/loader-utils';\nimport * as fs from '../node/fs';\nimport type {Writable} from 'stream';\n\nexport type WritableFile = {\n  write: (buf: Buffer) => Promise<void>;\n  close: () => Promise<void>;\n};\n\nexport interface WriteStreamOptions {\n  flags?: string;\n  encoding?: 'utf8';\n  fd?: number;\n  mode?: number;\n  autoClose?: boolean;\n  start?: number;\n}\n\n/** Helper function to create an envelope reader for a binary memory input */\nexport function makeWritableFile(\n  pathOrStream: string | Writable,\n  options?: WriteStreamOptions\n): WritableFile {\n  if (isBrowser) {\n    return {\n      write: async () => {},\n      close: async () => {}\n    };\n  }\n\n  const outputStream: Writable =\n    typeof pathOrStream === 'string' ? fs.createWriteStream(pathOrStream, options) : pathOrStream;\n  return {\n    write: async (buffer: Buffer) =>\n      new Promise((resolve, reject) => {\n        outputStream.write(buffer, (err) => (err ? reject(err) : resolve()));\n      }),\n    close: () =>\n      new Promise((resolve, reject) => {\n        (outputStream as any).close((err) => (err ? reject(err) : resolve()));\n      })\n  };\n}\n", "import * as fs from '../node/fs';\nimport {IFileSystem, IRandomAccessReadFileSystem} from '../../types';\n// import {fetchFile} from \"../fetch/fetch-file\"\n// import {selectLoader} from \"../api/select-loader\";\n\ntype Stat = {\n  size: number;\n  isDirectory: () => boolean;\n  info?: fs.Stats;\n};\n\ntype ReadOptions = {\n  buffer?: Buffer;\n  offset?: number;\n  length?: number;\n  position?: number;\n};\n\n/**\n * FileSystem pass-through for Node.js\n * Compatible with BrowserFileSystem.\n * @param options\n */\nexport default class NodeFileSystem implements IFileSystem, IRandomAccessReadFileSystem {\n  // implements IFileSystem\n  constructor(options: {[key: string]: any}) {\n    this.fetch = options._fetch;\n  }\n\n  async readdir(dirname = '.', options?: {}): Promise<any[]> {\n    return await fs.readdir(dirname, options);\n  }\n\n  async stat(path: string, options?: {}): Promise<Stat> {\n    const info = await fs.stat(path, options);\n    return {size: Number(info.size), isDirectory: () => false, info};\n  }\n\n  async fetch(path: string, options: {[key: string]: any}) {\n    // Falls back to handle https:/http:/data: etc fetches\n    // eslint-disable-next-line\n    const fallbackFetch = options.fetch || this.fetch;\n    return fallbackFetch(path, options);\n  }\n\n  // implements IRandomAccessFileSystem\n  async open(path: string, flags: string | number, mode?: any): Promise<number> {\n    return await fs.open(path, flags);\n  }\n\n  async close(fd: number): Promise<void> {\n    return await fs.close(fd);\n  }\n\n  async fstat(fd: number): Promise<Stat> {\n    const info = await fs.fstat(fd);\n    return info;\n  }\n\n  async read(\n    fd: number,\n    // @ts-ignore Possibly null\n    {buffer = null, offset = 0, length = buffer.byteLength, position = null}: ReadOptions\n  ): Promise<{bytesRead: number; buffer: Buffer}> {\n    let totalBytesRead = 0;\n    // Read in loop until we get required number of bytes\n    while (totalBytesRead < length) {\n      const {bytesRead} = await fs.read(\n        fd,\n        buffer,\n        offset + totalBytesRead,\n        length - totalBytesRead,\n        position + totalBytesRead\n      );\n      totalBytesRead += bytesRead;\n    }\n    return {bytesRead: totalBytesRead, buffer};\n  }\n}\n"],
  "mappings": "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",
  "names": ["assert", "condition", "message", "Error", "globals", "self", "window", "global", "document", "self_", "window_", "global_", "document_", "isBrowser", "Boolean", "process", "String", "browser", "isWorker", "importScripts", "matches", "version", "exec", "nodeVersion", "parseFloat", "makeTextDecoderIterator", "arrayBufferIterator", "options", "textDecoder", "TextDecoder", "undefined", "arrayBuffer", "decode", "stream", "makeTextEncoderIterator", "textIterator", "textEncoder", "TextEncoder", "text", "encode", "makeLineIterator", "previous", "textChunk", "eolIndex", "indexOf", "line", "slice", "length", "makeNumberedLineIterator", "lineIterator", "counter", "compareArrayBuffers", "arrayBuffer1", "arrayBuffer2", "byteLength", "array1", "Uint8Array", "array2", "i", "length", "concatenateArrayBuffers", "sources", "sourceArrays", "map", "source2", "ArrayBuffer", "reduce", "typedArray", "result", "offset", "sourceArray", "set", "buffer", "sliceArrayBuffer", "arrayBuffer", "byteOffset", "byteLength", "subArray", "undefined", "Uint8Array", "subarray", "arrayCopy", "buffer", "forEach", "iterator", "visitor", "done", "value", "next", "return", "cancel", "concatenateArrayBuffersAsync", "asyncIterator", "arrayBuffers", "chunk", "push", "concatenateArrayBuffers", "obj", "timestamp", "window", "performance", "now", "process", "hrtime", "timeParts", "Date", "Stat", "constructor", "name", "type", "reset", "setSampleSize", "samples", "sampleSize", "incrementCount", "addCount", "decrementCount", "subtractCount", "value", "_count", "_samples", "_checkSampling", "addTime", "time", "_time", "lastTiming", "timeStart", "_startTime", "getHiResTimestamp", "_timerPending", "timeEnd", "getSampleAverageCount", "lastSampleCount", "getSampleAverageTime", "lastSampleTime", "getSampleHz", "getAverageCount", "count", "getAverageTime", "getHz", "Stats", "constructor", "options", "id", "stats", "_initializeStats", "Object", "seal", "get", "name", "type", "_getOrCreate", "size", "keys", "length", "reset", "key", "forEach", "fn", "getTable", "table", "stat", "time", "count", "average", "getAverageTime", "hz", "getHz", "Stat", "STAT_QUEUED_REQUESTS", "STAT_ACTIVE_REQUESTS", "STAT_CANCELLED_REQUESTS", "STAT_QUEUED_REQUESTS_EVER", "STAT_ACTIVE_REQUESTS_EVER", "DEFAULT_PROPS", "id", "throttleRequests", "maxRequests", "RequestScheduler", "constructor", "props", "Map", "stats", "Stats", "get", "scheduleRequest", "handle", "getPriority", "Promise", "resolve", "done", "requestMap", "has", "request", "priority", "promise", "requestQueue", "push", "set", "_issueNewRequests", "_issueRequest", "isDone", "delete", "activeRequestCount", "deferredUpdate", "setTimeout", "_issueNewRequestsAsync", "freeSlots", "Math", "max", "_updateAllRequests", "i", "shift", "length", "_updateRequest", "splice", "sort", "a", "b", "pathPrefix", "fileAliases", "setPathPrefix", "prefix", "getPathPrefix", "resolvePath", "filename", "alias", "fileAliases", "startsWith", "replacement", "replace", "pathPrefix", "VERSION", "JSONLoader", "name", "id", "module", "version", "extensions", "mimeTypes", "category", "text", "parseTextSync", "parse", "arrayBuffer", "TextDecoder", "decode", "options", "JSON", "VERSION", "DEFAULT_VERSION", "console", "error", "assert", "condition", "message", "Error", "globals", "self", "window", "global", "document", "self_", "window_", "global_", "document_", "isBrowser", "process", "String", "browser", "isWorker", "importScripts", "isMobile", "window", "orientation", "matches", "version", "exec", "nodeVersion", "parseFloat", "WorkerJob", "constructor", "jobName", "workerThread", "name", "result", "Promise", "resolve", "reject", "_resolve", "_reject", "postMessage", "type", "payload", "source", "done", "value", "assert", "isRunning", "error", "Worker", "terminate", "workerURLCache", "Map", "getLoadableWorkerURL", "props", "assert", "source", "url", "workerURL", "get", "getLoadableWorkerURLFromURL", "set", "getLoadableWorkerURLFromSource", "startsWith", "workerSource", "buildScriptSource", "blob", "Blob", "type", "URL", "createObjectURL", "workerUrl", "getTransferList", "object", "recursive", "transfers", "transfersSet", "Set", "isTransferable", "add", "buffer", "ArrayBuffer", "isView", "key", "undefined", "Array", "from", "MessagePort", "ImageBitmap", "OffscreenCanvas", "getTransferListForWriter", "clone", "Object", "assign", "keys", "forEach", "RegExp", "NOOP", "WorkerThread", "isSupported", "Worker", "isBrowser", "NodeWorker", "constructor", "props", "name", "source", "url", "assert", "onMessage", "onError", "error", "console", "log", "worker", "_createBrowserWorker", "_createNodeWorker", "destroy", "terminate", "terminated", "isRunning", "Boolean", "postMessage", "data", "transferList", "getTransferList", "_getErrorFromErrorEvent", "event", "message", "lineno", "colno", "Error", "_loadableURL", "getLoadableWorkerURL", "onmessage", "onerror", "onmessageerror", "absolute", "includes", "startsWith", "eval", "on", "code", "WorkerPool", "isSupported", "WorkerThread", "constructor", "props", "source", "url", "setProps", "destroy", "idleQueue", "forEach", "worker", "isDestroyed", "name", "undefined", "maxConcurrency", "maxMobileConcurrency", "reuseWorkers", "onDebug", "startJob", "onMessage", "job", "type", "data", "done", "onError", "error", "startPromise", "Promise", "onStart", "jobQueue", "push", "_startQueuedJob", "length", "workerThread", "_getAvailableWorker", "queuedJob", "shift", "message", "backlog", "WorkerJob", "payload", "result", "returnWorkerToQueue", "shouldDestroyWorker", "count", "_getMaxConcurrency", "toLowerCase", "isMobile", "DEFAULT_PROPS", "maxConcurrency", "maxMobileConcurrency", "reuseWorkers", "onDebug", "WorkerFarm", "isSupported", "WorkerThread", "getWorkerFarm", "props", "_workerFarm", "setProps", "constructor", "Map", "workerPools", "destroy", "workerPool", "values", "_getWorkerPoolProps", "getWorkerPool", "options", "name", "source", "url", "get", "WorkerPool", "set", "getParentPort", "parentPort", "eval", "globalThis", "onMessageWrapperMap", "Map", "WorkerBody", "inWorkerThread", "self", "Boolean", "onmessage", "onMessage", "handleMessage", "message", "type", "payload", "data", "on", "console", "debug", "addEventListener", "onMessageWrapper", "get", "isKnownMessage", "error", "removeEventListener", "delete", "postMessage", "source", "transferList", "getTransferList", "startsWith", "NPM_TAG", "VERSION", "getWorkerName", "worker", "warning", "version", "name", "getWorkerURL", "options", "workerOptions", "id", "workerFile", "url", "workerUrl", "_workerType", "module", "versionTag", "assert", "processOnWorker", "worker", "data", "options", "context", "name", "getWorkerName", "workerFarm", "WorkerFarm", "getWorkerFarm", "source", "workerPoolProps", "url", "getWorkerURL", "workerPool", "getWorkerPool", "jobName", "job", "startJob", "onMessage", "bind", "transferableOptions", "getTransferListForWriter", "postMessage", "input", "result", "type", "payload", "done", "error", "Error", "id", "process", "message", "console", "warn", "Symbol", "asyncIterator", "AsyncQueue", "constructor", "_values", "_settlers", "_closed", "push", "value", "enqueue", "Error", "length", "settler", "shift", "reject", "resolve", "close", "done", "next", "Promise", "undefined", "validateWorkerVersion", "worker", "coreVersion", "VERSION", "assert", "workerVersion", "version", "VERSION", "LATEST", "loadLibraryPromises", "loadLibrary", "libraryUrl", "moduleName", "options", "getLibraryUrl", "loadLibraryFromFile", "library", "startsWith", "modules", "isBrowser", "CDN", "assert", "isWorker", "endsWith", "response", "fetch", "arrayBuffer", "node", "requireFromFile", "importScripts", "scriptSource", "text", "loadLibraryFromString", "id", "requireFromString", "eval", "call", "global", "script", "document", "createElement", "appendChild", "createTextNode", "e", "body", "canParseWithWorker", "loader", "options", "WorkerFarm", "isSupported", "isBrowser", "_nodeWorkers", "worker", "parseWithWorker", "data", "context", "parseOnMainThread", "name", "id", "url", "getWorkerURL", "workerFarm", "getWorkerFarm", "workerPool", "getWorkerPool", "JSON", "parse", "stringify", "job", "startJob", "onMessage", "bind", "postMessage", "input", "result", "type", "payload", "done", "error", "Error", "message", "console", "warn", "canEncodeWithWorker", "writer", "options", "WorkerFarm", "isSupported", "isBrowser", "_nodeWorkers", "worker", "getFirstCharacters", "data", "length", "slice", "ArrayBuffer", "isView", "getMagicString", "buffer", "byteOffset", "arrayBuffer", "byteLength", "dataView", "DataView", "magic", "i", "String", "fromCharCode", "getUint8", "parseJSON", "string", "JSON", "parse", "_", "Error", "getFirstCharacters", "padToNBytes", "byteLength", "padding", "assert", "copyToArray", "source", "target", "targetOffset", "sourceArray", "ArrayBuffer", "Uint8Array", "srcByteOffset", "byteOffset", "srcByteLength", "byteLength", "buffer", "arrayBuffer", "set", "padToNBytes", "copyPaddedArrayBufferToDataView", "dataView", "byteOffset", "sourceBuffer", "padding", "paddedLength", "padToNBytes", "byteLength", "padLength", "targetArray", "Uint8Array", "buffer", "sourceArray", "set", "i", "setUint8", "copyPaddedStringToDataView", "string", "textEncoder", "TextEncoder", "stringBuffer", "encode", "node", "isBuffer", "value", "toBuffer", "data", "toArrayBuffer", "ArrayBuffer", "isView", "byteOffset", "byteLength", "buffer", "slice", "text", "uint8Array", "TextEncoder", "encode", "_toArrayBuffer", "Error", "filename", "url", "slashIndex", "lastIndexOf", "substr", "dirname", "join", "parts", "separator", "map", "part", "index", "replace", "RegExp", "length", "fs", "Transform", "isSupported", "Boolean", "stream", "fs"]
}
