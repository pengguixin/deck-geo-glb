{
  "version": 3,
  "sources": ["../../@loaders.gl/gltf/src/lib/utils/version.ts", "../../@loaders.gl/textures/src/lib/utils/version.ts", "../../@loaders.gl/textures/src/lib/parsers/basis-module-loader.ts", "../../@loaders.gl/textures/src/lib/gl-extensions.ts", "../../@loaders.gl/textures/src/lib/utils/texture-formats.ts", "../../ktx-parse/src/constants.ts", "../../ktx-parse/src/container.ts", "../../ktx-parse/src/buffer-reader.ts", "../../ktx-parse/src/util.ts", "../../ktx-parse/src/read.ts", "../../ktx-parse/src/write.ts", "../../@loaders.gl/textures/src/lib/utils/extract-mipmap-images.ts", "../../@loaders.gl/textures/src/lib/utils/ktx-format-helper.ts", "../../@loaders.gl/textures/src/lib/parsers/parse-ktx.ts", "../../@loaders.gl/textures/src/lib/parsers/parse-basis.ts", "../../@loaders.gl/textures/src/basis-loader.ts", "../../@loaders.gl/textures/src/lib/parsers/parse-dds.ts", "../../@loaders.gl/textures/src/lib/parsers/parse-pvr.ts", "../../@loaders.gl/textures/src/lib/parsers/parse-compressed-texture.ts", "../../@loaders.gl/textures/src/compressed-texture-loader.ts", "../../@loaders.gl/textures/src/lib/parsers/parse-npy.ts", "../../@loaders.gl/textures/src/npy-loader.ts", "../../@loaders.gl/gltf/src/lib/utils/assert.ts", "../../@loaders.gl/gltf/src/lib/gltf-utils/resolve-url.ts", "../../@loaders.gl/gltf/src/lib/gltf-utils/get-typed-array.ts", "../../@loaders.gl/gltf/src/lib/gltf-utils/gltf-utils.ts", "../../@loaders.gl/gltf/src/lib/api/gltf-scenegraph.ts", "../../@loaders.gl/gltf/src/meshopt/meshopt-decoder.ts", "../../@loaders.gl/gltf/src/lib/extensions/EXT_meshopt_compression.ts", "../../@loaders.gl/gltf/src/lib/extensions/EXT_texture_webp.ts", "../../@loaders.gl/gltf/src/lib/extensions/KHR_texture_basisu.ts", "../../@loaders.gl/draco/src/lib/utils/version.ts", "../../@loaders.gl/draco/src/draco-loader.ts", "../../@loaders.gl/schema/src/lib/batches/base-table-batch-aggregator.ts", "../../@loaders.gl/schema/src/lib/utils/row-utils.ts", "../../@loaders.gl/schema/src/lib/batches/row-table-batch-aggregator.ts", "../../@loaders.gl/schema/src/lib/batches/columnar-table-batch-aggregator.ts", "../../@loaders.gl/schema/src/lib/batches/table-batch-builder.ts", "../../@loaders.gl/schema/src/category/mesh/mesh-utils.ts", "../../@loaders.gl/schema/src/lib/utils/assert.ts", "../../@loaders.gl/schema/src/lib/schema/impl/schema.ts", "../../@loaders.gl/schema/src/lib/schema/impl/field.ts", "../../@loaders.gl/schema/src/lib/schema/impl/enum.ts", "../../@loaders.gl/schema/src/lib/schema/impl/type.ts", "../../@loaders.gl/schema/src/lib/arrow/arrow-like-type-utils.ts", "../../@loaders.gl/schema/src/category/mesh/deduce-mesh-schema.ts", "../../@loaders.gl/schema/src/lib/utils/async-queue.ts", "../../@loaders.gl/draco/src/lib/utils/get-draco-schema.ts", "../../@loaders.gl/draco/src/lib/draco-parser.ts", "../../@loaders.gl/draco/src/lib/draco-module-loader.ts", "../../@loaders.gl/draco/src/index.ts", "../../@loaders.gl/gltf/src/lib/gltf-utils/gltf-attribute-utils.ts", "../../@loaders.gl/gltf/src/lib/extensions/KHR_draco_mesh_compression.ts", "../../@loaders.gl/gltf/src/lib/gltf-utils/gltf-constants.ts", "../../@loaders.gl/gltf/src/lib/extensions/KHR_texture_transform.ts", "../../@loaders.gl/gltf/src/lib/extensions/deprecated/KHR_lights_punctual.ts", "../../@loaders.gl/gltf/src/lib/extensions/deprecated/KHR_materials_unlit.ts", "../../@loaders.gl/gltf/src/lib/extensions/deprecated/KHR_techniques_webgl.ts", "../../@loaders.gl/gltf/src/lib/extensions/deprecated/EXT_feature_metadata.ts", "../../@loaders.gl/gltf/src/lib/api/gltf-extensions.ts", "../../@loaders.gl/gltf/src/lib/extensions/KHR_binary_gltf.ts", "../../@loaders.gl/gltf/src/lib/api/normalize-gltf-v1.ts", "../../@loaders.gl/gltf/src/lib/api/post-process-gltf.ts", "../../@loaders.gl/gltf/src/lib/parsers/parse-glb.ts", "../../@loaders.gl/gltf/src/lib/parsers/parse-gltf.ts", "../../@loaders.gl/gltf/src/gltf-loader.ts", "../../@loaders.gl/gltf/src/lib/encoders/encode-glb.ts", "../../@loaders.gl/gltf/src/lib/encoders/encode-gltf.ts", "../../@loaders.gl/gltf/src/gltf-writer.ts", "../../@loaders.gl/gltf/src/glb-loader.ts", "../../@loaders.gl/gltf/src/glb-writer.ts"],
  "sourcesContent": ["// Version constant cannot be imported, it needs to correspond to the build version of **this** module.\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nexport const VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'latest';\n", "// Version constant cannot be imported, it needs to correspond to the build version of **this** module.\n// __VERSION__ is injected by babel-plugin-version-inline\n// TODO: use 'latest' instead of 'beta' when 3.0.0 version is released as 'latest'\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nexport const VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'beta';\n", "// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nconst VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'beta';\n\n// @ts-nocheck\nimport {loadLibrary} from '@loaders.gl/worker-utils';\n\nconst BASIS_CDN_ENCODER_WASM = `https://unpkg.com/@loaders.gl/textures@${VERSION}/dist/libs/basis_encoder.wasm`;\nconst BASIS_CDN_ENCODER_JS = `https://unpkg.com/@loaders.gl/textures@${VERSION}/dist/libs/basis_encoder.js`;\n\nlet loadBasisTranscoderPromise;\n\n/**\n * Loads wasm transcoder module\n * @param options\n * @returns {BasisFile} promise\n */\nexport async function loadBasisTrascoderModule(options) {\n  const modules = options.modules || {};\n  if (modules.basis) {\n    return modules.basis;\n  }\n\n  loadBasisTranscoderPromise = loadBasisTranscoderPromise || loadBasisTrascoder(options);\n  return await loadBasisTranscoderPromise;\n}\n\n/**\n * Loads wasm transcoder module\n * @param options\n * @returns {BasisFile} promise\n */\nasync function loadBasisTrascoder(options) {\n  let BASIS = null;\n  let wasmBinary = null;\n\n  [BASIS, wasmBinary] = await Promise.all([\n    await loadLibrary('basis_transcoder.js', 'textures', options),\n    await loadLibrary('basis_transcoder.wasm', 'textures', options)\n  ]);\n\n  // Depends on how import happened...\n  // @ts-ignore TS2339: Property does not exist on type\n  BASIS = BASIS || globalThis.BASIS;\n  return await initializeBasisTrascoderModule(BASIS, wasmBinary);\n}\n\n/**\n * Initialize wasm transcoder module\n * @param BasisModule - js part of the module\n * @param wasmBinary - wasm part of the module\n * @returns {BasisFile} promise\n */\nfunction initializeBasisTrascoderModule(BasisModule, wasmBinary) {\n  const options: {wasmBinary?} = {};\n\n  if (wasmBinary) {\n    options.wasmBinary = wasmBinary;\n  }\n\n  return new Promise((resolve) => {\n    // if you try to return BasisModule the browser crashes!\n    BasisModule(options).then((module) => {\n      const {BasisFile, initializeBasis} = module;\n      initializeBasis();\n      resolve({BasisFile});\n    });\n  });\n}\n\nlet loadBasisEncoderPromise;\n\n/**\n * Loads wasm encoder module\n * @param options\n * @returns {BasisFile, KTX2File} promise\n */\nexport async function loadBasisEncoderModule(options) {\n  const modules = options.modules || {};\n  if (modules.basisEncoder) {\n    return modules.basisEncoder;\n  }\n\n  loadBasisEncoderPromise = loadBasisEncoderPromise || loadBasisEncoder(options);\n  return await loadBasisEncoderPromise;\n}\n\n/**\n * Loads wasm encoder module\n * @param options\n * @returns {BasisFile, KTX2File} promise\n */\nasync function loadBasisEncoder(options) {\n  let BASIS_ENCODER = null;\n  let wasmBinary = null;\n\n  [BASIS_ENCODER, wasmBinary] = await Promise.all([\n    await loadLibrary(BASIS_CDN_ENCODER_JS, 'textures', options),\n    await loadLibrary(BASIS_CDN_ENCODER_WASM, 'textures', options)\n  ]);\n\n  // Depends on how import happened...\n  // @ts-ignore TS2339: Property does not exist on type\n  BASIS_ENCODER = BASIS_ENCODER || globalThis.BASIS;\n  return await initializeBasisEncoderModule(BASIS_ENCODER, wasmBinary);\n}\n\n/**\n * Initialize wasm transcoder module\n * @param BasisEncoderModule - js part of the module\n * @param wasmBinary - wasm part of the module\n * @returns {BasisFile, KTX2File} promise\n */\nfunction initializeBasisEncoderModule(BasisEncoderModule, wasmBinary) {\n  const options: {wasmBinary?} = {};\n\n  if (wasmBinary) {\n    options.wasmBinary = wasmBinary;\n  }\n\n  return new Promise((resolve) => {\n    // if you try to return BasisModule the browser crashes!\n    BasisEncoderModule(options).then((module) => {\n      const {BasisFile, KTX2File, initializeBasis, BasisEncoder} = module;\n      initializeBasis();\n      resolve({BasisFile, KTX2File, BasisEncoder});\n    });\n  });\n}\n", "/* eslint-disable camelcase */\nexport const GL_EXTENSIONS_CONSTANTS = {\n  // WEBGL_compressed_texture_s3tc\n\n  COMPRESSED_RGB_S3TC_DXT1_EXT: 0x83f0,\n  COMPRESSED_RGBA_S3TC_DXT1_EXT: 0x83f1,\n  COMPRESSED_RGBA_S3TC_DXT3_EXT: 0x83f2,\n  COMPRESSED_RGBA_S3TC_DXT5_EXT: 0x83f3,\n\n  // WEBGL_compressed_texture_es3\n\n  COMPRESSED_R11_EAC: 0x9270,\n  COMPRESSED_SIGNED_R11_EAC: 0x9271,\n  COMPRESSED_RG11_EAC: 0x9272,\n  COMPRESSED_SIGNED_RG11_EAC: 0x9273,\n  COMPRESSED_RGB8_ETC2: 0x9274,\n  COMPRESSED_RGBA8_ETC2_EAC: 0x9275,\n  COMPRESSED_SRGB8_ETC2: 0x9276,\n  COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: 0x9277,\n  COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: 0x9278,\n  COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: 0x9279,\n\n  // WEBGL_compressed_texture_pvrtc\n\n  COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 0x8c00,\n  COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 0x8c02,\n  COMPRESSED_RGB_PVRTC_2BPPV1_IMG: 0x8c01,\n  COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: 0x8c03,\n\n  // WEBGL_compressed_texture_etc1\n\n  COMPRESSED_RGB_ETC1_WEBGL: 0x8d64,\n\n  // WEBGL_compressed_texture_atc\n\n  COMPRESSED_RGB_ATC_WEBGL: 0x8c92,\n  COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL: 0x8c93,\n  COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL: 0x87ee,\n\n  // WEBGL_compressed_texture_astc\n\n  COMPRESSED_RGBA_ASTC_4X4_KHR: 0x93b0,\n  COMPRESSED_RGBA_ASTC_5X4_KHR: 0x93b1,\n  COMPRESSED_RGBA_ASTC_5X5_KHR: 0x93b2,\n  COMPRESSED_RGBA_ASTC_6X5_KHR: 0x93b3,\n  COMPRESSED_RGBA_ASTC_6X6_KHR: 0x93b4,\n  COMPRESSED_RGBA_ASTC_8X5_KHR: 0x93b5,\n  COMPRESSED_RGBA_ASTC_8X6_KHR: 0x93b6,\n  COMPRESSED_RGBA_ASTC_8X8_KHR: 0x93b7,\n  COMPRESSED_RGBA_ASTC_10X5_KHR: 0x93b8,\n  COMPRESSED_RGBA_ASTC_10X6_KHR: 0x93b9,\n  COMPRESSED_RGBA_ASTC_10X8_KHR: 0x93ba,\n  COMPRESSED_RGBA_ASTC_10X10_KHR: 0x93bb,\n  COMPRESSED_RGBA_ASTC_12X10_KHR: 0x93bc,\n  COMPRESSED_RGBA_ASTC_12X12_KHR: 0x93bd,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_4X4_KHR: 0x93d0,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_5X4_KHR: 0x93d1,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_5X5_KHR: 0x93d2,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_6X5_KHR: 0x93d3,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_6X6_KHR: 0x93d4,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_8X5_KHR: 0x93d5,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_8X6_KHR: 0x93d6,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_8X8_KHR: 0x93d7,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_10X5_KHR: 0x93d8,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_10X6_KHR: 0x93d9,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_10X8_KHR: 0x93da,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_10X10_KHR: 0x93db,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_12X10_KHR: 0x93dc,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_12X12_KHR: 0x93dd,\n\n  // EXT_texture_compression_rgtc\n\n  COMPRESSED_RED_RGTC1_EXT: 0x8dbb,\n  COMPRESSED_SIGNED_RED_RGTC1_EXT: 0x8dbc,\n  COMPRESSED_RED_GREEN_RGTC2_EXT: 0x8dbd,\n  COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT: 0x8dbe,\n\n  // WEBGL_compressed_texture_s3tc_srgb\n\n  COMPRESSED_SRGB_S3TC_DXT1_EXT: 0x8c4c,\n  COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT: 0x8c4d,\n  COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT: 0x8c4e,\n  COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT: 0x8c4f\n};\n", "import type {GPUTextureFormat} from '@loaders.gl/schema';\n\nconst BROWSER_PREFIXES = ['', 'WEBKIT_', 'MOZ_'];\n\nconst WEBGL_EXTENSIONS: {[key: string]: GPUTextureFormat} = {\n  /* eslint-disable camelcase */\n  WEBGL_compressed_texture_s3tc: 'dxt',\n  WEBGL_compressed_texture_s3tc_srgb: 'dxt-srgb',\n  WEBGL_compressed_texture_etc1: 'etc1',\n  WEBGL_compressed_texture_etc: 'etc2',\n  WEBGL_compressed_texture_pvrtc: 'pvrtc',\n  WEBGL_compressed_texture_atc: 'atc',\n  WEBGL_compressed_texture_astc: 'astc',\n  EXT_texture_compression_rgtc: 'rgtc'\n  /* eslint-enable camelcase */\n};\n\nlet formats: Set<GPUTextureFormat> | null = null;\n\n/**\n * Returns a list of formats.\n * Creates a temporary WebGLRenderingContext if none is provided.\n *\n * @param gl - Optional context.\n */\nexport function getSupportedGPUTextureFormats(gl?: WebGLRenderingContext): Set<string> {\n  if (!formats) {\n    gl = gl || getWebGLContext() || undefined;\n\n    formats = new Set<GPUTextureFormat>();\n\n    for (const prefix of BROWSER_PREFIXES) {\n      for (const extension in WEBGL_EXTENSIONS) {\n        if (gl && gl.getExtension(`${prefix}${extension}`)) {\n          const gpuTextureFormat = WEBGL_EXTENSIONS[extension];\n          formats.add(gpuTextureFormat);\n        }\n      }\n    }\n  }\n\n  return formats;\n}\n\n/**\n * @returns {WebGLRenderingContext?}\n */\nfunction getWebGLContext() {\n  try {\n    const canvas = document.createElement('canvas');\n    return canvas.getContext('webgl');\n  } catch (error) {\n    return null;\n  }\n}\n", "///////////////////////////////////////////////////\n// Common.\n///////////////////////////////////////////////////\n\n// Injected at compile time, from $npm_package_version.\ndeclare const PACKAGE_VERSION: string;\n\nexport const KTX_WRITER = `KTX-Parse v${PACKAGE_VERSION}`;\n\nexport const NUL = new Uint8Array([0x00]);\n\n\n///////////////////////////////////////////////////\n// KTX2 Header.\n///////////////////////////////////////////////////\n\nexport const KTX2_ID = [\n\t// '´', 'K', 'T', 'X', '2', '0', 'ª', '\\r', '\\n', '\\x1A', '\\n'\n\t0xAB, 0x4B, 0x54, 0x58, 0x20, 0x32, 0x30, 0xBB, 0x0D, 0x0A, 0x1A, 0x0A\n];\n\nexport const HEADER_BYTE_LENGTH = 68; // 13 * 4 + 2 * 8\n\nexport enum KTX2SupercompressionScheme {\n\tNONE = 0,\n\tBASISLZ = 1,\n\tZSTD = 2,\n\tZLIB = 3,\n};\n\n\n///////////////////////////////////////////////////\n// Data Format Descriptor (DFD).\n///////////////////////////////////////////////////\n\nexport enum KTX2DataFormatType {\n    BASICFORMAT = 0x00,\n};\n\nexport const KHR_DF_VENDORID_KHRONOS = 0;\n\nexport const KHR_DF_VERSION = 2;\n\nexport const KHR_DF_BLOCKSIZE = 40;\n\nexport const VK_FORMAT_UNDEFINED = 0;\n\nexport enum KTX2DataFormatModel {\n    UNSPECIFIED = 0,\n\tETC1S = 163,\n\tUASTC = 166,\n};\n\nexport enum KTX2DataFormatPrimaries {\n    UNSPECIFIED = 0,\n    SRGB = 1,\n};\n\nexport enum KTX2DataFormatTransfer {\n    UNSPECIFIED = 0,\n    LINEAR = 1,\n    SRGB = 2,\n    ITU = 3,\n    NTSC = 4,\n    SLOG = 5,\n    SLOG2 = 6,\n};\n\nexport enum KTX2DataFormatFlags {\n    ALPHA_STRAIGHT = 0,\n    ALPHA_PREMULTIPLIED = 1,\n};\n\nexport enum KTX2DataFormatChannelETC1S {\n    RGB = 0,\n    RRR = 3,\n    GGG = 4,\n    AAA = 15,\n};\n\nexport enum KTX2DataFormatChannelUASTC {\n    RGB = 0,\n    RGBA = 3,\n    RRR = 4,\n    RRRG = 5,\n};\n", "import { KHR_DF_BLOCKSIZE, KHR_DF_VENDORID_KHRONOS, KHR_DF_VERSION, KTX2DataFormatFlags, KTX2DataFormatModel, KTX2DataFormatPrimaries, KTX2DataFormatType, KTX2SupercompressionScheme, VK_FORMAT_UNDEFINED } from './constants';\n\n/**\n * Represents an unpacked KTX 2.0 texture container. Data for individual mip levels are stored in\n * the `.levels` array, typically compressed in Basis Universal formats. Additional properties\n * provide metadata required to process, transcode, and upload these textures.\n */\nexport class KTX2Container {\n\t/**\n\t * Specifies the image format using Vulkan VkFormat enum values. When using Basis Universal\n\t * texture formats, `vkFormat` must be VK_FORMAT_UNDEFINED.\n\t */\n\tpublic vkFormat = VK_FORMAT_UNDEFINED;\n\n\t/**\n\t * Size of the data type in bytes used to upload the data to a graphics API. When `vkFormat` is\n\t * VK_FORMAT_UNDEFINED, `typeSize` must be 1.\n\t */\n\tpublic typeSize: number = 1;\n\n\t/** Width of the texture image for level 0, in pixels. */\n\tpublic pixelWidth: number = 0;\n\n\t/** Height of the texture image for level 0, in pixels. */\n\tpublic pixelHeight: number = 0;\n\n\t/** Depth of the texture image for level 0, in pixels (3D textures only). */\n\tpublic pixelDepth: number = 0;\n\n\t/** Number of array elements (array textures only). */\n\tpublic layerCount: number = 0;\n\n\t/**\n\t * Number of cubemap faces. For cubemaps and cubemap arrays, `faceCount` must be 6. For all\n\t * other textures, `faceCount` must be 1. Cubemap faces are stored in +X, -X, +Y, -Y, +Z, -Z\n\t * order.\n\t */\n\tpublic faceCount: number = 1;\n\n\t/** Indicates which supercompression scheme has been applied to mip level images, if any. */\n\tpublic supercompressionScheme = KTX2SupercompressionScheme.NONE;\n\n\t/** Mip levels, ordered largest (original) to smallest (~1px). */\n\tpublic levels: KTX2Level[] = [];\n\n\t/** Data Format Descriptor. */\n\tpublic dataFormatDescriptor: KTX2DataFormatDescriptorBasicFormat[] = [{\n\t\tvendorId: KHR_DF_VENDORID_KHRONOS,\n\t\tdescriptorType: KTX2DataFormatType.BASICFORMAT,\n\t\tversionNumber: KHR_DF_VERSION,\n\t\tdescriptorBlockSize: KHR_DF_BLOCKSIZE,\n\t\tcolorModel: KTX2DataFormatModel.UNSPECIFIED,\n\t\tcolorPrimaries: KTX2DataFormatPrimaries.SRGB,\n\t\ttransferFunction: KTX2DataFormatPrimaries.SRGB,\n\t\tflags: KTX2DataFormatFlags.ALPHA_STRAIGHT,\n\t\ttexelBlockDimension: {x: 4, y: 4, z: 1, w: 1},\n\t\tbytesPlane: [],\n\t\tsamples: [],\n\t}];\n\n\t/** Key/Value Data. */\n\tpublic keyValue: {[key: string]: string | Uint8Array} = {};\n\n\t/** Supercompression Global Data. */\n\tpublic globalData: KTX2GlobalDataBasisLZ | null = null;\n}\n\n\n///////////////////////////////////////////////////\n// Mip Levels.\n///////////////////////////////////////////////////\n\nexport interface KTX2Level {\n\t/** Compressed data of the mip level. */\n\tlevelData: Uint8Array;\n\n\t/**\n\t * Size of the mip level after reflation from supercompression, if applicable. When\n\t * `supercompressionType` is BASISLZ, `uncompressedByteLength` must be 0. When\n\t * `supercompressionType` is `NONE`, `uncompressedByteLength` must match the `levelData` byte\n\t * length.\n\t *\n\t * _**NOTICE:** this implies that for formats such as UASTC, `uncompressedByteLength` may\n\t * indicate size after ZSTD reflation (and of transcoded ASTC data), but does _not_ indicate\n\t * size of decoded RGBA32 pixels._\n\t */\n\tuncompressedByteLength: number;\n};\n\n\n///////////////////////////////////////////////////\n// Data Format Descriptor (DFD).\n///////////////////////////////////////////////////\n\nexport interface KTX2DataFormatDescriptorBasicFormat {\n\tvendorId: number;\n\tdescriptorType: number;\n\tversionNumber: number;\n\tdescriptorBlockSize: number;\n\tcolorModel: number;\n\tcolorPrimaries: number;\n\ttransferFunction: number;\n\tflags: number;\n\ttexelBlockDimension: KTX2BasicFormatTexelBlockDimensions;\n\tbytesPlane: number[];\n\tsamples: KTX2BasicFormatSample[],\n};\n\nexport interface KTX2BasicFormatTexelBlockDimensions {\n\tx: number;\n\ty: number;\n\tz: number;\n\tw: number;\n};\n\nexport interface KTX2BasicFormatSample {\n\tbitOffset: number;\n\tbitLength: number;\n\tchannelID: number;\n\tsamplePosition: number[];\n\tsampleLower: number;\n\tsampleUpper: number;\n};\n\n\n///////////////////////////////////////////////////\n// Supercompression Global Data.\n///////////////////////////////////////////////////\n\nexport interface KTX2GlobalDataBasisLZ {\n\tendpointCount: number;\n\tselectorCount: number;\n\timageDescs: KTX2GlobalDataBasisLZImageDesc[];\n\tendpointsData: Uint8Array;\n\tselectorsData: Uint8Array;\n\ttablesData: Uint8Array;\n\textendedData: Uint8Array;\n};\n\ninterface KTX2GlobalDataBasisLZImageDesc {\n\timageFlags: number;\n\trgbSliceByteOffset: number;\n\trgbSliceByteLength: number;\n\talphaSliceByteOffset: number;\n\talphaSliceByteLength: number;\n};\n", "export class BufferReader {\n\tprivate _dataView: DataView;\n\tprivate _littleEndian: boolean;\n\tpublic _offset: number;\n\n\tconstructor(data: Uint8Array, byteOffset: number, byteLength: number, littleEndian: boolean) {\n\t\tthis._dataView = new DataView(data.buffer, data.byteOffset + byteOffset, byteLength);\n\t\tthis._littleEndian = littleEndian;\n\t\tthis._offset = 0;\n\t}\n\n\t_nextUint8() {\n\t\tconst value = this._dataView.getUint8(this._offset);\n\t\tthis._offset += 1;\n\t\treturn value;\n\t}\n\n\t_nextUint16() {\n\t\tconst value = this._dataView.getUint16(this._offset, this._littleEndian);\n\t\tthis._offset += 2;\n\t\treturn value;\n\t}\n\n\t_nextUint32() {\n\t\tconst value = this._dataView.getUint32(this._offset, this._littleEndian);\n\t\tthis._offset += 4;\n\t\treturn value;\n\t}\n\n\t_nextUint64() {\n\t\tconst left = this._dataView.getUint32(this._offset, this._littleEndian);\n\t\tconst right = this._dataView.getUint32(this._offset + 4, this._littleEndian);\n\t\t// TODO(cleanup): Just test this...\n\t\t// const value = this._littleEndian ? left + (2 ** 32 * right) : (2 ** 32 * left) + right;\n\t\tconst value = left + (2 ** 32 * right);\n\t\tthis._offset += 8;\n\t\treturn value;\n\t}\n\n\t_skip(bytes: number) {\n\t\tthis._offset += bytes;\n\t\treturn this;\n\t}\n\n\t_scan(maxByteLength: number, term: number = 0x00): Uint8Array {\n\t\tconst byteOffset = this._offset;\n\t\tlet byteLength = 0;\n\t\twhile (this._dataView.getUint8(this._offset) !== term && byteLength < maxByteLength) {\n\t\t\tbyteLength++;\n\t\t\tthis._offset++;\n\t\t}\n\n\t\tif (byteLength < maxByteLength) this._offset++;\n\n\t\treturn new Uint8Array(\n\t\t\tthis._dataView.buffer,\n\t\t\tthis._dataView.byteOffset + byteOffset,\n\t\t\tbyteLength\n\t\t);\n\t}\n}\n", "\n/** Encodes text to an ArrayBuffer. */\nexport function encodeText(text: string): Uint8Array {\n\tif (typeof TextEncoder !== 'undefined') {\n\t\treturn new TextEncoder().encode(text);\n\t}\n\treturn Buffer.from(text);\n}\n\n/** Decodes an ArrayBuffer to text. */\nexport function decodeText(buffer: Uint8Array): string {\n\tif (typeof TextDecoder !== 'undefined') {\n\t\treturn new TextDecoder().decode(buffer);\n\t}\n\treturn Buffer.from(buffer).toString('utf8');\n}\n\n/** Concatenates N ArrayBuffers. */\nexport function concat (buffers: (ArrayBuffer | Uint8Array)[]): Uint8Array {\n\tlet totalByteLength = 0;\n\tfor (const buffer of buffers) {\n\t\ttotalByteLength += buffer.byteLength;\n\t}\n\n\tconst result = new Uint8Array(totalByteLength);\n\tlet byteOffset = 0;\n\n\tfor (const buffer of buffers) {\n\t\tresult.set(new Uint8Array(buffer), byteOffset);\n\t\tbyteOffset += buffer.byteLength;\n\t}\n\n\treturn result;\n}", "import { BufferReader } from './buffer-reader';\nimport { KTX2_ID } from './constants';\nimport { KTX2Container, KTX2DataFormatDescriptorBasicFormat } from './container';\nimport { decodeText } from './util';\n\n/**\n * Parses a KTX 2.0 file, returning an unpacked {@link KTX2Container} instance with all associated\n * data. The container's mip levels and other binary data are pointers into the original file, not\n * copies, so the original file should not be overwritten after reading.\n *\n * @param data Bytes of KTX 2.0 file, as Uint8Array or Buffer.\n */\nexport function read(data: Uint8Array): KTX2Container {\n\n\t///////////////////////////////////////////////////\n\t// KTX 2.0 Identifier.\n\t///////////////////////////////////////////////////\n\n\tconst id = new Uint8Array(data.buffer, data.byteOffset, KTX2_ID.length);\n\tif (id[0] !== KTX2_ID[0] || // '´'\n\t\tid[1] !== KTX2_ID[1] || // 'K'\n\t\tid[2] !== KTX2_ID[2] || // 'T'\n\t\tid[3] !== KTX2_ID[3] || // 'X'\n\t\tid[4] !== KTX2_ID[4] || // ' '\n\t\tid[5] !== KTX2_ID[5] || // '2'\n\t\tid[6] !== KTX2_ID[6] || // '0'\n\t\tid[7] !== KTX2_ID[7] || // 'ª'\n\t\tid[8] !== KTX2_ID[8] || // '\\r'\n\t\tid[9] !== KTX2_ID[9] || // '\\n'\n\t\tid[10] !== KTX2_ID[10] || // '\\x1A'\n\t\tid[11] !== KTX2_ID[11] // '\\n'\n\t) {\n\t\tthrow new Error('Missing KTX 2.0 identifier.');\n\t}\n\n\tconst container = new KTX2Container();\n\n\t///////////////////////////////////////////////////\n\t// Header.\n\t///////////////////////////////////////////////////\n\n\tconst headerByteLength = 17 * Uint32Array.BYTES_PER_ELEMENT;\n\tconst headerReader = new BufferReader(data, KTX2_ID.length, headerByteLength, true);\n\n\tcontainer.vkFormat = headerReader._nextUint32();\n\tcontainer.typeSize = headerReader._nextUint32();\n\tcontainer.pixelWidth = headerReader._nextUint32();\n\tcontainer.pixelHeight = headerReader._nextUint32();\n\tcontainer.pixelDepth = headerReader._nextUint32();\n\tcontainer.layerCount = headerReader._nextUint32();\n\tcontainer.faceCount = headerReader._nextUint32();\n\n\tconst levelCount = headerReader._nextUint32();\n\n\tcontainer.supercompressionScheme = headerReader._nextUint32();\n\n\tconst dfdByteOffset = headerReader._nextUint32();\n\tconst dfdByteLength = headerReader._nextUint32();\n\tconst kvdByteOffset = headerReader._nextUint32();\n\tconst kvdByteLength = headerReader._nextUint32();\n\tconst sgdByteOffset = headerReader._nextUint64();\n\tconst sgdByteLength = headerReader._nextUint64();\n\n\t///////////////////////////////////////////////////\n\t// Level Index.\n\t///////////////////////////////////////////////////\n\n\tconst levelByteLength = levelCount * 3 * 8;\n\tconst levelReader = new BufferReader(data, KTX2_ID.length + headerByteLength, levelByteLength, true);\n\n\tfor (let i = 0; i < levelCount; i ++) {\n\t\tcontainer.levels.push({\n\t\t\tlevelData: new Uint8Array(data.buffer, data.byteOffset + levelReader._nextUint64(), levelReader._nextUint64()),\n\t\t\tuncompressedByteLength: levelReader._nextUint64(),\n\t\t});\n\t}\n\n\n\t///////////////////////////////////////////////////\n\t// Data Format Descriptor (DFD).\n\t///////////////////////////////////////////////////\n\n\tconst dfdReader = new BufferReader(data, dfdByteOffset, dfdByteLength, true);\n\n\tconst dfd: KTX2DataFormatDescriptorBasicFormat = {\n\t\tvendorId: dfdReader._skip(4 /* totalSize */)._nextUint16(),\n\t\tdescriptorType: dfdReader._nextUint16(),\n\t\tversionNumber: dfdReader._nextUint16(),\n\t\tdescriptorBlockSize: dfdReader._nextUint16(),\n\t\tcolorModel: dfdReader._nextUint8(),\n\t\tcolorPrimaries: dfdReader._nextUint8(),\n\t\ttransferFunction: dfdReader._nextUint8(),\n\t\tflags: dfdReader._nextUint8(),\n\t\ttexelBlockDimension: {\n\t\t\tx: dfdReader._nextUint8() + 1,\n\t\t\ty: dfdReader._nextUint8() + 1,\n\t\t\tz: dfdReader._nextUint8() + 1,\n\t\t\tw: dfdReader._nextUint8() + 1,\n\t\t},\n\t\tbytesPlane: [\n\t\t\tdfdReader._nextUint8(),\n\t\t\tdfdReader._nextUint8(),\n\t\t\tdfdReader._nextUint8(),\n\t\t\tdfdReader._nextUint8(),\n\t\t\tdfdReader._nextUint8(),\n\t\t\tdfdReader._nextUint8(),\n\t\t\tdfdReader._nextUint8(),\n\t\t\tdfdReader._nextUint8(),\n\t\t],\n\t\tsamples: [],\n\t};\n\n\tconst sampleStart = 6;\n\tconst sampleWords = 4;\n\tconst numSamples = (dfd.descriptorBlockSize / 4 - sampleStart) / sampleWords;\n\n\tfor (let i = 0; i < numSamples; i ++) {\n\t\tdfd.samples[ i ] = {\n\t\t\tbitOffset: dfdReader._nextUint16(),\n\t\t\tbitLength: dfdReader._nextUint8(),\n\t\t\tchannelID: dfdReader._nextUint8(),\n\t\t\tsamplePosition: [\n\t\t\t\tdfdReader._nextUint8(),\n\t\t\t\tdfdReader._nextUint8(),\n\t\t\t\tdfdReader._nextUint8(),\n\t\t\t\tdfdReader._nextUint8(),\n\t\t\t],\n\t\t\tsampleLower: dfdReader._nextUint32(),\n\t\t\tsampleUpper: dfdReader._nextUint32(),\n\t\t};\n\t}\n\n\tcontainer.dataFormatDescriptor.length = 0;\n\tcontainer.dataFormatDescriptor.push(dfd);\n\n\n\t///////////////////////////////////////////////////\n\t// Key/Value Data (KVD).\n\t///////////////////////////////////////////////////\n\n\tconst kvdReader = new BufferReader(data, kvdByteOffset, kvdByteLength, true);\n\n\twhile (kvdReader._offset < kvdByteLength) {\n\t\tconst keyValueByteLength = kvdReader._nextUint32();\n\t\tconst keyData = kvdReader._scan(keyValueByteLength);\n\t\tconst key = decodeText(keyData);\n\t\tconst valueData = kvdReader._scan(keyValueByteLength - keyData.byteLength);\n\t\tcontainer.keyValue[key] = key.match(/^ktx/i) ? decodeText(valueData) : valueData;\n\n\t\t// 4-byte alignment.\n\t\tif (keyValueByteLength % 4) kvdReader._skip(4 - (keyValueByteLength % 4));\n\t}\n\n\n\t///////////////////////////////////////////////////\n\t// Supercompression Global Data (SGD).\n\t///////////////////////////////////////////////////\n\n\tif (sgdByteLength <= 0) return container;\n\n\tconst sgdReader = new BufferReader(data, sgdByteOffset, sgdByteLength, true);\n\n\tconst endpointCount = sgdReader._nextUint16();\n\tconst selectorCount = sgdReader._nextUint16();\n\tconst endpointsByteLength = sgdReader._nextUint32();\n\tconst selectorsByteLength = sgdReader._nextUint32();\n\tconst tablesByteLength = sgdReader._nextUint32();\n\tconst extendedByteLength = sgdReader._nextUint32();\n\n\tconst imageDescs = [];\n\tfor (let i = 0; i < levelCount; i ++) {\n\t\timageDescs.push({\n\t\t\timageFlags: sgdReader._nextUint32(),\n\t\t\trgbSliceByteOffset: sgdReader._nextUint32(),\n\t\t\trgbSliceByteLength: sgdReader._nextUint32(),\n\t\t\talphaSliceByteOffset: sgdReader._nextUint32(),\n\t\t\talphaSliceByteLength: sgdReader._nextUint32(),\n\t\t});\n\t}\n\n\tconst endpointsByteOffset = sgdByteOffset + sgdReader._offset;\n\tconst selectorsByteOffset = endpointsByteOffset + endpointsByteLength;\n\tconst tablesByteOffset = selectorsByteOffset + selectorsByteLength;\n\tconst extendedByteOffset = tablesByteOffset + tablesByteLength;\n\n\tconst endpointsData = new Uint8Array(data.buffer, data.byteOffset + endpointsByteOffset, endpointsByteLength);\n\tconst selectorsData = new Uint8Array(data.buffer, data.byteOffset + selectorsByteOffset, selectorsByteLength);\n\tconst tablesData = new Uint8Array(data.buffer, data.byteOffset + tablesByteOffset, tablesByteLength);\n\tconst extendedData = new Uint8Array(data.buffer, data.byteOffset + extendedByteOffset, extendedByteLength);\n\n\tcontainer.globalData = {\n\t\tendpointCount,\n\t\tselectorCount,\n\t\timageDescs,\n\t\tendpointsData,\n\t\tselectorsData,\n\t\ttablesData,\n\t\textendedData,\n\t};\n\n\treturn container;\n}\n", "import { HEADER_BYTE_LENGTH, KTX2DataFormatType, KTX2_ID, KTX_WRITER, NUL } from './constants';\nimport { KTX2Container } from './container';\nimport { concat, encodeText } from './util';\n\ninterface WriteOptions {keepWriter?: boolean};\nconst DEFAULT_OPTIONS: WriteOptions = {keepWriter: false};\n\n/**\n * Serializes a {@link KTX2Container} instance to a KTX 2.0 file. Mip levels and other binary data\n * are copied into the resulting Uint8Array, so the original container can safely be edited or\n * destroyed after it is serialized.\n *\n * Options:\n * - keepWriter: If true, 'KTXWriter' key/value field is written as provided by the container.\n * \t\tOtherwise, a string for the current ktx-parse version is generated. Default: false.\n *\n * @param container\n * @param options\n */\nexport function write(container: KTX2Container, options: WriteOptions = {}): Uint8Array {\n\toptions = {...DEFAULT_OPTIONS, ...options};\n\n\t///////////////////////////////////////////////////\n\t// Supercompression Global Data (SGD).\n\t///////////////////////////////////////////////////\n\n\tlet sgdBuffer = new ArrayBuffer(0);\n\tif (container.globalData) {\n\t\tconst sgdHeaderBuffer = new ArrayBuffer(20 + container.globalData.imageDescs.length * 5 * 4);\n\t\tconst sgdHeaderView = new DataView(sgdHeaderBuffer);\n\t\tsgdHeaderView.setUint16(0, container.globalData.endpointCount, true);\n\t\tsgdHeaderView.setUint16(2, container.globalData.selectorCount, true);\n\t\tsgdHeaderView.setUint32(4, container.globalData.endpointsData.byteLength, true);\n\t\tsgdHeaderView.setUint32(8, container.globalData.selectorsData.byteLength, true);\n\t\tsgdHeaderView.setUint32(12, container.globalData.tablesData.byteLength, true);\n\t\tsgdHeaderView.setUint32(16, container.globalData.extendedData.byteLength, true);\n\n\t\tfor (let i = 0; i < container.globalData.imageDescs.length; i++) {\n\t\t\tconst imageDesc = container.globalData.imageDescs[i];\n\t\t\tsgdHeaderView.setUint32(20 + i * 5 * 4 + 0, imageDesc.imageFlags, true);\n\t\t\tsgdHeaderView.setUint32(20 + i * 5 * 4 + 4, imageDesc.rgbSliceByteOffset, true);\n\t\t\tsgdHeaderView.setUint32(20 + i * 5 * 4 + 8, imageDesc.rgbSliceByteLength, true);\n\t\t\tsgdHeaderView.setUint32(20 + i * 5 * 4 + 12, imageDesc.alphaSliceByteOffset, true);\n\t\t\tsgdHeaderView.setUint32(20 + i * 5 * 4 + 16, imageDesc.alphaSliceByteLength, true);\n\t\t}\n\n\t\tsgdBuffer = concat([\n\t\t\tsgdHeaderBuffer,\n\t\t\tcontainer.globalData.endpointsData,\n\t\t\tcontainer.globalData.selectorsData,\n\t\t\tcontainer.globalData.tablesData,\n\t\t\tcontainer.globalData.extendedData,\n\t\t]);\n\t}\n\n\n\t///////////////////////////////////////////////////\n\t// Key/Value Data (KVD).\n\t///////////////////////////////////////////////////\n\n\tconst keyValueData: Uint8Array[] = [];\n\tlet keyValue = container.keyValue;\n\n\tif (!options.keepWriter) {\n\t\tkeyValue = {...container.keyValue, 'KTXwriter': KTX_WRITER};\n\t}\n\n\tfor (const key in keyValue) {\n\t\tconst value = keyValue[key];\n\t\tconst keyData = encodeText(key);\n\t\tconst valueData = typeof value === 'string' ? encodeText(value) : value;\n\t\tconst kvByteLength = keyData.byteLength + 1 + valueData.byteLength + 1;\n\t\tconst kvPadding = kvByteLength % 4 ? (4 - (kvByteLength % 4)) : 0; // align(4)\n\t\tkeyValueData.push(concat([\n\t\t\tnew Uint32Array([kvByteLength]),\n\t\t\tkeyData,\n\t\t\tNUL,\n\t\t\tvalueData,\n\t\t\tNUL,\n\t\t\tnew Uint8Array(kvPadding).fill(0x00), // align(4)\n\t\t]));\n\t}\n\n\tconst kvdBuffer = concat(keyValueData);\n\n\n\t///////////////////////////////////////////////////\n\t// Data Format Descriptor (DFD).\n\t///////////////////////////////////////////////////\n\n\tconst dfdBuffer = new ArrayBuffer(44);\n\tconst dfdView = new DataView(dfdBuffer);\n\n\tif (container.dataFormatDescriptor.length !== 1\n\t\t\t|| container.dataFormatDescriptor[0].descriptorType !== KTX2DataFormatType.BASICFORMAT) {\n\t\tthrow new Error('Only BASICFORMAT Data Format Descriptor output supported.');\n\t}\n\n\tconst dfd = container.dataFormatDescriptor[0];\n\n\tdfdView.setUint32(0, 44, true);\n\tdfdView.setUint16(4, dfd.vendorId, true);\n\tdfdView.setUint16(6, dfd.descriptorType, true);\n\tdfdView.setUint16(8, dfd.versionNumber, true);\n\tdfdView.setUint16(10, dfd.descriptorBlockSize, true);\n\n\tdfdView.setUint8(12, dfd.colorModel);\n\tdfdView.setUint8(13, dfd.colorPrimaries);\n\tdfdView.setUint8(14, dfd.transferFunction);\n\tdfdView.setUint8(15, dfd.flags);\n\n\tdfdView.setUint8(16, dfd.texelBlockDimension.x - 1);\n\tdfdView.setUint8(17, dfd.texelBlockDimension.y - 1);\n\tdfdView.setUint8(18, dfd.texelBlockDimension.z - 1);\n\tdfdView.setUint8(19, dfd.texelBlockDimension.w - 1);\n\n\tfor (let i = 0; i < 8; i++) dfdView.setUint8(20 + i, dfd.bytesPlane[i]);\n\n\tfor (let i = 0; i < dfd.samples.length; i++) {\n\t\tconst sample = dfd.samples[i];\n\t\tconst sampleByteOffset = 28 + i * 16;\n\n\t\tdfdView.setUint16(sampleByteOffset + 0, sample.bitOffset, true);\n\t\tdfdView.setUint8(sampleByteOffset + 2, sample.bitLength);\n\t\tdfdView.setUint8(sampleByteOffset + 3, sample.channelID);\n\n\t\tdfdView.setUint8(sampleByteOffset + 4, sample.samplePosition[0]);\n\t\tdfdView.setUint8(sampleByteOffset + 5, sample.samplePosition[1]);\n\t\tdfdView.setUint8(sampleByteOffset + 6, sample.samplePosition[2]);\n\t\tdfdView.setUint8(sampleByteOffset + 7, sample.samplePosition[3]);\n\n\t\tdfdView.setUint32(sampleByteOffset + 8, sample.sampleLower, true);\n\t\tdfdView.setUint32(sampleByteOffset + 12, sample.sampleUpper, true);\n\t}\n\n\n\t///////////////////////////////////////////////////\n\t// Data alignment.\n\t///////////////////////////////////////////////////\n\n\tconst dfdByteOffset = KTX2_ID.length + HEADER_BYTE_LENGTH + container.levels.length * 3 * 8;\n\tconst kvdByteOffset = dfdByteOffset + dfdBuffer.byteLength;\n\tlet sgdByteOffset = kvdByteOffset + kvdBuffer.byteLength;\n\tif (sgdByteOffset % 8) sgdByteOffset += 8 - (sgdByteOffset % 8); // align(8)\n\n\n\t///////////////////////////////////////////////////\n\t// Level Index.\n\t///////////////////////////////////////////////////\n\n\tconst levelData: Uint8Array[] = [];\n\tconst levelIndex = new DataView(new ArrayBuffer(container.levels.length * 3 * 8));\n\n\tlet levelDataByteOffset = sgdByteOffset + sgdBuffer.byteLength;\n\tfor (let i = 0; i < container.levels.length; i++) {\n\t\tconst level = container.levels[i];\n\t\tlevelData.push(level.levelData);\n\t\tlevelIndex.setBigUint64(i * 24 + 0, BigInt(levelDataByteOffset), true);\n\t\tlevelIndex.setBigUint64(i * 24 + 8, BigInt(level.levelData.byteLength), true);\n\t\tlevelIndex.setBigUint64(i * 24 + 16, BigInt(level.uncompressedByteLength), true);\n\t\tlevelDataByteOffset += level.levelData.byteLength;\n\t}\n\n\n\t///////////////////////////////////////////////////\n\t// Header.\n\t///////////////////////////////////////////////////\n\n\tconst headerBuffer = new ArrayBuffer(HEADER_BYTE_LENGTH);\n\tconst headerView = new DataView(headerBuffer);\n\theaderView.setUint32(0, container.vkFormat, true);\n\theaderView.setUint32(4, container.typeSize, true);\n\theaderView.setUint32(8, container.pixelWidth, true);\n\theaderView.setUint32(12, container.pixelHeight, true);\n\theaderView.setUint32(16, container.pixelDepth, true);\n\theaderView.setUint32(20, container.layerCount, true);\n\theaderView.setUint32(24, container.faceCount, true);\n\theaderView.setUint32(28, container.levels.length, true);\n\theaderView.setUint32(32, container.supercompressionScheme, true);\n\n\theaderView.setUint32(36, dfdByteOffset, true);\n\theaderView.setUint32(40, dfdBuffer.byteLength, true);\n\theaderView.setUint32(44, kvdByteOffset, true);\n\theaderView.setUint32(48, kvdBuffer.byteLength, true);\n\theaderView.setBigUint64(52, BigInt(sgdByteOffset), true);\n\theaderView.setBigUint64(60, BigInt(sgdBuffer.byteLength), true);\n\n\n\t///////////////////////////////////////////////////\n\t// Compose.\n\t///////////////////////////////////////////////////\n\n\treturn new Uint8Array(concat([\n\t\tnew Uint8Array(KTX2_ID).buffer,\n\t\theaderBuffer,\n\t\tlevelIndex.buffer,\n\t\tdfdBuffer,\n\t\tkvdBuffer,\n\t\tnew ArrayBuffer(sgdByteOffset - (kvdByteOffset + kvdBuffer.byteLength)), // align(8)\n\t\tsgdBuffer,\n\t\t...levelData,\n\t]));\n}\n\n", "import type {TextureLevel} from '@loaders.gl/schema';\n\nexport type CompressedTextureExtractOptions = {\n  mipMapLevels: number;\n  width: number;\n  height: number;\n  sizeFunction: Function;\n  internalFormat: number;\n};\n\n/**\n * Extract mipmap images from compressed texture buffer\n * @param data - binary data of compressed texture or Array of level objects\n * @param options.mipMapLevels - number of mipmap level inside image\n * @param options.width - width of 0 - level\n * @param options.height - height of 0 - level\n * @param options.sizeFunction - format-related function to calculate level size in bytes\n * @param options.internalFormat - WebGL compatible format code\n * @returns Array of the texture levels\n */\nexport function extractMipmapImages(\n  data: Uint8Array | object[],\n  options: CompressedTextureExtractOptions\n): TextureLevel[] {\n  const images = new Array(options.mipMapLevels);\n\n  let levelWidth = options.width;\n  let levelHeight = options.height;\n  let offset = 0;\n\n  for (let i = 0; i < options.mipMapLevels; ++i) {\n    // @ts-expect-error\n    const levelSize = getLevelSize(options, levelWidth, levelHeight, data, i);\n    // @ts-expect-error\n    const levelData = getLevelData(data, i, offset, levelSize);\n\n    images[i] = {\n      compressed: true,\n      format: options.internalFormat,\n      data: levelData,\n      width: levelWidth,\n      height: levelHeight,\n      levelSize\n    };\n\n    levelWidth = Math.max(1, levelWidth >> 1);\n    levelHeight = Math.max(1, levelHeight >> 1);\n\n    offset += levelSize;\n  }\n  return images;\n}\n\nfunction getLevelData(\n  data: Uint8Array,\n  index: number,\n  offset: number,\n  levelSize: number\n): Uint8Array {\n  if (!Array.isArray(data)) {\n    return new Uint8Array(data.buffer, data.byteOffset + offset, levelSize);\n  }\n\n  return data[index].levelData;\n}\n\nfunction getLevelSize(\n  options: CompressedTextureExtractOptions,\n  levelWidth: number,\n  levelHeight: number,\n  data: Uint8Array[] | object[],\n  index: number\n): number {\n  if (!Array.isArray(data)) {\n    return options.sizeFunction(levelWidth, levelHeight);\n  }\n  return options.sizeFunction(data[index]);\n}\n", "import {GL_EXTENSIONS_CONSTANTS} from '../gl-extensions';\n\nconst VULKAN_TO_WEBGL_FORMAT_MAP: Record<number, number> = {\n  131: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_S3TC_DXT1_EXT,\n  132: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB_S3TC_DXT1_EXT,\n  133: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT1_EXT,\n  134: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,\n  135: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT3_EXT,\n  136: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,\n  137: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT5_EXT,\n  138: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT,\n  139: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RED_RGTC1_EXT,\n  140: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SIGNED_RED_RGTC1_EXT,\n  141: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RED_GREEN_RGTC2_EXT,\n  142: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT,\n  147: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB8_ETC2,\n  148: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ETC2,\n  149: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2,\n  150: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2,\n  151: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA8_ETC2_EAC,\n  152: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC,\n  153: GL_EXTENSIONS_CONSTANTS.COMPRESSED_R11_EAC,\n  154: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SIGNED_R11_EAC,\n  155: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RG11_EAC,\n  156: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SIGNED_RG11_EAC,\n  // @ts-ignore\n  157: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_4x4_KHR,\n  // @ts-ignore\n  158: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR,\n  // @ts-ignore\n  159: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_5x4_KHR,\n  // @ts-ignore\n  160: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_5X4_KHR,\n  // @ts-ignore\n  161: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_5x5_KHR,\n  // @ts-ignore\n  162: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR,\n  // @ts-ignore\n  163: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_6x5_KHR,\n  // @ts-ignore\n  164: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR,\n  // @ts-ignore\n  165: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_6x6_KHR,\n  // @ts-ignore\n  166: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR,\n  // @ts-ignore\n  167: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8x5_KHR,\n  // @ts-ignore\n  168: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR,\n  // @ts-ignore\n  169: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8x6_KHR,\n  // @ts-ignore\n  170: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR,\n  // @ts-ignore\n  171: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8x8_KHR,\n  // @ts-ignore\n  172: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR,\n  // @ts-ignore\n  173: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10x5_KHR,\n  // @ts-ignore\n  174: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR,\n  // @ts-ignore\n  175: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10x6_KHR,\n  // @ts-ignore\n  176: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR,\n  // @ts-ignore\n  177: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10x8_KHR,\n  // @ts-ignore\n  178: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR,\n  // @ts-ignore\n  179: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10x10_KHR,\n  // @ts-ignore\n  180: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR,\n  // @ts-ignore\n  181: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_12x10_KHR,\n  // @ts-ignore\n  182: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR,\n  // @ts-ignore\n  183: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_12x12_KHR,\n  // @ts-ignore\n  184: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR,\n  1000054000: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG,\n  1000054001: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG,\n  // @ts-ignore\n  1000066000: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_4x4_KHR,\n  // @ts-ignore\n  1000066001: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_5x4_KHR,\n  // @ts-ignore\n  1000066002: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_5x5_KHR,\n  // @ts-ignore\n  1000066003: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_6x5_KHR,\n  // @ts-ignore\n  1000066004: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_6x6_KHR,\n  // @ts-ignore\n  1000066005: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8x5_KHR,\n  // @ts-ignore\n  1000066006: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8x6_KHR,\n  // @ts-ignore\n  1000066007: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8x8_KHR,\n  // @ts-ignore\n  1000066008: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10x5_KHR,\n  // @ts-ignore\n  1000066009: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10x6_KHR,\n  // @ts-ignore\n  1000066010: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10x8_KHR,\n  // @ts-ignore\n  1000066011: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10x10_KHR,\n  // @ts-ignore\n  1000066012: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_12x10_KHR,\n  // @ts-ignore\n  1000066013: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_12x12_KHR\n};\n\n/**\n * Returns WebGl format based on Vulkan format\n * Vulkan to WebGl format mapping provided here http://github.khronos.org/KTX-Specification/#formatMapping\n * Vulkan name to format number mapping provided here: https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkFormat.html\n * @param vkFormat\n * @returns WebGL / OpenGL constant\n */\nexport function mapVkFormatToWebGL(vkFormat: number): number {\n  return VULKAN_TO_WEBGL_FORMAT_MAP[vkFormat];\n}\n", "import type {TextureLevel} from '@loaders.gl/schema';\nimport {read} from 'ktx-parse';\nimport {extractMipmapImages} from '../utils/extract-mipmap-images';\nimport {mapVkFormatToWebGL} from '../utils/ktx-format-helper';\n\nconst KTX2_ID = [\n  // '´', 'K', 'T', 'X', '2', '0', 'ª', '\\r', '\\n', '\\x1A', '\\n'\n  0xab, 0x4b, 0x54, 0x58, 0x20, 0x32, 0x30, 0xbb, 0x0d, 0x0a, 0x1a, 0x0a\n];\n\n// eslint-disable-next-line complexity\nexport function isKTX(data: ArrayBuffer) {\n  // const id = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n  const id = new Uint8Array(data);\n  const notKTX =\n    id.byteLength < KTX2_ID.length ||\n    id[0] !== KTX2_ID[0] || // '´'\n    id[1] !== KTX2_ID[1] || // 'K'\n    id[2] !== KTX2_ID[2] || // 'T'\n    id[3] !== KTX2_ID[3] || // 'X'\n    id[4] !== KTX2_ID[4] || // ' '\n    id[5] !== KTX2_ID[5] || // '2'\n    id[6] !== KTX2_ID[6] || // '0'\n    id[7] !== KTX2_ID[7] || // 'ª'\n    id[8] !== KTX2_ID[8] || // '\\r'\n    id[9] !== KTX2_ID[9] || // '\\n'\n    id[10] !== KTX2_ID[10] || // '\\x1A'\n    id[11] !== KTX2_ID[11]; // '\\n'\n\n  return !notKTX;\n}\n\nexport function parseKTX(arrayBuffer: ArrayBuffer): TextureLevel[] {\n  const uint8Array = new Uint8Array(arrayBuffer);\n  const ktx = read(uint8Array);\n  const mipMapLevels = Math.max(1, ktx.levels.length);\n  const width = ktx.pixelWidth;\n  const height = ktx.pixelHeight;\n  const internalFormat = mapVkFormatToWebGL(ktx.vkFormat);\n\n  return extractMipmapImages(ktx.levels, {\n    mipMapLevels,\n    width,\n    height,\n    sizeFunction: (level: any): number => level.uncompressedByteLength,\n    internalFormat\n  });\n}\n", "/* eslint-disable indent */\nimport type {TextureLevel} from '@loaders.gl/schema';\nimport {loadBasisEncoderModule, loadBasisTrascoderModule} from './basis-module-loader';\nimport {GL_EXTENSIONS_CONSTANTS} from '../gl-extensions';\nimport {getSupportedGPUTextureFormats} from '../utils/texture-formats';\nimport {isKTX} from './parse-ktx';\n\nexport type BasisFormat =\n  | 'etc1'\n  | 'etc2'\n  | 'bc1'\n  | 'bc3'\n  | 'bc4'\n  | 'bc5'\n  | 'bc7-m6-opaque-only'\n  | 'bc7-m5'\n  | 'pvrtc1-4-rgb'\n  | 'pvrtc1-4-rgba'\n  | 'astc-4x4'\n  | 'atc-rgb'\n  | 'atc-rgba-interpolated-alpha'\n  | 'rgba32'\n  | 'rgb565'\n  | 'bgr565'\n  | 'rgba4444';\n\ntype BasisOutputOptions = {\n  basisFormat: number;\n  compressed: boolean;\n  format?: number;\n};\n\nconst OutputFormat: Record<string, BasisOutputOptions> = {\n  etc1: {\n    basisFormat: 0,\n    compressed: true,\n    format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_ETC1_WEBGL\n  },\n  etc2: {basisFormat: 1, compressed: true},\n  bc1: {\n    basisFormat: 2,\n    compressed: true,\n    format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_S3TC_DXT1_EXT\n  },\n  bc3: {\n    basisFormat: 3,\n    compressed: true,\n    format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT5_EXT\n  },\n  bc4: {basisFormat: 4, compressed: true},\n  bc5: {basisFormat: 5, compressed: true},\n  'bc7-m6-opaque-only': {basisFormat: 6, compressed: true},\n  'bc7-m5': {basisFormat: 7, compressed: true},\n  'pvrtc1-4-rgb': {\n    basisFormat: 8,\n    compressed: true,\n    format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_PVRTC_4BPPV1_IMG\n  },\n  'pvrtc1-4-rgba': {\n    basisFormat: 9,\n    compressed: true,\n    format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG\n  },\n  'astc-4x4': {\n    basisFormat: 10,\n    compressed: true,\n    format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_4X4_KHR\n  },\n  'atc-rgb': {basisFormat: 11, compressed: true},\n  'atc-rgba-interpolated-alpha': {basisFormat: 12, compressed: true},\n  rgba32: {basisFormat: 13, compressed: false},\n  rgb565: {basisFormat: 14, compressed: false},\n  bgr565: {basisFormat: 15, compressed: false},\n  rgba4444: {basisFormat: 16, compressed: false}\n};\n\n/**\n * parse data with a Binomial Basis_Universal module\n * @param data\n * @param options\n * @returns compressed texture data\n */\nexport default async function parseBasis(data: ArrayBuffer, options): Promise<TextureLevel[][]> {\n  if (options.basis.containerFormat === 'auto') {\n    if (isKTX(data)) {\n      const fileConstructors = await loadBasisEncoderModule(options);\n      return parseKTX2File(fileConstructors.KTX2File, data, options);\n    }\n    const {BasisFile} = await loadBasisTrascoderModule(options);\n    return parseBasisFile(BasisFile, data, options);\n  }\n  switch (options.basis.module) {\n    case 'encoder':\n      const fileConstructors = await loadBasisEncoderModule(options);\n      switch (options.basis.containerFormat) {\n        case 'ktx2':\n          return parseKTX2File(fileConstructors.KTX2File, data, options);\n        case 'basis':\n        default:\n          return parseBasisFile(fileConstructors.BasisFile, data, options);\n      }\n    case 'transcoder':\n    default:\n      const {BasisFile} = await loadBasisTrascoderModule(options);\n      return parseBasisFile(BasisFile, data, options);\n  }\n}\n\n/**\n * Parse *.basis file data\n * @param BasisFile - initialized transcoder module\n * @param data\n * @param options\n * @returns compressed texture data\n */\nfunction parseBasisFile(BasisFile, data, options): TextureLevel[][] {\n  const basisFile = new BasisFile(new Uint8Array(data));\n\n  try {\n    if (!basisFile.startTranscoding()) {\n      throw new Error('Failed to start basis transcoding');\n    }\n\n    const imageCount = basisFile.getNumImages();\n    const images: TextureLevel[][] = [];\n\n    for (let imageIndex = 0; imageIndex < imageCount; imageIndex++) {\n      const levelsCount = basisFile.getNumLevels(imageIndex);\n      const levels: TextureLevel[] = [];\n\n      for (let levelIndex = 0; levelIndex < levelsCount; levelIndex++) {\n        levels.push(transcodeImage(basisFile, imageIndex, levelIndex, options));\n      }\n\n      images.push(levels);\n    }\n\n    return images;\n  } finally {\n    basisFile.close();\n    basisFile.delete();\n  }\n}\n\n/**\n * Parse the particular level image of a basis file\n * @param basisFile\n * @param imageIndex\n * @param levelIndex\n * @param options\n * @returns compressed texture data\n */\nfunction transcodeImage(basisFile, imageIndex, levelIndex, options): TextureLevel {\n  const width = basisFile.getImageWidth(imageIndex, levelIndex);\n  const height = basisFile.getImageHeight(imageIndex, levelIndex);\n\n  // See https://github.com/BinomialLLC/basis_universal/pull/83\n  const hasAlpha = basisFile.getHasAlpha(/* imageIndex, levelIndex */);\n\n  // Check options for output format etc\n  const {compressed, format, basisFormat} = getBasisOptions(options, hasAlpha);\n\n  const decodedSize = basisFile.getImageTranscodedSizeInBytes(imageIndex, levelIndex, basisFormat);\n  const decodedData = new Uint8Array(decodedSize);\n\n  if (!basisFile.transcodeImage(decodedData, imageIndex, levelIndex, basisFormat, 0, 0)) {\n    throw new Error('failed to start Basis transcoding');\n  }\n\n  return {\n    // standard loaders.gl image category payload\n    width,\n    height,\n    data: decodedData,\n    compressed,\n    format,\n\n    // Additional fields\n    // Add levelSize field.\n    hasAlpha\n  };\n}\n\n/**\n * Parse *.ktx2 file data\n * @param KTX2File\n * @param data\n * @param options\n * @returns compressed texture data\n */\nfunction parseKTX2File(KTX2File, data: ArrayBuffer, options): TextureLevel[][] {\n  const ktx2File = new KTX2File(new Uint8Array(data));\n\n  try {\n    if (!ktx2File.startTranscoding()) {\n      throw new Error('failed to start KTX2 transcoding');\n    }\n    const levelsCount = ktx2File.getLevels();\n    const levels: TextureLevel[] = [];\n\n    for (let levelIndex = 0; levelIndex < levelsCount; levelIndex++) {\n      levels.push(transcodeKTX2Image(ktx2File, levelIndex, options));\n      break; // texture app can only show one level for some reason\n    }\n\n    return [levels];\n  } finally {\n    ktx2File.close();\n    ktx2File.delete();\n  }\n}\n\n/**\n * Parse the particular level image of a ktx2 file\n * @param ktx2File\n * @param levelIndex\n * @param options\n * @returns\n */\nfunction transcodeKTX2Image(ktx2File, levelIndex: number, options): TextureLevel {\n  const {alphaFlag, height, width} = ktx2File.getImageLevelInfo(levelIndex, 0, 0);\n\n  // Check options for output format etc\n  const {compressed, format, basisFormat} = getBasisOptions(options, alphaFlag);\n\n  const decodedSize = ktx2File.getImageTranscodedSizeInBytes(\n    levelIndex,\n    0 /* layerIndex */,\n    0 /* faceIndex */,\n    basisFormat\n  );\n  const decodedData = new Uint8Array(decodedSize);\n\n  if (\n    !ktx2File.transcodeImage(\n      decodedData,\n      levelIndex,\n      0 /* layerIndex */,\n      0 /* faceIndex */,\n      basisFormat,\n      0,\n      -1 /* channel0 */,\n      -1 /* channel1 */\n    )\n  ) {\n    throw new Error('Failed to transcode KTX2 image');\n  }\n\n  return {\n    // standard loaders.gl image category payload\n    width,\n    height,\n    data: decodedData,\n    compressed,\n\n    // Additional fields\n    levelSize: decodedSize,\n    hasAlpha: alphaFlag,\n    format\n  };\n}\n\n/**\n * Get BasisFormat by loader format option\n * @param options\n * @param hasAlpha\n * @returns BasisFormat data\n */\nfunction getBasisOptions(options, hasAlpha: boolean): BasisOutputOptions {\n  let format = options && options.basis && options.basis.format;\n  if (format === 'auto') {\n    format = selectSupportedBasisFormat();\n  }\n  if (typeof format === 'object') {\n    format = hasAlpha ? format.alpha : format.noAlpha;\n  }\n  format = format.toLowerCase();\n  return OutputFormat[format];\n}\n\n/**\n * Select transcode format from the list of supported formats\n * @returns key for OutputFormat map\n */\nexport function selectSupportedBasisFormat():\n  | BasisFormat\n  | {\n      alpha: BasisFormat;\n      noAlpha: BasisFormat;\n    } {\n  const supportedFormats = getSupportedGPUTextureFormats();\n  if (supportedFormats.has('astc')) {\n    return 'astc-4x4';\n  } else if (supportedFormats.has('dxt')) {\n    return {\n      alpha: 'bc3',\n      noAlpha: 'bc1'\n    };\n  } else if (supportedFormats.has('pvrtc')) {\n    return {\n      alpha: 'pvrtc1-4-rgba',\n      noAlpha: 'pvrtc1-4-rgb'\n    };\n  } else if (supportedFormats.has('etc1')) {\n    return 'etc1';\n  } else if (supportedFormats.has('etc2')) {\n    return 'etc2';\n  }\n  return 'rgb565';\n}\n", "import type {Loader, LoaderWithParser} from '@loaders.gl/loader-utils';\nimport {isBrowser} from '@loaders.gl/worker-utils';\nimport {VERSION} from './lib/utils/version';\nimport parseBasis from './lib/parsers/parse-basis';\n\n/**\n * Worker loader for Basis super compressed textures\n */\nexport const BasisWorkerLoader = {\n  name: 'Basis',\n  id: isBrowser ? 'basis' : 'basis-nodejs',\n  module: 'textures',\n  version: VERSION,\n  worker: true,\n  extensions: ['basis', 'ktx2'],\n  mimeTypes: ['application/octet-stream', 'image/ktx2'],\n  tests: ['sB'],\n  binary: true,\n  options: {\n    basis: {\n      format: 'auto', // gl context doesn't exist on a worker thread\n      libraryPath: 'libs/',\n      containerFormat: 'auto', // 'basis' || 'ktx2' || 'auto'\n      module: 'transcoder' // 'transcoder' || 'encoder'\n    }\n  }\n};\n\n/**\n * Loader for Basis super compressed textures\n */\nexport const BasisLoader = {\n  ...BasisWorkerLoader,\n  parse: parseBasis\n};\n\n// TYPE TESTS - TODO find a better way than exporting junk\nexport const _TypecheckBasisWorkerLoader: Loader = BasisWorkerLoader;\nexport const _TypecheckBasisLoader: LoaderWithParser = BasisLoader;\n", "import type {TextureLevel} from '@loaders.gl/schema';\nimport {assert} from '@loaders.gl/loader-utils';\nimport {GL_EXTENSIONS_CONSTANTS} from '../gl-extensions';\nimport {extractMipmapImages} from '../utils/extract-mipmap-images';\n\nconst DDS_CONSTANTS = {\n  MAGIC_NUMBER: 0x20534444,\n  HEADER_LENGTH: 31,\n  MAGIC_NUMBER_INDEX: 0,\n  HEADER_SIZE_INDEX: 1,\n  HEADER_FLAGS_INDEX: 2,\n  HEADER_HEIGHT_INDEX: 3,\n  HEADER_WIDTH_INDEX: 4,\n  MIPMAPCOUNT_INDEX: 7,\n  HEADER_PF_FLAGS_INDEX: 20,\n  HEADER_PF_FOURCC_INDEX: 21,\n  DDSD_MIPMAPCOUNT: 0x20000,\n  DDPF_FOURCC: 0x4\n};\n\nconst DDS_PIXEL_FORMATS: Record<string, number> = {\n  DXT1: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_S3TC_DXT1_EXT,\n  DXT3: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT3_EXT,\n  DXT5: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT5_EXT,\n  'ATC ': GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_ATC_WEBGL,\n  ATCA: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL,\n  ATCI: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL\n};\n\nconst getATCLevelSize = getDxt1LevelSize;\nconst getATCALevelSize = getDxtXLevelSize;\nconst getATCILevelSize = getDxtXLevelSize;\n\nconst DDS_SIZE_FUNCTIONS: Record<string, (width: number, height: number) => number> = {\n  DXT1: getDxt1LevelSize,\n  DXT3: getDxtXLevelSize,\n  DXT5: getDxtXLevelSize,\n  'ATC ': getATCLevelSize,\n  ATCA: getATCALevelSize,\n  ATCI: getATCILevelSize\n};\n\n/**\n * Check if data is in \"DDS\" format by its magic number\n * @param data - binary data of compressed texture\n * @returns true - data in \"DDS\" format, else - false\n */\nexport function isDDS(data: ArrayBuffer): boolean {\n  const header = new Uint32Array(data, 0, DDS_CONSTANTS.HEADER_LENGTH);\n  const magic = header[DDS_CONSTANTS.MAGIC_NUMBER_INDEX];\n  return magic === DDS_CONSTANTS.MAGIC_NUMBER;\n}\n\n/**\n * Parse texture data as \"DDS\" format\n * @param data - binary data of compressed texture\n * @returns Array of the texture levels\n */\nexport function parseDDS(data: ArrayBuffer): TextureLevel[] {\n  const header = new Int32Array(data, 0, DDS_CONSTANTS.HEADER_LENGTH);\n  const pixelFormatNumber = header[DDS_CONSTANTS.HEADER_PF_FOURCC_INDEX];\n  assert(\n    Boolean(header[DDS_CONSTANTS.HEADER_PF_FLAGS_INDEX] & DDS_CONSTANTS.DDPF_FOURCC),\n    'DDS: Unsupported format, must contain a FourCC code'\n  );\n  const fourCC = int32ToFourCC(pixelFormatNumber);\n  const internalFormat = DDS_PIXEL_FORMATS[fourCC];\n  const sizeFunction = DDS_SIZE_FUNCTIONS[fourCC];\n  assert(internalFormat && sizeFunction, `DDS: Unknown pixel format ${pixelFormatNumber}`);\n\n  let mipMapLevels = 1;\n  if (header[DDS_CONSTANTS.HEADER_FLAGS_INDEX] & DDS_CONSTANTS.DDSD_MIPMAPCOUNT) {\n    mipMapLevels = Math.max(1, header[DDS_CONSTANTS.MIPMAPCOUNT_INDEX]);\n  }\n  const width = header[DDS_CONSTANTS.HEADER_WIDTH_INDEX];\n  const height = header[DDS_CONSTANTS.HEADER_HEIGHT_INDEX];\n  const dataOffset = header[DDS_CONSTANTS.HEADER_SIZE_INDEX] + 4;\n  const image = new Uint8Array(data, dataOffset);\n\n  return extractMipmapImages(image, {\n    mipMapLevels,\n    width,\n    height,\n    sizeFunction,\n    internalFormat\n  });\n}\n\n/**\n * DXT1 applicable function to calculate level size\n * @param width - level width\n * @param height - level height\n * @returns level size in bytes\n */\nexport function getDxt1LevelSize(width: number, height: number): number {\n  return ((width + 3) >> 2) * ((height + 3) >> 2) * 8;\n}\n\n/**\n * DXT3 & DXT5 applicable function to calculate level size\n * @param width - level width\n * @param height - level height\n * @returns level size in bytes\n */\nexport function getDxtXLevelSize(width: number, height: number): number {\n  return ((width + 3) >> 2) * ((height + 3) >> 2) * 16;\n}\n\n/**\n * Convert every byte of Int32 value to char\n * @param value - Int32 number\n * @returns string of 4 characters\n */\nfunction int32ToFourCC(value: number): string {\n  return String.fromCharCode(\n    value & 0xff,\n    (value >> 8) & 0xff,\n    (value >> 16) & 0xff,\n    (value >> 24) & 0xff\n  );\n}\n", "/* eslint-disable camelcase */\n// Forked from PicoGL: https://github.com/tsherif/picogl.js/blob/master/examples/utils/utils.js\n// Copyright (c) 2017 Tarek Sherif, The MIT License (MIT)\n\nimport type {TextureLevel} from '@loaders.gl/schema';\nimport {GL_EXTENSIONS_CONSTANTS} from '../gl-extensions';\nimport {extractMipmapImages} from '../utils/extract-mipmap-images';\n\nconst PVR_CONSTANTS: Record<string, number> = {\n  MAGIC_NUMBER: 0x03525650,\n  MAGIC_NUMBER_EXTRA: 0x50565203,\n  HEADER_LENGTH: 13,\n  HEADER_SIZE: 52,\n  MAGIC_NUMBER_INDEX: 0,\n  PIXEL_FORMAT_INDEX: 2,\n  COLOUR_SPACE_INDEX: 4,\n  HEIGHT_INDEX: 6,\n  WIDTH_INDEX: 7,\n  MIPMAPCOUNT_INDEX: 11,\n  METADATA_SIZE_INDEX: 12\n};\n\nconst PVR_PIXEL_FORMATS: Record<number, number[]> = {\n  0: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_PVRTC_2BPPV1_IMG],\n  1: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG],\n  2: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_PVRTC_4BPPV1_IMG],\n  3: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG],\n  6: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_ETC1_WEBGL],\n  7: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_S3TC_DXT1_EXT],\n  9: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT3_EXT],\n  11: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT5_EXT],\n  22: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB8_ETC2],\n  23: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA8_ETC2_EAC],\n  24: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2],\n  25: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_R11_EAC],\n  26: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RG11_EAC],\n  27: [\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_4X4_KHR,\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_4X4_KHR\n  ],\n  28: [\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_5X4_KHR,\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_5X4_KHR\n  ],\n  29: [\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_5X5_KHR,\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_5X5_KHR\n  ],\n  30: [\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_6X5_KHR,\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_6X5_KHR\n  ],\n  31: [\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_6X6_KHR,\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_6X6_KHR\n  ],\n  32: [\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8X5_KHR,\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_8X5_KHR\n  ],\n  33: [\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8X6_KHR,\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_8X6_KHR\n  ],\n  34: [\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8X8_KHR,\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_8X8_KHR\n  ],\n  35: [\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10X5_KHR,\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_10X5_KHR\n  ],\n  36: [\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10X6_KHR,\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_10X6_KHR\n  ],\n  37: [\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10X8_KHR,\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_10X8_KHR\n  ],\n  38: [\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10X10_KHR,\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_10X10_KHR\n  ],\n  39: [\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_12X10_KHR,\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_12X10_KHR\n  ],\n  40: [\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_12X12_KHR,\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_12X12_KHR\n  ]\n};\n\nconst PVR_SIZE_FUNCTIONS: Record<number, (width: number, height: number) => number> = {\n  0: pvrtc2bppSize,\n  1: pvrtc2bppSize,\n  2: pvrtc4bppSize,\n  3: pvrtc4bppSize,\n  6: dxtEtcSmallSize,\n  7: dxtEtcSmallSize,\n  9: dxtEtcAstcBigSize,\n  11: dxtEtcAstcBigSize,\n  22: dxtEtcSmallSize,\n  23: dxtEtcAstcBigSize,\n  24: dxtEtcSmallSize,\n  25: dxtEtcSmallSize,\n  26: dxtEtcAstcBigSize,\n  27: dxtEtcAstcBigSize,\n  28: atc5x4Size,\n  29: atc5x5Size,\n  30: atc6x5Size,\n  31: atc6x6Size,\n  32: atc8x5Size,\n  33: atc8x6Size,\n  34: atc8x8Size,\n  35: atc10x5Size,\n  36: atc10x6Size,\n  37: atc10x8Size,\n  38: atc10x10Size,\n  39: atc12x10Size,\n  40: atc12x12Size\n};\n\n/**\n * Check if data is in \"PVR\" format by its magic number\n * @param data - binary data of compressed texture\n * @returns true - data in \"PVR\" format, else - false\n */\nexport function isPVR(data: ArrayBuffer): boolean {\n  const header = new Uint32Array(data, 0, PVR_CONSTANTS.HEADER_LENGTH);\n  const version = header[PVR_CONSTANTS.MAGIC_NUMBER_INDEX];\n\n  return version === PVR_CONSTANTS.MAGIC_NUMBER || version === PVR_CONSTANTS.MAGIC_NUMBER_EXTRA;\n}\n\n/**\n * Parse texture data as \"PVR\" format\n * @param data - binary data of compressed texture\n * @returns Array of the texture levels\n * @see http://cdn.imgtec.com/sdk-documentation/PVR+File+Format.Specification.pdf\n */\nexport function parsePVR(data: ArrayBuffer): TextureLevel[] {\n  const header = new Uint32Array(data, 0, PVR_CONSTANTS.HEADER_LENGTH);\n\n  const pvrFormat = header[PVR_CONSTANTS.PIXEL_FORMAT_INDEX];\n  const colourSpace = header[PVR_CONSTANTS.COLOUR_SPACE_INDEX];\n  const pixelFormats = PVR_PIXEL_FORMATS[pvrFormat] || [];\n  const internalFormat = pixelFormats.length > 1 && colourSpace ? pixelFormats[1] : pixelFormats[0];\n\n  const sizeFunction = PVR_SIZE_FUNCTIONS[pvrFormat];\n\n  const mipMapLevels = header[PVR_CONSTANTS.MIPMAPCOUNT_INDEX];\n\n  const width = header[PVR_CONSTANTS.WIDTH_INDEX];\n  const height = header[PVR_CONSTANTS.HEIGHT_INDEX];\n\n  const dataOffset = PVR_CONSTANTS.HEADER_SIZE + header[PVR_CONSTANTS.METADATA_SIZE_INDEX];\n\n  const image = new Uint8Array(data, dataOffset);\n\n  return extractMipmapImages(image, {\n    mipMapLevels,\n    width,\n    height,\n    sizeFunction,\n    internalFormat\n  });\n}\n\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_pvrtc/\nfunction pvrtc2bppSize(width: number, height: number): number {\n  width = Math.max(width, 16);\n  height = Math.max(height, 8);\n\n  return (width * height) / 4;\n}\n\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_pvrtc/\nfunction pvrtc4bppSize(width: number, height: number): number {\n  width = Math.max(width, 8);\n  height = Math.max(height, 8);\n\n  return (width * height) / 2;\n}\n\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_s3tc/\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_etc/\n// Size for:\n// COMPRESSED_RGB_S3TC_DXT1_EXT\n// COMPRESSED_R11_EAC\n// COMPRESSED_SIGNED_R11_EAC\n// COMPRESSED_RGB8_ETC2\n// COMPRESSED_SRGB8_ETC2\n// COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2\n// COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2\nfunction dxtEtcSmallSize(width: number, height: number): number {\n  return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 8;\n}\n\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_s3tc/\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_etc/\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/\n// Size for:\n// COMPRESSED_RGBA_S3TC_DXT3_EXT\n// COMPRESSED_RGBA_S3TC_DXT5_EXT\n// COMPRESSED_RG11_EAC\n// COMPRESSED_SIGNED_RG11_EAC\n// COMPRESSED_RGBA8_ETC2_EAC\n// COMPRESSED_SRGB8_ALPHA8_ETC2_EAC\n// COMPRESSED_RGBA_ASTC_4x4_KHR\nfunction dxtEtcAstcBigSize(width: number, height: number): number {\n  return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 16;\n}\n\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/\nfunction atc5x4Size(width: number, height: number): number {\n  return Math.floor((width + 4) / 5) * Math.floor((height + 3) / 4) * 16;\n}\n\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/\nfunction atc5x5Size(width: number, height: number): number {\n  return Math.floor((width + 4) / 5) * Math.floor((height + 4) / 5) * 16;\n}\n\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/\nfunction atc6x5Size(width: number, height: number): number {\n  return Math.floor((width + 5) / 6) * Math.floor((height + 4) / 5) * 16;\n}\n\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/\nfunction atc6x6Size(width: number, height: number): number {\n  return Math.floor((width + 5) / 6) * Math.floor((height + 5) / 6) * 16;\n}\n\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/\nfunction atc8x5Size(width: number, height: number): number {\n  return Math.floor((width + 7) / 8) * Math.floor((height + 4) / 5) * 16;\n}\n\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/\nfunction atc8x6Size(width: number, height: number): number {\n  return Math.floor((width + 7) / 8) * Math.floor((height + 5) / 6) * 16;\n}\n\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/\nfunction atc8x8Size(width: number, height: number): number {\n  return Math.floor((width + 7) / 8) * Math.floor((height + 7) / 8) * 16;\n}\n\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/\nfunction atc10x5Size(width: number, height: number): number {\n  return Math.floor((width + 9) / 10) * Math.floor((height + 4) / 5) * 16;\n}\n\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/\nfunction atc10x6Size(width: number, height: number): number {\n  return Math.floor((width + 9) / 10) * Math.floor((height + 5) / 6) * 16;\n}\n\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/\nfunction atc10x8Size(width: number, height: number): number {\n  return Math.floor((width + 9) / 10) * Math.floor((height + 7) / 8) * 16;\n}\n\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/\nfunction atc10x10Size(width: number, height: number): number {\n  return Math.floor((width + 9) / 10) * Math.floor((height + 9) / 10) * 16;\n}\n\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/\nfunction atc12x10Size(width: number, height: number): number {\n  return Math.floor((width + 11) / 12) * Math.floor((height + 9) / 10) * 16;\n}\n\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/\nfunction atc12x12Size(width: number, height: number): number {\n  return Math.floor((width + 11) / 12) * Math.floor((height + 11) / 12) * 16;\n}\n", "import type {TextureLevel} from '@loaders.gl/schema';\nimport {isKTX, parseKTX} from './parse-ktx';\nimport {isDDS, parseDDS} from './parse-dds';\nimport {isPVR, parsePVR} from './parse-pvr';\n\n/**\n * Deduces format and parses compressed texture loaded in ArrayBuffer\n * @param data - binary data of compressed texture\n * @returns Array of the texture levels\n */\nexport function parseCompressedTexture(data: ArrayBuffer): TextureLevel[] {\n  if (isKTX(data)) {\n    // TODO: remove @ts-ignore when `parseKTX` output is normalized to loaders.gl texture format\n    // @ts-ignore\n    return parseKTX(data);\n  }\n  if (isDDS(data)) {\n    return parseDDS(data);\n  }\n  if (isPVR(data)) {\n    return parsePVR(data);\n  }\n  throw new Error('Texture container format not recognized');\n}\n", "import type {Loader, LoaderWithParser} from '@loaders.gl/loader-utils';\nimport {VERSION} from './lib/utils/version';\nimport {parseCompressedTexture} from './lib/parsers/parse-compressed-texture';\nimport parseBasis from './lib/parsers/parse-basis';\n\nexport type TextureLoaderOptions = {\n  'compressed-texture'?: {\n    libraryPath?: string;\n    useBasis?: boolean;\n  };\n};\n\nconst DEFAULT_TEXTURE_LOADER_OPTIONS = {\n  'compressed-texture': {\n    libraryPath: 'libs/',\n    useBasis: false\n  }\n};\n\n/**\n * Worker Loader for KTX, DDS, and PVR texture container formats\n */\nexport const CompressedTextureWorkerLoader = {\n  name: 'Texture Containers',\n  id: 'compressed-texture',\n  module: 'textures',\n  version: VERSION,\n  worker: true,\n  extensions: [\n    'ktx',\n    'ktx2',\n    'dds', // WEBGL_compressed_texture_s3tc, WEBGL_compressed_texture_atc\n    'pvr' // WEBGL_compressed_texture_pvrtc\n  ],\n  mimeTypes: [\n    'image/ktx2',\n    'image/ktx',\n    'image/vnd-ms.dds',\n    'image/x-dds',\n    'application/octet-stream'\n  ],\n  binary: true,\n  options: DEFAULT_TEXTURE_LOADER_OPTIONS\n};\n\n/**\n * Loader for KTX, DDS, and PVR texture container formats\n */\nexport const CompressedTextureLoader = {\n  ...CompressedTextureWorkerLoader,\n  parse: async (arrayBuffer, options) => {\n    if (options['compressed-texture'].useBasis) {\n      options.basis = {\n        format: {\n          alpha: 'BC3',\n          noAlpha: 'BC1'\n        },\n        ...options.basis,\n        containerFormat: 'ktx2',\n        module: 'encoder'\n      };\n      return (await parseBasis(arrayBuffer, options))[0];\n    }\n    return parseCompressedTexture(arrayBuffer);\n  }\n};\n\n// TYPE TESTS - TODO find a better way than exporting junk\nexport const _TypecheckCompressedTextureWorkerLoader: Loader = CompressedTextureWorkerLoader;\nexport const _TypecheckCompressedTextureLoader: LoaderWithParser = CompressedTextureLoader;\n", "// import type {TextureLevel} from '@loaders.gl/schema';\n\ntype NumpyHeader = {descr: string; shape: number[]};\ntype TypedArrayConstructor =\n  | typeof Int8Array\n  | typeof Uint8Array\n  | typeof Int16Array\n  | typeof Uint16Array\n  | typeof Int32Array\n  | typeof Uint32Array\n  | typeof Int32Array\n  | typeof Uint32Array\n  | typeof Float32Array\n  | typeof Float64Array;\n\nfunction systemIsLittleEndian() {\n  const a = new Uint32Array([0x12345678]);\n  const b = new Uint8Array(a.buffer, a.byteOffset, a.byteLength);\n  return !(b[0] === 0x12);\n}\n\nconst LITTLE_ENDIAN_OS = systemIsLittleEndian();\n\n// The basic string format consists of 3 characters:\n// 1. a character describing the byteorder of the data (<: little-endian, >: big-endian, |: not-relevant)\n// 2. a character code giving the basic type of the array\n// 3. an integer providing the number of bytes the type uses.\n// https://numpy.org/doc/stable/reference/arrays.interface.html\n//\n// Here I only include the second and third characters, and check endianness\n// separately\nconst DTYPES: Record<string, TypedArrayConstructor> = {\n  u1: Uint8Array,\n  i1: Int8Array,\n  u2: Uint16Array,\n  i2: Int16Array,\n  u4: Uint32Array,\n  i4: Int32Array,\n  f4: Float32Array,\n  f8: Float64Array\n};\n\nexport function parseNPY(arrayBuffer: ArrayBuffer, options?: unknown) {\n  if (!arrayBuffer) {\n    return null;\n  }\n\n  const view = new DataView(arrayBuffer);\n  const {header, headerEndOffset} = parseHeader(view);\n\n  const numpyType = header.descr;\n  const ArrayType = DTYPES[numpyType.slice(1, 3)];\n  if (!ArrayType) {\n    throw new Error(`Unimplemented type ${numpyType}`);\n  }\n\n  const nArrayElements = header.shape?.reduce((a: number, b: number): number => a * b);\n  const arrayByteLength = nArrayElements * ArrayType.BYTES_PER_ELEMENT;\n\n  if (arrayBuffer.byteLength < headerEndOffset + arrayByteLength) {\n    throw new Error('Buffer overflow');\n  }\n  const data = new ArrayType(arrayBuffer.slice(headerEndOffset, headerEndOffset + arrayByteLength));\n\n  // Swap endianness if needed\n  if ((numpyType[0] === '>' && LITTLE_ENDIAN_OS) || (numpyType[0] === '<' && !LITTLE_ENDIAN_OS)) {\n    throw new Error('Incorrect endianness');\n  }\n\n  return {\n    data,\n    header\n  };\n}\n\n/**\n * Parse NPY header\n *\n * @param  view\n * @return\n */\nfunction parseHeader(view: DataView): {header: NumpyHeader; headerEndOffset: number} {\n  const majorVersion = view.getUint8(6);\n  // const minorVersion = view.getUint8(7);\n\n  let offset = 8;\n  let headerLength: number;\n  if (majorVersion >= 2) {\n    headerLength = view.getUint32(offset, true);\n    offset += 4;\n  } else {\n    headerLength = view.getUint16(offset, true);\n    offset += 2;\n  }\n\n  const encoding = majorVersion <= 2 ? 'latin1' : 'utf-8';\n  const decoder = new TextDecoder(encoding);\n  const headerArray = new Uint8Array(view.buffer, offset, headerLength);\n  const headerText = decoder.decode(headerArray);\n  offset += headerLength;\n\n  const header = JSON.parse(\n    headerText\n      .replace(/'/g, '\"')\n      .replace('False', 'false')\n      .replace('(', '[')\n      .replace(/,*\\),*/g, ']')\n  );\n\n  return {header, headerEndOffset: offset};\n}\n", "import type {Loader, LoaderWithParser, LoaderOptions} from '@loaders.gl/loader-utils';\nimport {VERSION} from './lib/utils/version';\nimport {parseNPY} from './lib/parsers/parse-npy';\n\n// \\x93NUMPY\nconst NPY_MAGIC_NUMBER = new Uint8Array([147, 78, 85, 77, 80, 89]);\n\n/**\n * Worker loader for numpy \"tiles\"\n */\nexport const NPYWorkerLoader = {\n  name: 'NPY',\n  id: 'npy',\n  module: 'textures',\n  version: VERSION,\n  worker: true,\n  extensions: ['npy'],\n  mimeTypes: [],\n  tests: [NPY_MAGIC_NUMBER.buffer],\n  options: {\n    npy: {}\n  }\n};\n\n/**\n * Loader for numpy \"tiles\"\n */\nexport const NPYLoader = {\n  ...NPYWorkerLoader,\n  parseSync: parseNPY,\n  parse: async (arrayBuffer: ArrayBuffer, options?: LoaderOptions) => parseNPY(arrayBuffer, options)\n};\n\n// TYPE TESTS - TODO find a better way than exporting junk\nexport const _TypecheckNPYWorkerLoader: Loader = NPYWorkerLoader;\nexport const _TypecheckNPYLoader: LoaderWithParser = NPYLoader;\n", "// Replacement for the external assert method to reduce bundle size\n// Note: We don't use the second \"message\" argument in calling code,\n// so no need to support it here\nexport function assert(condition: unknown, message?: string): void {\n  if (!condition) {\n    throw new Error(message || 'assert failed: gltf');\n  }\n}\n", "// Resolves a relative url against a baseUrl\n// If url is absolute, return it unchanged\nexport function resolveUrl(url, options) {\n  // TODO: Use better logic to handle all protocols plus not delay on data\n  const absolute = url.startsWith('data:') || url.startsWith('http:') || url.startsWith('https:');\n  if (absolute) {\n    return url;\n  }\n  const baseUrl = options.baseUri || options.uri;\n  if (!baseUrl) {\n    throw new Error(`'baseUri' must be provided to resolve relative url ${url}`);\n  }\n  return baseUrl.substr(0, baseUrl.lastIndexOf('/') + 1) + url;\n}\n", "// TODO - GLTFScenegraph should use these\nimport {assert} from '../utils/assert';\n\n// accepts buffer view index or buffer view object\n// returns a `Uint8Array`\nexport function getTypedArrayForBufferView(json, buffers, bufferViewIndex) {\n  const bufferView = json.bufferViews[bufferViewIndex];\n  assert(bufferView);\n\n  // Get hold of the arrayBuffer\n  const bufferIndex = bufferView.buffer;\n  const binChunk = buffers[bufferIndex];\n  assert(binChunk);\n\n  const byteOffset = (bufferView.byteOffset || 0) + binChunk.byteOffset;\n  return new Uint8Array(binChunk.arrayBuffer, byteOffset, bufferView.byteLength);\n}\n\n// accepts accessor index or accessor object\n// returns a `Uint8Array`\nexport function getTypedArrayForImageData(json, buffers, imageIndex) {\n  const image = json.images[imageIndex];\n  const bufferViewIndex = json.bufferViews[image.bufferView];\n  return getTypedArrayForBufferView(json, buffers, bufferViewIndex);\n}\n\n/*\n// accepts accessor index or accessor object\n// returns a typed array with type that matches the types\nexport function getTypedArrayForAccessor(accessor) {\n  accessor = this.getAccessor(accessor);\n  const bufferView = this.getBufferView(accessor.bufferView);\n  const buffer = this.getBuffer(bufferView.buffer);\n  const arrayBuffer = buffer.data;\n\n  // Create a new typed array as a view into the combined buffer\n  const {ArrayType, length} = getAccessorArrayTypeAndLength(accessor, bufferView);\n  const byteOffset = bufferView.byteOffset + accessor.byteOffset;\n  return new ArrayType(arrayBuffer, byteOffset, length);\n}\n*/\n", "import {assert} from '../utils/assert';\n\nconst TYPES = ['SCALAR', 'VEC2', 'VEC3', 'VEC4'];\n\ntype TypedArrayConstructor =\n  | Int8ArrayConstructor\n  | Uint8ArrayConstructor\n  | Int16ArrayConstructor\n  | Uint16ArrayConstructor\n  | Int32ArrayConstructor\n  | Uint32ArrayConstructor\n  | Int32ArrayConstructor\n  | Uint32ArrayConstructor\n  | Float32ArrayConstructor\n  | Float64ArrayConstructor;\n\nconst ARRAY_CONSTRUCTOR_TO_WEBGL_CONSTANT: [TypedArrayConstructor, number][] = [\n  [Int8Array, 5120],\n  [Uint8Array, 5121],\n  [Int16Array, 5122],\n  [Uint16Array, 5123],\n  [Uint32Array, 5125],\n  [Float32Array, 5126],\n  [Float64Array, 5130]\n];\nconst ARRAY_TO_COMPONENT_TYPE = new Map<TypedArrayConstructor, number>(\n  ARRAY_CONSTRUCTOR_TO_WEBGL_CONSTANT\n);\n\nconst ATTRIBUTE_TYPE_TO_COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\n\nconst ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE = {\n  5120: 1,\n  5121: 1,\n  5122: 2,\n  5123: 2,\n  5125: 4,\n  5126: 4\n};\n\nconst ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array\n};\n\nexport function getAccessorTypeFromSize(size) {\n  const type = TYPES[size - 1];\n  return type || TYPES[0];\n}\n\nexport function getComponentTypeFromArray(typedArray) {\n  const componentType = ARRAY_TO_COMPONENT_TYPE.get(typedArray.constructor);\n  if (!componentType) {\n    throw new Error('Illegal typed array');\n  }\n  return componentType;\n}\n\nexport function getAccessorArrayTypeAndLength(accessor, bufferView) {\n  const ArrayType = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY[accessor.componentType];\n  const components = ATTRIBUTE_TYPE_TO_COMPONENTS[accessor.type];\n  const bytesPerComponent = ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE[accessor.componentType];\n  const length = accessor.count * components;\n  const byteLength = accessor.count * components * bytesPerComponent;\n  assert(byteLength >= 0 && byteLength <= bufferView.byteLength);\n  return {ArrayType, length, byteLength};\n}\n", "import type {\n  GLTF,\n  GLTFScene,\n  GLTFNode,\n  GLTFMesh,\n  GLTFSkin,\n  GLTFMaterial,\n  GLTFAccessor,\n  GLTFSampler,\n  GLTFTexture,\n  GLTFImage,\n  GLTFBuffer,\n  GLTFBufferView,\n  GLTFWithBuffers\n} from '../types/gltf-types';\n\nimport {getBinaryImageMetadata} from '@loaders.gl/images';\nimport {padToNBytes, copyToArray} from '@loaders.gl/loader-utils';\nimport {assert} from '../utils/assert';\nimport {\n  getAccessorArrayTypeAndLength,\n  getAccessorTypeFromSize,\n  getComponentTypeFromArray\n} from '../gltf-utils/gltf-utils';\n\nconst DEFAULT_GLTF_JSON: GLTF = {\n  asset: {\n    version: '2.0',\n    generator: 'loaders.gl'\n  },\n  buffers: []\n};\n\ntype Extension = {[key: string]: any};\n/**\n * Class for structured access to GLTF data\n */\nexport default class GLTFScenegraph {\n  // internal\n  gltf: GLTFWithBuffers;\n  sourceBuffers: any[];\n  byteLength: number;\n\n  constructor(gltf?: {json: GLTF; buffers?: any[]}) {\n    // @ts-ignore\n    this.gltf = gltf || {\n      json: {...DEFAULT_GLTF_JSON},\n      buffers: []\n    };\n    this.sourceBuffers = [];\n    this.byteLength = 0;\n\n    // Initialize buffers\n    if (this.gltf.buffers && this.gltf.buffers[0]) {\n      this.byteLength = this.gltf.buffers[0].byteLength;\n      this.sourceBuffers = [this.gltf.buffers[0]];\n    }\n  }\n\n  // Accessors\n\n  get json(): GLTF {\n    return this.gltf.json;\n  }\n\n  getApplicationData(key: string): unknown {\n    // TODO - Data is already unpacked by GLBParser\n    const data = this.json[key];\n    return data;\n  }\n\n  getExtraData(key: string): {[key: string]: unknown} {\n    // TODO - Data is already unpacked by GLBParser\n    const extras = this.json.extras || {};\n    return extras[key];\n  }\n\n  getExtension<T = Extension>(extensionName: string): T | null {\n    const isExtension = this.getUsedExtensions().find((name) => name === extensionName);\n    const extensions = this.json.extensions || {};\n    return isExtension ? extensions[extensionName] || true : null;\n  }\n\n  getRequiredExtension<T = Extension>(extensionName: string): T | null {\n    const isRequired = this.getRequiredExtensions().find((name) => name === extensionName);\n    return isRequired ? this.getExtension(extensionName) : null;\n  }\n\n  getRequiredExtensions(): string[] {\n    return this.json.extensionsRequired || [];\n  }\n\n  getUsedExtensions(): string[] {\n    return this.json.extensionsUsed || [];\n  }\n\n  getRemovedExtensions(): string[] {\n    return (this.json.extensionsRemoved || []) as string[];\n  }\n\n  getObjectExtension<T = Extension>(object: {[key: string]: any}, extensionName: string): T | null {\n    const extensions = object.extensions || {};\n    return extensions[extensionName];\n  }\n\n  getScene(index: number): GLTFScene {\n    return this.getObject('scenes', index) as GLTFScene;\n  }\n\n  getNode(index: number): GLTFNode {\n    return this.getObject('nodes', index) as GLTFNode;\n  }\n\n  getSkin(index: number): GLTFSkin {\n    return this.getObject('skins', index) as GLTFSkin;\n  }\n\n  getMesh(index: number): GLTFMesh {\n    return this.getObject('meshes', index) as GLTFMesh;\n  }\n\n  getMaterial(index: number): GLTFMaterial {\n    return this.getObject('materials', index) as GLTFMaterial;\n  }\n\n  getAccessor(index: number): GLTFAccessor {\n    return this.getObject('accessors', index) as GLTFAccessor;\n  }\n\n  // getCamera(index: number): object | null {\n  //   return null; // TODO: fix thi: object  as null;\n  // }\n\n  getTexture(index: number): GLTFTexture {\n    return this.getObject('textures', index) as GLTFTexture;\n  }\n\n  getSampler(index: number): GLTFSampler {\n    return this.getObject('samplers', index) as GLTFSampler;\n  }\n\n  getImage(index: number): GLTFImage {\n    return this.getObject('images', index) as GLTFImage;\n  }\n\n  getBufferView(index: number | object): GLTFBufferView {\n    return this.getObject('bufferViews', index) as GLTFBufferView;\n  }\n\n  getBuffer(index: number): GLTFBuffer {\n    return this.getObject('buffers', index) as GLTFBuffer;\n  }\n\n  getObject(array: string, index: number | object): object {\n    // check if already resolved\n    if (typeof index === 'object') {\n      return index;\n    }\n    const object = this.json[array] && (this.json[array] as {}[])[index];\n    if (!object) {\n      throw new Error(`glTF file error: Could not find ${array}[${index}]`); // eslint-disable-line\n    }\n    return object;\n  }\n\n  /**\n   * Accepts buffer view index or buffer view object\n   * @returns a `Uint8Array`\n   */\n  getTypedArrayForBufferView(bufferView: number | object): Uint8Array {\n    bufferView = this.getBufferView(bufferView);\n    // @ts-ignore\n    const bufferIndex = bufferView.buffer;\n\n    // Get hold of the arrayBuffer\n    // const buffer = this.getBuffer(bufferIndex);\n    const binChunk = this.gltf.buffers[bufferIndex];\n    assert(binChunk);\n\n    // @ts-ignore\n    const byteOffset = (bufferView.byteOffset || 0) + binChunk.byteOffset;\n    // @ts-ignore\n    return new Uint8Array(binChunk.arrayBuffer, byteOffset, bufferView.byteLength);\n  }\n\n  /** Accepts accessor index or accessor object\n   * @returns a typed array with type that matches the types\n   */\n  getTypedArrayForAccessor(accessor: number | object): any {\n    // @ts-ignore\n    accessor = this.getAccessor(accessor);\n    // @ts-ignore\n    const bufferView = this.getBufferView(accessor.bufferView);\n    const buffer = this.getBuffer(bufferView.buffer);\n    // @ts-ignore\n    const arrayBuffer = buffer.data;\n\n    // Create a new typed array as a view into the combined buffer\n    const {ArrayType, length} = getAccessorArrayTypeAndLength(accessor, bufferView);\n    // @ts-ignore\n    const byteOffset = bufferView.byteOffset + accessor.byteOffset;\n    return new ArrayType(arrayBuffer, byteOffset, length);\n  }\n\n  /** accepts accessor index or accessor object\n   * returns a `Uint8Array`\n   */\n  getTypedArrayForImageData(image: number | object): Uint8Array {\n    // @ts-ignore\n    image = this.getAccessor(image);\n    // @ts-ignore\n    const bufferView = this.getBufferView(image.bufferView);\n    const buffer = this.getBuffer(bufferView.buffer);\n    // @ts-ignore\n    const arrayBuffer = buffer.data;\n\n    const byteOffset = bufferView.byteOffset || 0;\n    return new Uint8Array(arrayBuffer, byteOffset, bufferView.byteLength);\n  }\n\n  // MODIFERS\n\n  /**\n   * Add an extra application-defined key to the top-level data structure\n   */\n  addApplicationData(key: string, data: object): GLTFScenegraph {\n    this.json[key] = data;\n    return this;\n  }\n\n  /**\n   * `extras` - Standard GLTF field for storing application specific data\n   */\n  addExtraData(key: string, data: object): GLTFScenegraph {\n    this.json.extras = this.json.extras || {};\n    (this.json.extras as Record<string, unknown>)[key] = data;\n    return this;\n  }\n\n  addObjectExtension(object: object, extensionName: string, data: object): GLTFScenegraph {\n    // @ts-ignore\n    object.extensions = object.extensions || {};\n    // TODO - clobber or merge?\n    // @ts-ignore\n    object.extensions[extensionName] = data;\n    this.registerUsedExtension(extensionName);\n    return this;\n  }\n\n  setObjectExtension(object: object, extensionName: string, data: object): void {\n    // @ts-ignore\n    const extensions = object.extensions || {};\n    extensions[extensionName] = data;\n    // TODO - add to usedExtensions...\n  }\n\n  removeObjectExtension(object: object, extensionName: string): object {\n    // @ts-ignore\n    const extensions = object.extensions || {};\n    const extension = extensions[extensionName];\n    delete extensions[extensionName];\n    return extension;\n  }\n\n  /**\n   * Add to standard GLTF top level extension object, mark as used\n   */\n  addExtension(extensionName: string, extensionData: object = {}): object {\n    assert(extensionData);\n    this.json.extensions = this.json.extensions || {};\n    (this.json.extensions as Record<string, unknown>)[extensionName] = extensionData;\n    this.registerUsedExtension(extensionName);\n    return extensionData;\n  }\n\n  /**\n   * Standard GLTF top level extension object, mark as used and required\n   */\n  addRequiredExtension(extensionName, extensionData: object = {}): object {\n    assert(extensionData);\n    this.addExtension(extensionName, extensionData);\n    this.registerRequiredExtension(extensionName);\n    return extensionData;\n  }\n\n  /**\n   * Add extensionName to list of used extensions\n   */\n  registerUsedExtension(extensionName: string): void {\n    this.json.extensionsUsed = this.json.extensionsUsed || [];\n    if (!this.json.extensionsUsed.find((ext) => ext === extensionName)) {\n      this.json.extensionsUsed.push(extensionName);\n    }\n  }\n\n  /**\n   * Add extensionName to list of required extensions\n   */\n  registerRequiredExtension(extensionName: string): void {\n    this.registerUsedExtension(extensionName);\n    this.json.extensionsRequired = this.json.extensionsRequired || [];\n    if (!this.json.extensionsRequired.find((ext) => ext === extensionName)) {\n      this.json.extensionsRequired.push(extensionName);\n    }\n  }\n\n  /**\n   * Removes an extension from the top-level list\n   */\n  removeExtension(extensionName: string): void {\n    if (!this.getExtension(extensionName)) {\n      return;\n    }\n    if (this.json.extensionsRequired) {\n      this._removeStringFromArray(this.json.extensionsRequired, extensionName);\n    }\n    if (this.json.extensionsUsed) {\n      this._removeStringFromArray(this.json.extensionsUsed, extensionName);\n    }\n    if (this.json.extensions) {\n      delete this.json.extensions[extensionName];\n    }\n    if (!Array.isArray(this.json.extensionsRemoved)) {\n      this.json.extensionsRemoved = [];\n    }\n    const extensionsRemoved = this.json.extensionsRemoved as string[];\n    if (!extensionsRemoved.includes(extensionName)) {\n      extensionsRemoved.push(extensionName);\n    }\n  }\n\n  /**\n   *  Set default scene which is to be displayed at load time\n   */\n  setDefaultScene(sceneIndex: number): void {\n    this.json.scene = sceneIndex;\n  }\n\n  /**\n   * @todo: add more properties for scene initialization:\n   *   name`, `extensions`, `extras`\n   *   https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-scene\n   */\n  addScene(scene: {nodeIndices: number[]}): number {\n    const {nodeIndices} = scene;\n    this.json.scenes = this.json.scenes || [];\n    this.json.scenes.push({nodes: nodeIndices});\n    return this.json.scenes.length - 1;\n  }\n\n  /**\n   * @todo: add more properties for node initialization:\n   *   `name`, `extensions`, `extras`, `camera`, `children`, `skin`, `rotation`, `scale`, `translation`, `weights`\n   *   https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#node\n   */\n  addNode(node: {meshIndex: number; matrix?: number[]}): number {\n    const {meshIndex, matrix} = node;\n    this.json.nodes = this.json.nodes || [];\n    const nodeData = {mesh: meshIndex};\n    if (matrix) {\n      // @ts-ignore\n      nodeData.matrix = matrix;\n    }\n    this.json.nodes.push(nodeData);\n    return this.json.nodes.length - 1;\n  }\n\n  /** Adds a mesh to the json part */\n  addMesh(mesh: {attributes: object; indices?: object; material?: number; mode?: number}): number {\n    const {attributes, indices, material, mode = 4} = mesh;\n    const accessors = this._addAttributes(attributes);\n\n    const glTFMesh = {\n      primitives: [\n        {\n          attributes: accessors,\n          mode\n        }\n      ]\n    };\n\n    if (indices) {\n      const indicesAccessor = this._addIndices(indices);\n      // @ts-ignore\n      glTFMesh.primitives[0].indices = indicesAccessor;\n    }\n\n    if (Number.isFinite(material)) {\n      // @ts-ignore\n      glTFMesh.primitives[0].material = material;\n    }\n\n    this.json.meshes = this.json.meshes || [];\n    this.json.meshes.push(glTFMesh);\n    return this.json.meshes.length - 1;\n  }\n\n  addPointCloud(attributes: object): number {\n    // @ts-ignore\n    const accessorIndices = this._addAttributes(attributes);\n\n    const glTFMesh = {\n      primitives: [\n        {\n          attributes: accessorIndices,\n          mode: 0 // GL.POINTS\n        }\n      ]\n    };\n\n    this.json.meshes = this.json.meshes || [];\n    this.json.meshes.push(glTFMesh);\n    return this.json.meshes.length - 1;\n  }\n\n  /**\n   * Adds a binary image. Builds glTF \"JSON metadata\" and saves buffer reference\n   * Buffer will be copied into BIN chunk during \"pack\"\n   * Currently encodes as glTF image\n   * @param imageData\n   * @param mimeType\n   */\n  addImage(imageData: any, mimeTypeOpt?: string): number {\n    // If image is referencing a bufferView instead of URI, mimeType must be defined:\n    //   https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#images\n    //   \"a reference to a bufferView; in that case mimeType must be defined.\"\n    const metadata = getBinaryImageMetadata(imageData);\n    const mimeType = mimeTypeOpt || metadata?.mimeType;\n\n    const bufferViewIndex = this.addBufferView(imageData);\n\n    const glTFImage = {\n      bufferView: bufferViewIndex,\n      mimeType\n    };\n\n    this.json.images = this.json.images || [];\n    this.json.images.push(glTFImage);\n    return this.json.images.length - 1;\n  }\n\n  /**\n   * Add one untyped source buffer, create a matching glTF `bufferView`, and return its index\n   * @param buffer\n   */\n  addBufferView(buffer: any): number {\n    const byteLength = buffer.byteLength;\n    assert(Number.isFinite(byteLength));\n\n    // Add this buffer to the list of buffers to be written to the body.\n    this.sourceBuffers = this.sourceBuffers || [];\n    this.sourceBuffers.push(buffer);\n\n    const glTFBufferView = {\n      buffer: 0,\n      // Write offset from the start of the binary body\n      byteOffset: this.byteLength,\n      byteLength\n    };\n\n    // We've now added the contents to the body, so update the total length\n    // Every sub-chunk needs to be 4-byte align ed\n    this.byteLength += padToNBytes(byteLength, 4);\n\n    // Add a bufferView indicating start and length of this binary sub-chunk\n    this.json.bufferViews = this.json.bufferViews || [];\n    this.json.bufferViews.push(glTFBufferView);\n    return this.json.bufferViews.length - 1;\n  }\n\n  /**\n   * Adds an accessor to a bufferView\n   * @param bufferViewIndex\n   * @param accessor\n   */\n  addAccessor(bufferViewIndex: number, accessor: object): number {\n    const glTFAccessor = {\n      bufferView: bufferViewIndex,\n      // @ts-ignore\n      type: getAccessorTypeFromSize(accessor.size),\n      // @ts-ignore\n      componentType: accessor.componentType,\n      // @ts-ignore\n      count: accessor.count,\n      // @ts-ignore\n      max: accessor.max,\n      // @ts-ignore\n      min: accessor.min\n    };\n\n    this.json.accessors = this.json.accessors || [];\n    this.json.accessors.push(glTFAccessor);\n    return this.json.accessors.length - 1;\n  }\n\n  /**\n   * Add a binary buffer. Builds glTF \"JSON metadata\" and saves buffer reference\n   * Buffer will be copied into BIN chunk during \"pack\"\n   * Currently encodes buffers as glTF accessors, but this could be optimized\n   * @param sourceBuffer\n   * @param accessor\n   */\n  addBinaryBuffer(sourceBuffer: any, accessor: object = {size: 3}): number {\n    const bufferViewIndex = this.addBufferView(sourceBuffer);\n    // @ts-ignore\n    let minMax = {min: accessor.min, max: accessor.max};\n    if (!minMax.min || !minMax.max) {\n      // @ts-ignore\n      minMax = this._getAccessorMinMax(sourceBuffer, accessor.size);\n    }\n\n    const accessorDefaults = {\n      // @ts-ignore\n      size: accessor.size,\n      componentType: getComponentTypeFromArray(sourceBuffer),\n      // @ts-ignore\n      count: Math.round(sourceBuffer.length / accessor.size),\n      min: minMax.min,\n      max: minMax.max\n    };\n\n    return this.addAccessor(bufferViewIndex, Object.assign(accessorDefaults, accessor));\n  }\n\n  /**\n   * Adds a texture to the json part\n   * @todo: add more properties for texture initialization\n   * `sampler`, `name`, `extensions`, `extras`\n   * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#texture\n   */\n  addTexture(texture: {imageIndex: number}): number {\n    const {imageIndex} = texture;\n    const glTFTexture = {\n      source: imageIndex\n    };\n\n    this.json.textures = this.json.textures || [];\n    this.json.textures.push(glTFTexture);\n    return this.json.textures.length - 1;\n  }\n\n  /** Adds a material to the json part */\n  addMaterial(pbrMaterialInfo: Object): number {\n    this.json.materials = this.json.materials || [];\n    this.json.materials.push(pbrMaterialInfo);\n    return this.json.materials.length - 1;\n  }\n\n  /** Pack the binary chunk */\n  createBinaryChunk(): void {\n    // Encoder expects this array undefined or empty\n    this.gltf.buffers = [];\n\n    // Allocate total array\n    const totalByteLength = this.byteLength;\n    const arrayBuffer = new ArrayBuffer(totalByteLength);\n    const targetArray = new Uint8Array(arrayBuffer);\n\n    // Copy each array into\n    let dstByteOffset = 0;\n    for (const sourceBuffer of this.sourceBuffers || []) {\n      dstByteOffset = copyToArray(sourceBuffer, targetArray, dstByteOffset);\n    }\n\n    // Update the glTF BIN CHUNK byte length\n    if (this.json?.buffers?.[0]) {\n      this.json.buffers[0].byteLength = totalByteLength;\n    } else {\n      this.json.buffers = [{byteLength: totalByteLength}];\n    }\n\n    // Save generated arrayBuffer\n    this.gltf.binary = arrayBuffer;\n\n    // Put arrayBuffer to sourceBuffers for possible additional writing data in the chunk\n    this.sourceBuffers = [arrayBuffer];\n  }\n\n  // PRIVATE\n\n  _removeStringFromArray(array, string) {\n    let found = true;\n    while (found) {\n      const index = array.indexOf(string);\n      if (index > -1) {\n        array.splice(index, 1);\n      } else {\n        found = false;\n      }\n    }\n  }\n\n  /**\n   * Add attributes to buffers and create `attributes` object which is part of `mesh`\n   */\n  _addAttributes(attributes = {}) {\n    const result = {};\n    for (const attributeKey in attributes) {\n      const attributeData = attributes[attributeKey];\n      const attrName = this._getGltfAttributeName(attributeKey);\n      const accessor = this.addBinaryBuffer(attributeData.value, attributeData);\n      result[attrName] = accessor;\n    }\n    return result;\n  }\n\n  /**\n   * Add indices to buffers\n   */\n  _addIndices(indices) {\n    return this.addBinaryBuffer(indices, {size: 1});\n  }\n\n  /**\n   * Deduce gltf specific attribue name from input attribute name\n   */\n  _getGltfAttributeName(attributeName) {\n    switch (attributeName.toLowerCase()) {\n      case 'position':\n      case 'positions':\n      case 'vertices':\n        return 'POSITION';\n      case 'normal':\n      case 'normals':\n        return 'NORMAL';\n      case 'color':\n      case 'colors':\n        return 'COLOR_0';\n      case 'texcoord':\n      case 'texcoords':\n        return 'TEXCOORD_0';\n      default:\n        return attributeName;\n    }\n  }\n\n  /**\n   * Calculate `min` and `max` arrays of accessor according to spec:\n   * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-accessor\n   */\n  _getAccessorMinMax(buffer, size) {\n    const result = {min: null, max: null};\n    if (buffer.length < size) {\n      return result;\n    }\n    // @ts-ignore\n    result.min = [];\n    // @ts-ignore\n    result.max = [];\n    const initValues = buffer.subarray(0, size);\n    for (const value of initValues) {\n      // @ts-ignore\n      result.min.push(value);\n      // @ts-ignore\n      result.max.push(value);\n    }\n\n    for (let index = size; index < buffer.length; index += size) {\n      for (let componentIndex = 0; componentIndex < size; componentIndex++) {\n        // @ts-ignore\n        result.min[0 + componentIndex] = Math.min(\n          // @ts-ignore\n          result.min[0 + componentIndex],\n          buffer[index + componentIndex]\n        );\n        // @ts-ignore\n        result.max[0 + componentIndex] = Math.max(\n          // @ts-ignore\n          result.max[0 + componentIndex],\n          buffer[index + componentIndex]\n        );\n      }\n    }\n    return result;\n  }\n}\n", "// This file is part of meshoptimizer library and is distributed under the terms of MIT License.\n// Copyright (C) 2016-2021, by Arseny Kapoulkine (arseny.kapoulkine@gmail.com)\n\n/* eslint-disable camelcase */\nconst isWebAssemblySupported = typeof WebAssembly !== 'object';\n\n// Built with clang version 11.0.0 (https://github.com/llvm/llvm-project.git 0160ad802e899c2922bc9b29564080c22eb0908c)\n// Built from meshoptimizer 0.16\nconst wasm_base =\n  'B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB';\nconst wasm_simd =\n  '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';\n\n// Uses bulk-memory and simd extensions\nconst detector = new Uint8Array([\n  0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2,\n  12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11\n]);\n\n// Used to unpack wasm\nconst wasmpack = new Uint8Array([\n  32, 0, 65, 253, 3, 1, 2, 34, 4, 106, 6, 5, 11, 8, 7, 20, 13, 33, 12, 16, 128, 9, 116, 64, 19, 113,\n  127, 15, 10, 21, 22, 14, 255, 66, 24, 54, 136, 107, 18, 23, 192, 26, 114, 118, 132, 17, 77, 101,\n  130, 144, 27, 87, 131, 44, 45, 74, 156, 154, 70, 167\n]);\n\nconst FILTERS = {\n  // legacy index-based enums for glTF\n  0: '',\n  1: 'meshopt_decodeFilterOct',\n  2: 'meshopt_decodeFilterQuat',\n  3: 'meshopt_decodeFilterExp',\n  // string-based enums for glTF\n  NONE: '',\n  OCTAHEDRAL: 'meshopt_decodeFilterOct',\n  QUATERNION: 'meshopt_decodeFilterQuat',\n  EXPONENTIAL: 'meshopt_decodeFilterExp'\n};\n\nconst DECODERS = {\n  // legacy index-based enums for glTF\n  0: 'meshopt_decodeVertexBuffer',\n  1: 'meshopt_decodeIndexBuffer',\n  2: 'meshopt_decodeIndexSequence',\n  // string-based enums for glTF\n  ATTRIBUTES: 'meshopt_decodeVertexBuffer',\n  TRIANGLES: 'meshopt_decodeIndexBuffer',\n  INDICES: 'meshopt_decodeIndexSequence'\n};\n\nexport function isMeshoptSupported(): boolean {\n  return isWebAssemblySupported;\n}\n\nexport async function meshoptDecodeVertexBuffer(\n  target: Uint8Array,\n  count: number,\n  size: number,\n  source: Uint8Array,\n  filter: string | number = 'NONE'\n): Promise<void> {\n  const instance = await loadWasmInstance();\n  decode(\n    instance,\n    instance.exports.meshopt_decodeVertexBuffer,\n    target,\n    count,\n    size,\n    source,\n    instance.exports[FILTERS[filter]]\n  );\n}\n\nexport async function meshoptDecodeIndexBuffer(\n  target: Uint8Array,\n  count: number,\n  size: number,\n  source: Uint8Array\n): Promise<void> {\n  const instance = await loadWasmInstance();\n  decode(instance, instance.exports.meshopt_decodeIndexBuffer, target, count, size, source);\n}\n\nexport async function meshoptDecodeIndexSequence(\n  target: Uint8Array,\n  count: number,\n  size: number,\n  source: Uint8Array\n): Promise<void> {\n  const instance = await loadWasmInstance();\n  decode(instance, instance.exports.meshopt_decodeIndexSequence, target, count, size, source);\n}\n\n// eslint-disable-next-line max-params\nexport async function meshoptDecodeGltfBuffer(\n  target: Uint8Array,\n  count: number,\n  size: number,\n  source: Uint8Array,\n  mode: string,\n  filter: string | number = 'NONE'\n): Promise<void> {\n  const instance = await loadWasmInstance();\n  decode(\n    instance,\n    instance.exports[DECODERS[mode]],\n    target,\n    count,\n    size,\n    source,\n    instance.exports[FILTERS[filter || 'NONE']]\n  );\n}\n\nlet wasmPromise: Promise<WebAssembly.Instance>;\n\nasync function loadWasmInstance(): Promise<WebAssembly.Instance> {\n  // eslint-disable-next-line\n  if (!wasmPromise) {\n    wasmPromise = loadWasmModule();\n  }\n  return wasmPromise;\n}\n\nasync function loadWasmModule(): Promise<WebAssembly.Instance> {\n  let wasm = wasm_base;\n  if (WebAssembly.validate(detector)) {\n    wasm = wasm_simd;\n\n    // eslint-disable-next-line no-console\n    console.log('Warning: meshopt_decoder is using experimental SIMD support');\n  }\n\n  const result = await WebAssembly.instantiate(unpack(wasm), {});\n  await (result.instance.exports as any).__wasm_call_ctors();\n  return result.instance;\n}\n\nfunction unpack(data) {\n  const result = new Uint8Array(data.length);\n  for (let i = 0; i < data.length; ++i) {\n    const ch = data.charCodeAt(i);\n    result[i] = ch > 96 ? ch - 71 : ch > 64 ? ch - 65 : ch > 47 ? ch + 4 : ch > 46 ? 63 : 62;\n  }\n  let write = 0;\n  for (let i = 0; i < data.length; ++i) {\n    result[write++] = result[i] < 60 ? wasmpack[result[i]] : (result[i] - 60) * 64 + result[++i];\n  }\n  return result.buffer.slice(0, write);\n}\n\n// eslint-disable-next-line max-params\nfunction decode(instance, fun, target, count, size, source, filter?) {\n  const sbrk = instance.exports.sbrk;\n  const count4 = (count + 3) & ~3; // pad for SIMD filter\n  const tp = sbrk(count4 * size);\n  const sp = sbrk(source.length);\n  const heap = new Uint8Array(instance.exports.memory.buffer);\n  heap.set(source, sp);\n  const res = fun(tp, count, size, sp, source.length);\n  if (res === 0 && filter) {\n    filter(tp, count4, size);\n  }\n  target.set(heap.subarray(tp, tp + count * size));\n  sbrk(tp - sbrk(0));\n  if (res !== 0) {\n    throw new Error(`Malformed buffer data: ${res}`);\n  }\n}\n", "/* eslint-disable camelcase */\nimport type {GLTF, GLTFBufferView, GLTF_EXT_meshopt_compression} from '../types/gltf-types';\nimport type {GLTFLoaderOptions} from '../../gltf-loader';\nimport GLTFScenegraph from '../api/gltf-scenegraph';\nimport {meshoptDecodeGltfBuffer} from '../../meshopt/meshopt-decoder';\n\n// @ts-ignore\n// eslint-disable-next-line\nconst DEFAULT_MESHOPT_OPTIONS = {\n  byteOffset: 0,\n  filter: 'NONE'\n};\n\n/** Extension name */\nconst EXT_MESHOPT_COMPRESSION = 'EXT_meshopt_compression';\n\nexport const name = EXT_MESHOPT_COMPRESSION;\n\nexport async function decode(gltfData: {json: GLTF}, options: GLTFLoaderOptions) {\n  const scenegraph = new GLTFScenegraph(gltfData);\n\n  if (!options?.gltf?.decompressMeshes) {\n    return;\n  }\n\n  const promises: Promise<any>[] = [];\n  for (const bufferViewIndex of gltfData.json.bufferViews || []) {\n    promises.push(decodeMeshoptBufferView(scenegraph, bufferViewIndex));\n  }\n\n  // Decompress meshes in parallel\n  await Promise.all(promises);\n\n  // We have now decompressed all primitives, so remove the top-level extension\n  scenegraph.removeExtension(EXT_MESHOPT_COMPRESSION);\n}\n\n/** Decode one meshopt buffer view */\nasync function decodeMeshoptBufferView(\n  scenegraph: GLTFScenegraph,\n  bufferView: GLTFBufferView\n): Promise<ArrayBuffer | null> {\n  const meshoptExtension = scenegraph.getObjectExtension<GLTF_EXT_meshopt_compression>(\n    bufferView,\n    EXT_MESHOPT_COMPRESSION\n  );\n  if (meshoptExtension) {\n    const {\n      byteOffset = 0,\n      byteLength = 0,\n      byteStride,\n      count,\n      mode,\n      filter = 'NONE',\n      buffer: bufferIndex\n    } = meshoptExtension;\n    const buffer = scenegraph.gltf.buffers[bufferIndex];\n\n    const source = new Uint8Array(buffer.arrayBuffer, buffer.byteOffset + byteOffset, byteLength);\n    const result = new Uint8Array(\n      scenegraph.gltf.buffers[bufferView.buffer].arrayBuffer,\n      bufferView.byteOffset,\n      bufferView.byteLength\n    );\n    await meshoptDecodeGltfBuffer(result, count, byteStride, source, mode, filter);\n    return result;\n  }\n\n  return null;\n}\n", "// GLTF EXTENSION: EXT_TEXTURE_WEBP\n// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/EXT_TEXTURE_WEBP\n/* eslint-disable camelcase */\n\nimport type {GLTF, GLTF_EXT_texture_webp} from '../types/gltf-types';\nimport type {GLTFLoaderOptions} from '../../gltf-loader';\n\nimport {_isImageFormatSupported} from '@loaders.gl/images';\nimport GLTFScenegraph from '../api/gltf-scenegraph';\n\nconst EXT_TEXTURE_WEBP = 'EXT_texture_webp';\n\n/** Extension name */\nexport const name = EXT_TEXTURE_WEBP;\n\n/**\n * Replaces a texture source reference with the extension texture\n * Done in preprocess() to prevent load of default image\n */\nexport function preprocess(gltfData: {json: GLTF}, options: GLTFLoaderOptions): void {\n  const scenegraph = new GLTFScenegraph(gltfData);\n\n  if (!_isImageFormatSupported('image/webp')) {\n    if (scenegraph.getRequiredExtensions().includes(EXT_TEXTURE_WEBP)) {\n      throw new Error(`gltf: Required extension ${EXT_TEXTURE_WEBP} not supported by browser`);\n    }\n    return;\n  }\n\n  const {json} = scenegraph;\n\n  for (const texture of json.textures || []) {\n    const extension = scenegraph.getObjectExtension<GLTF_EXT_texture_webp>(\n      texture,\n      EXT_TEXTURE_WEBP\n    );\n    if (extension) {\n      // TODO - if multiple texture extensions are present which one wins?\n      texture.source = extension.source;\n    }\n    scenegraph.removeObjectExtension(texture, EXT_TEXTURE_WEBP);\n  }\n\n  // Remove the top-level extension\n  scenegraph.removeExtension(EXT_TEXTURE_WEBP);\n}\n", "// GLTF EXTENSION: KHR_texture_basisu\n// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_texture_basisu\n/* eslint-disable camelcase */\n\nimport type {GLTF, GLTF_KHR_texture_basisu} from '../types/gltf-types';\nimport type {GLTFLoaderOptions} from '../../gltf-loader';\n\nimport GLTFScenegraph from '../api/gltf-scenegraph';\n\nconst KHR_TEXTURE_BASISU = 'KHR_texture_basisu';\n\n/** Extension name */\nexport const name = KHR_TEXTURE_BASISU;\n\n/**\n * Replaces a texture source reference with the extension texture\n * Done in preprocess() to prevent load of default image\n */\nexport function preprocess(gltfData: {json: GLTF}, options: GLTFLoaderOptions): void {\n  const scene = new GLTFScenegraph(gltfData);\n  const {json} = scene;\n\n  for (const texture of json.textures || []) {\n    const extension = scene.getObjectExtension<GLTF_KHR_texture_basisu>(\n      texture,\n      KHR_TEXTURE_BASISU\n    );\n    if (extension) {\n      // TODO - if multiple texture extensions are present which one wins?\n      texture.source = extension.source;\n    }\n    scene.removeObjectExtension(texture, KHR_TEXTURE_BASISU);\n  }\n\n  // Remove the top-level extension\n  scene.removeExtension(KHR_TEXTURE_BASISU);\n}\n", "// Version constant cannot be imported, it needs to correspond to the build version of **this** module.\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nexport const VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'latest';\n", "import type {Loader, LoaderOptions} from '@loaders.gl/loader-utils';\nimport {isBrowser} from '@loaders.gl/worker-utils';\nimport type {DracoParseOptions} from './lib/draco-parser';\n// import type {DracoMeshData} from './types';\nimport {VERSION} from './lib/utils/version';\n\nexport type DracoLoaderOptions = LoaderOptions & {\n  draco?: DracoParseOptions & {\n    decoderType?: 'wasm' | 'js';\n    libraryPath?: string;\n    extraAttributes?;\n    attributeNameEntry?: string;\n    workerUrl?: string;\n  };\n};\n\nconst DEFAULT_DRACO_OPTIONS: DracoLoaderOptions = {\n  draco: {\n    decoderType: typeof WebAssembly === 'object' ? 'wasm' : 'js', // 'js' for IE11\n    libraryPath: 'libs/',\n    extraAttributes: {},\n    attributeNameEntry: undefined\n  }\n};\n\n/**\n * Worker loader for Draco3D compressed geometries\n */\nexport const DracoLoader = {\n  name: 'Draco',\n  id: isBrowser ? 'draco' : 'draco-nodejs',\n  module: 'draco',\n  shapes: ['mesh'],\n  version: VERSION,\n  worker: true,\n  extensions: ['drc'],\n  mimeTypes: ['application/octet-stream'],\n  binary: true,\n  tests: ['DRACO'],\n  options: DEFAULT_DRACO_OPTIONS\n};\n\nexport const _TypecheckDracoLoader: Loader = DracoLoader;\n", "import type {Schema} from '../schema/schema';\nimport type {TableBatch} from '../../category/table/table-types';\nimport {TableBatchAggregator, TableBatchOptions} from './table-batch-aggregator';\n\nconst DEFAULT_ROW_COUNT = 100;\n\nexport default class RowTableBatchAggregator implements TableBatchAggregator {\n  schema: Schema;\n  options: TableBatchOptions;\n\n  length: number = 0;\n  rows: any[] | null = null;\n  cursor: number = 0;\n  private _headers: string[] = [];\n\n  constructor(schema: Schema, options: TableBatchOptions) {\n    this.options = options;\n    this.schema = schema;\n\n    // schema is an array if there're no headers\n    // object if there are headers\n    if (!Array.isArray(schema)) {\n      this._headers = [];\n      for (const key in schema) {\n        this._headers[schema[key].index] = schema[key].name;\n      }\n    }\n  }\n\n  rowCount(): number {\n    return this.length;\n  }\n\n  addArrayRow(row: any[], cursor?: number): void {\n    if (Number.isFinite(cursor)) {\n      this.cursor = cursor as number;\n    }\n\n    this.rows = this.rows || new Array(DEFAULT_ROW_COUNT);\n    this.rows[this.length] = row;\n    this.length++;\n  }\n\n  addObjectRow(row: {[columnName: string]: any}, cursor?: number): void {\n    if (Number.isFinite(cursor)) {\n      this.cursor = cursor as number;\n    }\n\n    this.rows = this.rows || new Array(DEFAULT_ROW_COUNT);\n    this.rows[this.length] = row;\n    this.length++;\n  }\n\n  getBatch(): TableBatch | null {\n    let rows = this.rows;\n    if (!rows) {\n      return null;\n    }\n\n    rows = rows.slice(0, this.length);\n    this.rows = null;\n\n    const batch: TableBatch = {\n      shape: this.options.shape,\n      batchType: 'data',\n      data: rows,\n      length: this.length,\n      schema: this.schema,\n      cursor: this.cursor\n    };\n\n    return batch;\n  }\n}\n", "/** Convert an object row to an array row */\nexport function convertToObjectRow(\n  arrayRow: any[],\n  headers: string[]\n): {[columnName: string]: any} {\n  if (!arrayRow) {\n    throw new Error('null row');\n  }\n  if (!headers) {\n    throw new Error('no headers');\n  }\n  const objectRow = {};\n  for (let i = 0; i < headers.length; i++) {\n    objectRow[headers[i]] = arrayRow[i];\n  }\n  return objectRow;\n}\n\n/** Convert an object row to an array row */\nexport function convertToArrayRow(\n  objectRow: {[columnName: string]: any},\n  headers: string[]\n): any[] {\n  if (!objectRow) {\n    throw new Error('null row');\n  }\n  if (!headers) {\n    throw new Error('no headers');\n  }\n  const arrayRow = new Array(headers.length);\n  for (let i = 0; i < headers.length; i++) {\n    arrayRow[i] = objectRow[headers[i]];\n  }\n  return arrayRow;\n}\n", "import type {Schema} from '../schema/schema';\nimport type {TableBatch} from '../../category/table/table-types';\n// import type {ArrayRowTableBatch, ObjectRowTableBatch} from '../../category/table';\nimport {convertToArrayRow, convertToObjectRow} from '../utils/row-utils';\nimport {TableBatchAggregator, TableBatchOptions} from './table-batch-aggregator';\n\nconst DEFAULT_ROW_COUNT = 100;\n\nexport default class RowTableBatchAggregator implements TableBatchAggregator {\n  schema: Schema;\n  options: TableBatchOptions;\n\n  length: number = 0;\n  objectRows: {[columnName: string]: any} | null = null;\n  arrayRows: any[] | null = null;\n  cursor: number = 0;\n  private _headers: string[] = [];\n\n  constructor(schema: Schema, options: TableBatchOptions) {\n    this.options = options;\n    this.schema = schema;\n\n    // schema is an array if there're no headers\n    // object if there are headers\n    if (!Array.isArray(schema)) {\n      this._headers = [];\n      for (const key in schema) {\n        this._headers[schema[key].index] = schema[key].name;\n      }\n    }\n  }\n\n  rowCount(): number {\n    return this.length;\n  }\n\n  addArrayRow(row: any[], cursor?: number): void {\n    if (Number.isFinite(cursor)) {\n      this.cursor = cursor as number;\n    }\n\n    // eslint-disable-next-line default-case\n    switch (this.options.shape) {\n      case 'object-row-table':\n        const rowObject = convertToObjectRow(row, this._headers);\n        this.addObjectRow(rowObject, cursor);\n        break;\n      case 'array-row-table':\n        this.arrayRows = this.arrayRows || new Array(DEFAULT_ROW_COUNT);\n        this.arrayRows[this.length] = row;\n        this.length++;\n        break;\n    }\n  }\n\n  addObjectRow(row: {[columnName: string]: any}, cursor?: number): void {\n    if (Number.isFinite(cursor)) {\n      this.cursor = cursor as number;\n    }\n\n    // eslint-disable-next-line default-case\n    switch (this.options.shape) {\n      case 'array-row-table':\n        const rowArray = convertToArrayRow(row, this._headers);\n        this.addArrayRow(rowArray, cursor);\n        break;\n      case 'object-row-table':\n        this.objectRows = this.objectRows || new Array(DEFAULT_ROW_COUNT);\n        this.objectRows[this.length] = row;\n        this.length++;\n        break;\n    }\n  }\n\n  getBatch(): TableBatch | null {\n    let rows = this.arrayRows || this.objectRows;\n    if (!rows) {\n      return null;\n    }\n\n    rows = rows.slice(0, this.length);\n    this.arrayRows = null;\n    this.objectRows = null;\n\n    return {\n      shape: this.options.shape,\n      batchType: 'data',\n      data: rows,\n      length: this.length,\n      schema: this.schema,\n      cursor: this.cursor\n    };\n  }\n}\n", "import type {Schema} from '../schema/schema';\nimport type {ColumnarTableBatch, ArrowTableBatch} from '../../category/table/table-types';\nimport {TableBatchAggregator} from './table-batch-aggregator';\n\ntype ColumnarTableBatchOptions = {};\n\nconst DEFAULT_ROW_COUNT = 100;\n\nexport default class ColumnarTableBatchAggregator implements TableBatchAggregator {\n  schema: Schema;\n  length: number = 0;\n  allocated: number = 0;\n  columns: {[columnName: string]: any[]} = {};\n\n  constructor(schema: Schema, options: ColumnarTableBatchOptions) {\n    this.schema = schema;\n    this._reallocateColumns();\n  }\n\n  rowCount(): number {\n    return this.length;\n  }\n\n  addArrayRow(row: any[]) {\n    // If user keeps pushing rows beyond batch size, reallocate\n    this._reallocateColumns();\n    let i = 0;\n    // TODO what if no csv header, columns not populated?\n    for (const fieldName in this.columns) {\n      this.columns[fieldName][this.length] = row[i++];\n    }\n    this.length++;\n  }\n\n  addObjectRow(row: {[columnName: string]: any}): void {\n    // If user keeps pushing rows beyond batch size, reallocate\n    this._reallocateColumns();\n    for (const fieldName in row) {\n      this.columns[fieldName][this.length] = row[fieldName];\n    }\n    this.length++;\n  }\n\n  getBatch(): ColumnarTableBatch | ArrowTableBatch | null {\n    this._pruneColumns();\n    const columns = Array.isArray(this.schema) ? this.columns : {};\n\n    // schema is an array if there're no headers\n    // object if there are headers\n    // columns should match schema format\n    if (!Array.isArray(this.schema)) {\n      for (const fieldName in this.schema) {\n        const field = this.schema[fieldName];\n        columns[field.name] = this.columns[field.index];\n      }\n    }\n\n    this.columns = {};\n\n    const batch: ColumnarTableBatch = {\n      shape: 'columnar-table',\n      batchType: 'data',\n      data: columns,\n      schema: this.schema,\n      length: this.length\n    };\n\n    return batch;\n  }\n\n  // HELPERS\n\n  _reallocateColumns() {\n    if (this.length < this.allocated) {\n      return;\n    }\n\n    // @ts-ignore TODO\n    this.allocated = this.allocated > 0 ? (this.allocated *= 2) : DEFAULT_ROW_COUNT;\n    this.columns = {};\n\n    for (const fieldName in this.schema) {\n      const field = this.schema[fieldName];\n      const ArrayType = field.type || Float32Array;\n      const oldColumn = this.columns[field.index];\n\n      if (oldColumn && ArrayBuffer.isView(oldColumn)) {\n        // Copy the old data to the new array\n        const typedArray = new ArrayType(this.allocated);\n        typedArray.set(oldColumn);\n        this.columns[field.index] = typedArray;\n      } else if (oldColumn) {\n        // Plain array\n        oldColumn.length = this.allocated;\n        this.columns[field.index] = oldColumn;\n      } else {\n        // Create new\n        this.columns[field.index] = new ArrayType(this.allocated);\n      }\n    }\n  }\n\n  _pruneColumns() {\n    for (const [columnName, column] of Object.entries(this.columns)) {\n      this.columns[columnName] = column.slice(0, this.length);\n    }\n  }\n}\n", "import type {Schema} from '../schema/schema';\nimport type {TableBatch} from '../../category/table/table-types';\nimport type {TableBatchAggregator, TableBatchConstructor} from './table-batch-aggregator';\nimport BaseTableBatchAggregator from './base-table-batch-aggregator';\nimport RowTableBatchAggregator from './row-table-batch-aggregator';\nimport ColumnarTableBatchAggregator from './columnar-table-batch-aggregator';\n\n// TODO define interface instead\ntype TableBatchBuilderOptions = {\n  shape: 'row-table' | 'array-row-table' | 'object-row-table' | 'columnar-table' | 'arrow-table';\n  batchSize?: number | 'auto';\n  batchDebounceMs?: number;\n  limit: number;\n  _limitMB: number;\n};\n\ntype GetBatchOptions = {\n  bytesUsed?: number;\n  [key: string]: any;\n};\n\nconst DEFAULT_OPTIONS: Required<TableBatchBuilderOptions> = {\n  shape: 'array-row-table',\n  batchSize: 'auto',\n  batchDebounceMs: 0,\n  limit: 0,\n  _limitMB: 0\n};\n\nconst ERR_MESSAGE = 'TableBatchBuilder';\n\n/** Incrementally builds batches from a stream of rows */\nexport default class TableBatchBuilder {\n  schema: Schema;\n  options: Required<TableBatchBuilderOptions>;\n\n  private aggregator: TableBatchAggregator | null = null;\n  private batchCount: number = 0;\n  private bytesUsed: number = 0;\n  private isChunkComplete: boolean = false;\n  private lastBatchEmittedMs: number = Date.now();\n  private totalLength: number = 0;\n  private totalBytes: number = 0;\n  private rowBytes: number = 0;\n\n  static ArrowBatch?: TableBatchConstructor;\n\n  constructor(schema: Schema, options?: TableBatchBuilderOptions) {\n    this.schema = schema;\n    this.options = {...DEFAULT_OPTIONS, ...options};\n  }\n\n  limitReached(): boolean {\n    if (Boolean(this.options?.limit) && this.totalLength >= this.options.limit) {\n      return true;\n    }\n    if (Boolean(this.options?._limitMB) && this.totalBytes / 1e6 >= this.options._limitMB) {\n      return true;\n    }\n    return false;\n  }\n\n  /** @deprecated Use addArrayRow or addObjectRow */\n  addRow(row: any[] | {[columnName: string]: any}): void {\n    if (this.limitReached()) {\n      return;\n    }\n    this.totalLength++;\n    this.rowBytes = this.rowBytes || this._estimateRowMB(row);\n    this.totalBytes += this.rowBytes;\n    if (Array.isArray(row)) {\n      this.addArrayRow(row);\n    } else {\n      this.addObjectRow(row);\n    }\n  }\n\n  /** Add one row to the batch */\n  protected addArrayRow(row: any[]) {\n    if (!this.aggregator) {\n      const TableBatchType = this._getTableBatchType();\n      this.aggregator = new TableBatchType(this.schema, this.options);\n    }\n    this.aggregator.addArrayRow(row);\n  }\n\n  /** Add one row to the batch */\n  protected addObjectRow(row: {[columnName: string]: any}): void {\n    if (!this.aggregator) {\n      const TableBatchType = this._getTableBatchType();\n      this.aggregator = new TableBatchType(this.schema, this.options);\n    }\n    this.aggregator.addObjectRow(row);\n  }\n\n  /** Mark an incoming raw memory chunk has completed */\n  chunkComplete(chunk: ArrayBuffer | string): void {\n    if (chunk instanceof ArrayBuffer) {\n      this.bytesUsed += chunk.byteLength;\n    }\n    if (typeof chunk === 'string') {\n      this.bytesUsed += chunk.length;\n    }\n    this.isChunkComplete = true;\n  }\n\n  getFullBatch(options?: GetBatchOptions): TableBatch | null {\n    return this._isFull() ? this._getBatch(options) : null;\n  }\n\n  getFinalBatch(options?: GetBatchOptions): TableBatch | null {\n    return this._getBatch(options);\n  }\n\n  // INTERNAL\n\n  _estimateRowMB(row: any[] | object): number {\n    return Array.isArray(row) ? row.length * 8 : Object.keys(row).length * 8;\n  }\n\n  private _isFull(): boolean {\n    // No batch, not ready\n    if (!this.aggregator || this.aggregator.rowCount() === 0) {\n      return false;\n    }\n\n    // if batchSize === 'auto' we wait for chunk to complete\n    // if batchSize === number, ensure we have enough rows\n    if (this.options.batchSize === 'auto') {\n      if (!this.isChunkComplete) {\n        return false;\n      }\n    } else if (this.options.batchSize > this.aggregator.rowCount()) {\n      return false;\n    }\n\n    // Debounce batches\n    if (this.options.batchDebounceMs > Date.now() - this.lastBatchEmittedMs) {\n      return false;\n    }\n\n    // Emit batch\n    this.isChunkComplete = false;\n    this.lastBatchEmittedMs = Date.now();\n    return true;\n  }\n\n  /**\n   * bytesUsed can be set via chunkComplete or via getBatch*\n   */\n  private _getBatch(options?: GetBatchOptions): TableBatch | null {\n    if (!this.aggregator) {\n      return null;\n    }\n\n    // TODO - this can overly increment bytes used?\n    if (options?.bytesUsed) {\n      this.bytesUsed = options.bytesUsed;\n    }\n    const normalizedBatch = this.aggregator.getBatch() as TableBatch;\n    normalizedBatch.count = this.batchCount;\n    normalizedBatch.bytesUsed = this.bytesUsed;\n    Object.assign(normalizedBatch, options);\n\n    this.batchCount++;\n    this.aggregator = null;\n    return normalizedBatch;\n  }\n\n  private _getTableBatchType(): TableBatchConstructor {\n    switch (this.options.shape) {\n      case 'row-table':\n        return BaseTableBatchAggregator;\n      case 'array-row-table':\n      case 'object-row-table':\n        return RowTableBatchAggregator;\n      case 'columnar-table':\n        return ColumnarTableBatchAggregator;\n      case 'arrow-table':\n        if (!TableBatchBuilder.ArrowBatch) {\n          throw new Error(ERR_MESSAGE);\n        }\n        return TableBatchBuilder.ArrowBatch;\n      default:\n        throw new Error(ERR_MESSAGE);\n    }\n  }\n}\n", "// Mesh category utilities\n// TODO - move to mesh category module, or to math.gl/geometry module\nimport {TypedArray} from '../../types';\nimport {MeshAttributes} from './mesh-types';\n\ntype TypedArrays = {[key: string]: TypedArray};\n\n/**\n * Holds an axis aligned bounding box\n * TODO - make sure AxisAlignedBoundingBox in math.gl/culling understands this format (or change this format)\n */\ntype BoundingBox = [[number, number, number], [number, number, number]];\n\n/**\n * Get number of vertices in mesh\n * @param attributes\n */\nexport function getMeshSize(attributes: TypedArrays): number {\n  let size = 0;\n  for (const attributeName in attributes) {\n    const attribute = attributes[attributeName];\n    if (ArrayBuffer.isView(attribute)) {\n      // @ts-ignore DataView doesn't have BYTES_PER_ELEMENT\n      size += attribute.byteLength * attribute.BYTES_PER_ELEMENT;\n    }\n  }\n  return size;\n}\n\n/**\n * Get the (axis aligned) bounding box of a mesh\n * @param attributes\n * @returns array of two vectors representing the axis aligned bounding box\n */\n// eslint-disable-next-line complexity\nexport function getMeshBoundingBox(attributes: MeshAttributes): BoundingBox {\n  let minX = Infinity;\n  let minY = Infinity;\n  let minZ = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n  let maxZ = -Infinity;\n\n  const positions = attributes.POSITION ? attributes.POSITION.value : [];\n  const len = positions && positions.length;\n\n  for (let i = 0; i < len; i += 3) {\n    const x = positions[i];\n    const y = positions[i + 1];\n    const z = positions[i + 2];\n\n    minX = x < minX ? x : minX;\n    minY = y < minY ? y : minY;\n    minZ = z < minZ ? z : minZ;\n\n    maxX = x > maxX ? x : maxX;\n    maxY = y > maxY ? y : maxY;\n    maxZ = z > maxZ ? z : maxZ;\n  }\n  return [\n    [minX, minY, minZ],\n    [maxX, maxY, maxZ]\n  ];\n}\n", "// Replacement for the external assert method to reduce bundle size\n// Note: We don't use the second \"message\" argument in calling code,\n// so no need to support it here\nexport function assert(condition: boolean, message?: string) {\n  if (!condition) {\n    throw new Error(message || 'loader assertion failed.');\n  }\n}\n", "import {assert} from '../../utils/assert';\nimport Field from './field';\n\nexport type SchemaMetadata = Map<string, any>;\n\n/**\n * ArrowJS `Schema` API-compatible class for row-based tables (returned from `DataTable`)\n * https://loaders.gl/arrowjs/docs/api-reference/schema\n */\nexport default class Schema {\n  fields: Field[];\n  // TODO - Arrow just allows Map<string, string>\n  metadata: SchemaMetadata;\n\n  constructor(fields: Field[], metadata?: SchemaMetadata) {\n    assert(Array.isArray(fields));\n    checkNames(fields);\n    // For kepler fields, create arrow compatible `Fields` that have kepler fields as `metadata`\n    this.fields = fields;\n    this.metadata = metadata || new Map();\n  }\n\n  // TODO - arrow only seems to compare fields, not metadata\n  compareTo(other: Schema): boolean {\n    if (this.metadata !== other.metadata) {\n      return false;\n    }\n    if (this.fields.length !== other.fields.length) {\n      return false;\n    }\n    for (let i = 0; i < this.fields.length; ++i) {\n      if (!this.fields[i].compareTo(other.fields[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  select(...columnNames: string[]): Schema {\n    // Ensure column names reference valid fields\n    const nameMap = Object.create(null);\n    for (const name of columnNames) {\n      nameMap[name] = true;\n    }\n    const selectedFields = this.fields.filter((field) => nameMap[field.name]);\n    return new Schema(selectedFields, this.metadata);\n  }\n\n  selectAt(...columnIndices: number[]): Schema {\n    // Ensure column indices reference valid fields\n    const selectedFields = columnIndices.map((index) => this.fields[index]).filter(Boolean);\n    return new Schema(selectedFields, this.metadata);\n  }\n\n  assign(schemaOrFields: Schema | Field[]): Schema {\n    let fields: Field[];\n    let metadata: SchemaMetadata = this.metadata;\n\n    if (schemaOrFields instanceof Schema) {\n      const otherSchema = schemaOrFields;\n      fields = otherSchema.fields;\n      metadata = mergeMaps(mergeMaps(new Map(), this.metadata), otherSchema.metadata);\n    } else {\n      fields = schemaOrFields;\n    }\n\n    // Create a merged list of fields, overwrite fields in place, new fields at end\n    const fieldMap: {[key: string]: Field} = Object.create(null);\n\n    for (const field of this.fields) {\n      fieldMap[field.name] = field;\n    }\n\n    for (const field of fields) {\n      fieldMap[field.name] = field;\n    }\n\n    const mergedFields = Object.values(fieldMap);\n\n    return new Schema(mergedFields, metadata);\n  }\n}\n\n// Warn if any duplicated field names\nfunction checkNames(fields: Field[]): void {\n  const usedNames: Record<string, boolean> = {};\n  for (const field of fields) {\n    if (usedNames[field.name]) {\n      // eslint-disable-next-line\n      console.warn('Schema: duplicated field name', field.name, field);\n    }\n    usedNames[field.name] = true;\n  }\n}\n\nfunction mergeMaps<T>(m1: T, m2: T): T {\n  // @ts-ignore\n  return new Map([...(m1 || new Map()), ...(m2 || new Map())]);\n}\n", "import {DataType} from './type';\n\n/**\n * ArrowJS `Field` API-compatible class for row-based tables\n * https://loaders.gl/arrowjs/docs/api-reference/field\n * A field holds name, nullable, and metadata information about a table \"column\"\n * A Schema is essentially a list of fields\n */\nexport default class Field {\n  name: string;\n  type: DataType;\n  nullable: boolean;\n  metadata: Map<string, string>;\n\n  constructor(\n    name: string,\n    type: DataType,\n    nullable = false,\n    metadata: Map<string, string> = new Map()\n  ) {\n    this.name = name;\n    this.type = type;\n    this.nullable = nullable;\n    this.metadata = metadata;\n  }\n\n  get typeId(): number {\n    return this.type && this.type.typeId;\n  }\n\n  clone(): Field {\n    return new Field(this.name, this.type, this.nullable, this.metadata);\n  }\n\n  compareTo(other: this): boolean {\n    return (\n      this.name === other.name &&\n      this.type === other.type &&\n      this.nullable === other.nullable &&\n      this.metadata === other.metadata\n    );\n  }\n\n  toString(): string {\n    return `${this.type}${this.nullable ? ', nullable' : ''}${\n      this.metadata ? `, metadata: ${this.metadata}` : ''\n    }`;\n  }\n}\n", "// This code is adapted from ArrowJS https://github.com/apache/arrow\n// under Apache license http://www.apache.org/licenses/LICENSE-2.0\n\n/**\n * Main data type enumeration.\n *\n * Data types in this library are all *logical*. They can be expressed as\n * either a primitive physical type (bytes or bits of some fixed size), a\n * nested type consisting of other data types, or another data type (e.g. a\n * timestamp encoded as an int64).\n *\n * **Note**: Only enum values 0-17 (NONE through Map) are written to an Arrow\n * IPC payload.\n *\n * The rest of the values are specified here so TypeScript can narrow the type\n * signatures further beyond the base Arrow Types. The Arrow DataTypes include\n * metadata like `bitWidth` that impact the type signatures of the values we\n * accept and return.\n *\n * For example, the `Int8Vector` reads 1-byte numbers from an `Int8Array`, an\n * `Int32Vector` reads a 4-byte number from an `Int32Array`, and an `Int64Vector`\n * reads a pair of 4-byte lo, hi 32-bit integers as a zero-copy slice from the\n * underlying `Int32Array`.\n *\n * Library consumers benefit by knowing the narrowest type, since we can ensure\n * the types across all public methods are propagated, and never bail to `any`.\n * These values are _never_ used at runtime, and they will _never_ be written\n * to the flatbuffers metadata of serialized Arrow IPC payloads.\n */\nexport enum Type {\n  /** The default placeholder type */\n  NONE = 0,\n  /** A NULL type having no physical storage */\n  Null = 1,\n  /** Signed or unsigned 8, 16, 32, or 64-bit little-endian integer */\n  Int = 2,\n  /** 2, 4, or 8-byte floating point value */\n  Float = 3,\n  /** Variable-length bytes (no guarantee of UTF8-ness) */\n  Binary = 4,\n  /** UTF8 variable-length string as List<Char> */\n  Utf8 = 5,\n  /** Boolean as 1 bit, LSB bit-packed ordering */\n  Bool = 6,\n  /** Precision-and-scale-based decimal type. Storage type depends on the parameters. */\n  Decimal = 7,\n  /** int32_t days or int64_t milliseconds since the UNIX epoch */\n  Date = 8,\n  /** Time as signed 32 or 64-bit integer, representing either seconds, milliseconds, microseconds, or nanoseconds since midnight since midnight */\n  Time = 9,\n  /** Exact timestamp encoded with int64 since UNIX epoch (Default unit millisecond) */\n  Timestamp = 10,\n  /** YEAR_MONTH or DAY_TIME interval in SQL style */\n  Interval = 11,\n  /** A list of some logical data type */\n  List = 12,\n  /** Struct of logical types */\n  Struct = 13,\n  /** Union of logical types */\n  Union = 14,\n  /** Fixed-size binary. Each value occupies the same number of bytes */\n  FixedSizeBinary = 15,\n  /** Fixed-size list. Each value occupies the same number of bytes */\n  FixedSizeList = 16,\n  /** Map of named logical types */\n  Map = 17,\n\n  /** Dictionary aka Category type */\n  Dictionary = -1,\n  Int8 = -2,\n  Int16 = -3,\n  Int32 = -4,\n  Int64 = -5,\n  Uint8 = -6,\n  Uint16 = -7,\n  Uint32 = -8,\n  Uint64 = -9,\n  Float16 = -10,\n  Float32 = -11,\n  Float64 = -12,\n  DateDay = -13,\n  DateMillisecond = -14,\n  TimestampSecond = -15,\n  TimestampMillisecond = -16,\n  TimestampMicrosecond = -17,\n  TimestampNanosecond = -18,\n  TimeSecond = -19,\n  TimeMillisecond = -20,\n  TimeMicrosecond = -21,\n  TimeNanosecond = -22,\n  DenseUnion = -23,\n  SparseUnion = -24,\n  IntervalDayTime = -25,\n  IntervalYearMonth = -26\n}\n", "// This code is adapted from ArrowJS https://github.com/apache/arrow\n// under Apache license http://www.apache.org/licenses/LICENSE-2.0\n\nimport {Type} from './enum';\n\nimport Field from './field';\n\nexport {Type} from './enum';\n\nexport type TypedIntArray =\n  | Int8Array\n  | Uint8Array\n  | Int16Array\n  | Uint16Array\n  | Int32Array\n  | Uint32Array\n  | Int32Array\n  | Uint32Array\n  | Uint8ClampedArray;\n\nexport type TypedFloatArray = Float32Array | Float64Array;\n\nexport type TypedArray = TypedIntArray | TypedFloatArray;\n\nexport type AnyArrayType = Array<any> | TypedIntArray | TypedFloatArray;\n\nexport class DataType {\n  static isNull(x: any): boolean {\n    return x && x.typeId === Type.Null;\n  }\n  static isInt(x: any): boolean {\n    return x && x.typeId === Type.Int;\n  }\n  static isFloat(x: any): boolean {\n    return x && x.typeId === Type.Float;\n  }\n  static isBinary(x: any): boolean {\n    return x && x.typeId === Type.Binary;\n  }\n  static isUtf8(x: any): boolean {\n    return x && x.typeId === Type.Utf8;\n  }\n  static isBool(x: any): boolean {\n    return x && x.typeId === Type.Bool;\n  }\n  static isDecimal(x: any): boolean {\n    return x && x.typeId === Type.Decimal;\n  }\n  static isDate(x: any): boolean {\n    return x && x.typeId === Type.Date;\n  }\n  static isTime(x: any): boolean {\n    return x && x.typeId === Type.Time;\n  }\n  static isTimestamp(x: any): boolean {\n    return x && x.typeId === Type.Timestamp;\n  }\n  static isInterval(x: any): boolean {\n    return x && x.typeId === Type.Interval;\n  }\n  static isList(x: any): boolean {\n    return x && x.typeId === Type.List;\n  }\n  static isStruct(x: any): boolean {\n    return x && x.typeId === Type.Struct;\n  }\n  static isUnion(x: any): boolean {\n    return x && x.typeId === Type.Union;\n  }\n  static isFixedSizeBinary(x: any): boolean {\n    return x && x.typeId === Type.FixedSizeBinary;\n  }\n  static isFixedSizeList(x: any): boolean {\n    return x && x.typeId === Type.FixedSizeList;\n  }\n  static isMap(x: any): boolean {\n    return x && x.typeId === Type.Map;\n  }\n  static isDictionary(x: any): boolean {\n    return x && x.typeId === Type.Dictionary;\n  }\n\n  get typeId(): Type {\n    return Type.NONE;\n  }\n\n  // get ArrayType(): AnyArrayType {\n  //   return Int8Array;\n  // }\n\n  // get ArrayType() { return Array; }\n  compareTo(other: DataType): boolean {\n    // TODO\n    return this === other; // comparer.visit(this, other);\n  }\n}\n\n// NULL\n\nexport class Null extends DataType {\n  get typeId(): Type {\n    return Type.Null;\n  }\n  get [Symbol.toStringTag](): string {\n    return 'Null';\n  }\n  toString(): string {\n    return 'Null';\n  }\n}\n\n// BOOLEANS\n\nexport class Bool extends DataType {\n  get typeId(): Type {\n    return Type.Bool;\n  }\n  // get ArrayType() {\n  //   return Uint8Array;\n  // }\n  get [Symbol.toStringTag](): string {\n    return 'Bool';\n  }\n  toString(): string {\n    return 'Bool';\n  }\n}\n\n// INTS\n\nexport class Int extends DataType {\n  readonly isSigned: boolean;\n  readonly bitWidth: number;\n  constructor(isSigned, bitWidth) {\n    super();\n    this.isSigned = isSigned;\n    this.bitWidth = bitWidth;\n  }\n  get typeId(): Type {\n    return Type.Int;\n  }\n  // get ArrayType() {\n  //   switch (this.bitWidth) {\n  //     case 8:\n  //       return this.isSigned ? Int8Array : Uint8Array;\n  //     case 16:\n  //       return this.isSigned ? Int16Array : Uint16Array;\n  //     case 32:\n  //       return this.isSigned ? Int32Array : Uint32Array;\n  //     case 64:\n  //       return this.isSigned ? Int32Array : Uint32Array;\n  //     default:\n  //       throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);\n  //   }\n  // }\n  get [Symbol.toStringTag](): string {\n    return 'Int';\n  }\n  toString(): string {\n    return `${this.isSigned ? 'I' : 'Ui'}nt${this.bitWidth}`;\n  }\n}\n\nexport class Int8 extends Int {\n  constructor() {\n    super(true, 8);\n  }\n}\nexport class Int16 extends Int {\n  constructor() {\n    super(true, 16);\n  }\n}\nexport class Int32 extends Int {\n  constructor() {\n    super(true, 32);\n  }\n}\nexport class Int64 extends Int {\n  constructor() {\n    super(true, 64);\n  }\n}\nexport class Uint8 extends Int {\n  constructor() {\n    super(false, 8);\n  }\n}\nexport class Uint16 extends Int {\n  constructor() {\n    super(false, 16);\n  }\n}\nexport class Uint32 extends Int {\n  constructor() {\n    super(false, 32);\n  }\n}\nexport class Uint64 extends Int {\n  constructor() {\n    super(false, 64);\n  }\n}\n\n// FLOATS\n\nconst Precision = {\n  HALF: 16,\n  SINGLE: 32,\n  DOUBLE: 64\n};\n\nexport class Float extends DataType {\n  readonly precision: number;\n  constructor(precision) {\n    super();\n    this.precision = precision;\n  }\n  get typeId(): Type {\n    return Type.Float;\n  }\n  // get ArrayType() {\n  //   switch (this.precision) {\n  //     case Precision.HALF:\n  //       return Uint16Array;\n  //     case Precision.SINGLE:\n  //       return Float32Array;\n  //     case Precision.DOUBLE:\n  //       return Float64Array;\n  //     default:\n  //       throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);\n  //   }\n  // }\n  get [Symbol.toStringTag](): string {\n    return 'Float';\n  }\n  toString(): string {\n    return `Float${this.precision}`;\n  }\n}\n\nexport class Float16 extends Float {\n  constructor() {\n    super(Precision.HALF);\n  }\n}\nexport class Float32 extends Float {\n  constructor() {\n    super(Precision.SINGLE);\n  }\n}\nexport class Float64 extends Float {\n  constructor() {\n    super(Precision.DOUBLE);\n  }\n}\n\nexport class Binary extends DataType {\n  constructor() {\n    super();\n  }\n  get typeId() {\n    return Type.Binary;\n  }\n  toString() {\n    return 'Binary';\n  }\n  get [Symbol.toStringTag]() {\n    return 'Binary';\n  }\n}\n\n// STRINGS\n\nexport class Utf8 extends DataType {\n  get typeId(): Type {\n    return Type.Utf8;\n  }\n  // get ArrayType() {\n  //   return Uint8Array;\n  // }\n  get [Symbol.toStringTag](): string {\n    return 'Utf8';\n  }\n  toString(): string {\n    return 'Utf8';\n  }\n}\n\n// DATES, TIMES AND INTERVALS\n\nconst DateUnit = {\n  DAY: 0,\n  MILLISECOND: 1\n};\n\nexport class Date extends DataType {\n  readonly unit: number;\n  constructor(unit) {\n    super();\n    this.unit = unit;\n  }\n  get typeId(): Type {\n    return Type.Date;\n  }\n  // get ArrayType() {\n  //   return Int32Array;\n  // }\n  get [Symbol.toStringTag](): string {\n    return 'Date';\n  }\n  toString(): string {\n    return `Date${(this.unit + 1) * 32}<${DateUnit[this.unit]}>`;\n  }\n}\n\nexport class DateDay extends Date {\n  constructor() {\n    super(DateUnit.DAY);\n  }\n}\nexport class DateMillisecond extends Date {\n  constructor() {\n    super(DateUnit.MILLISECOND);\n  }\n}\n\nconst TimeUnit = {\n  SECOND: 1,\n  MILLISECOND: 1e3,\n  MICROSECOND: 1e6,\n  NANOSECOND: 1e9\n};\n\nexport class Time extends DataType {\n  readonly unit: any;\n  readonly bitWidth: number;\n\n  constructor(unit: any, bitWidth: number) {\n    super();\n    this.unit = unit;\n    this.bitWidth = bitWidth;\n  }\n  get typeId(): Type {\n    return Type.Time;\n  }\n  toString(): string {\n    return `Time${this.bitWidth}<${TimeUnit[this.unit]}>`;\n  }\n  get [Symbol.toStringTag](): string {\n    return 'Time';\n  }\n  // get ArrayType() {\n  //   return Int32Array;\n  // }\n}\n\nexport class TimeSecond extends Time {\n  constructor() {\n    super(TimeUnit.SECOND, 32);\n  }\n}\nexport class TimeMillisecond extends Time {\n  constructor() {\n    super(TimeUnit.MILLISECOND, 32);\n  }\n}\n// export class TimeMicrosecond extends Time { constructor() { super(TimeUnit.MICROSECOND, 64); } }\n// export class TimeNanosecond extends Time { constructor() { super(TimeUnit.NANOSECOND, 64); } }\n\nexport class Timestamp extends DataType {\n  readonly unit: any;\n  readonly timezone: any;\n\n  constructor(unit: any, timezone = null) {\n    super();\n    this.unit = unit;\n    this.timezone = timezone;\n  }\n  get typeId(): Type {\n    return Type.Timestamp;\n  }\n  // get ArrayType() {\n  //   return Int32Array;\n  // }\n  get [Symbol.toStringTag](): string {\n    return 'Timestamp';\n  }\n  toString(): string {\n    return `Timestamp<${TimeUnit[this.unit]}${this.timezone ? `, ${this.timezone}` : ''}>`;\n  }\n}\n\nexport class TimestampSecond extends Timestamp {\n  constructor(timezone = null) {\n    super(TimeUnit.SECOND, timezone);\n  }\n}\nexport class TimestampMillisecond extends Timestamp {\n  constructor(timezone = null) {\n    super(TimeUnit.MILLISECOND, timezone);\n  }\n}\nexport class TimestampMicrosecond extends Timestamp {\n  constructor(timezone = null) {\n    super(TimeUnit.MICROSECOND, timezone);\n  }\n}\nexport class TimestampNanosecond extends Timestamp {\n  constructor(timezone = null) {\n    super(TimeUnit.NANOSECOND, timezone);\n  }\n}\n\nconst IntervalUnit = {\n  DAY_TIME: 0,\n  YEAR_MONTH: 1\n};\n\nexport class Interval extends DataType {\n  readonly unit: number;\n  constructor(unit: number) {\n    super();\n    this.unit = unit;\n  }\n  get typeId(): Type {\n    return Type.Interval;\n  }\n  // get ArrayType() {\n  //   return Int32Array;\n  // }\n  get [Symbol.toStringTag](): string {\n    return 'Interval';\n  }\n  toString(): string {\n    return `Interval<${IntervalUnit[this.unit]}>`;\n  }\n}\n\nexport class IntervalDayTime extends Interval {\n  constructor() {\n    super(IntervalUnit.DAY_TIME);\n  }\n}\nexport class IntervalYearMonth extends Interval {\n  constructor() {\n    super(IntervalUnit.YEAR_MONTH);\n  }\n}\n\nexport class FixedSizeList extends DataType {\n  readonly listSize: number;\n  readonly children: Field[];\n\n  constructor(listSize: number, child: Field) {\n    super();\n    this.listSize = listSize;\n    this.children = [child];\n  }\n  get typeId(): Type {\n    return Type.FixedSizeList;\n  }\n  get valueType() {\n    return this.children[0].type;\n  }\n  get valueField() {\n    return this.children[0];\n  }\n  // get ArrayType() {\n  //   return this.valueType.ArrayType;\n  // }\n  get [Symbol.toStringTag](): string {\n    return 'FixedSizeList';\n  }\n  toString(): string {\n    return `FixedSizeList[${this.listSize}]<${this.valueType}>`;\n  }\n}\n\nexport class Struct extends DataType {\n  public readonly children: Field[];\n\n  constructor(children: Field[]) {\n    super();\n    this.children = children;\n  }\n\n  public get typeId() {\n    return Type.Struct;\n  }\n  public toString() {\n    return `Struct<{${this.children.map((f) => `${f.name}:${f.type}`).join(', ')}}>`;\n  }\n  get [Symbol.toStringTag](): string {\n    return 'Struct';\n  }\n}\n", "import type {TypedArray} from '../../types';\nimport {\n  DataType,\n  Float32,\n  Float64,\n  Int16,\n  Int32,\n  Int8,\n  Uint16,\n  Uint32,\n  Uint8\n} from '../schema/schema';\n\nexport function getArrowTypeFromTypedArray(array: TypedArray): DataType {\n  switch (array.constructor) {\n    case Int8Array:\n      return new Int8();\n    case Uint8Array:\n      return new Uint8();\n    case Int16Array:\n      return new Int16();\n    case Uint16Array:\n      return new Uint16();\n    case Int32Array:\n      return new Int32();\n    case Uint32Array:\n      return new Uint32();\n    case Float32Array:\n      return new Float32();\n    case Float64Array:\n      return new Float64();\n    default:\n      throw new Error('array type not supported');\n  }\n}\n", "import {MeshAttribute, MeshAttributes} from './mesh-types';\nimport {Schema, Field, FixedSizeList} from '../../lib/schema/schema';\nimport {getArrowTypeFromTypedArray} from '../../lib/arrow/arrow-like-type-utils';\n\n/**\n * Create a schema for mesh attributes data\n * @param attributes\n * @param metadata\n * @returns\n */\nexport function deduceMeshSchema(\n  attributes: MeshAttributes,\n  metadata?: Map<string, string>\n): Schema {\n  const fields = deduceMeshFields(attributes);\n  return new Schema(fields, metadata);\n}\n\n/**\n * Create arrow-like schema field for mesh attribute\n * @param attributeName\n * @param attribute\n * @param optionalMetadata\n * @returns\n */\nexport function deduceMeshField(\n  attributeName: string,\n  attribute: MeshAttribute,\n  optionalMetadata?: Map<string, string>\n): Field {\n  const type = getArrowTypeFromTypedArray(attribute.value);\n  const metadata = optionalMetadata ? optionalMetadata : makeMeshAttributeMetadata(attribute);\n  const field = new Field(\n    attributeName,\n    new FixedSizeList(attribute.size, new Field('value', type)),\n    false,\n    metadata\n  );\n  return field;\n}\n\n/**\n * Create fields array for mesh attributes\n * @param attributes\n * @returns\n */\nfunction deduceMeshFields(attributes: MeshAttributes): Field[] {\n  const fields: Field[] = [];\n  for (const attributeName in attributes) {\n    const attribute: MeshAttribute = attributes[attributeName];\n    fields.push(deduceMeshField(attributeName, attribute));\n  }\n  return fields;\n}\n\n/**\n * Make metadata by mesh attribute properties\n * @param attribute\n * @returns\n */\nexport function makeMeshAttributeMetadata(attribute: MeshAttribute): Map<string, string> {\n  const result = new Map();\n  if ('byteOffset' in attribute) {\n    result.set('byteOffset', attribute.byteOffset!.toString(10));\n  }\n  if ('byteStride' in attribute) {\n    result.set('byteStride', attribute.byteStride!.toString(10));\n  }\n  if ('normalized' in attribute) {\n    result.set('normalized', attribute.normalized!.toString());\n  }\n  return result;\n}\n", "// From https://github.com/rauschma/async-iter-demo/tree/master/src under MIT license\n// http://2ality.com/2016/10/asynchronous-iteration.html\n\nclass ArrayQueue<T> extends Array<T> {\n  enqueue(value: T) {\n    // Add at the end\n    return this.push(value);\n  }\n  dequeue(): T {\n    // Remove first element\n    return this.shift() as T;\n  }\n}\n\nexport default class AsyncQueue<T> {\n  private _values: ArrayQueue<T | Error>;\n  private _settlers: ArrayQueue<{resolve: (value: any) => void; reject: (reason?: any) => void}>;\n  private _closed: boolean;\n\n  constructor() {\n    // enqueues > dequeues\n    this._values = new ArrayQueue<T>();\n    // dequeues > enqueues\n    this._settlers = new ArrayQueue<{\n      resolve: (value: any) => void;\n      reject: (reason?: any) => void;\n    }>();\n    this._closed = false;\n  }\n\n  close(): void {\n    while (this._settlers.length > 0) {\n      this._settlers.dequeue().resolve({done: true});\n    }\n    this._closed = true;\n  }\n\n  [Symbol.asyncIterator](): AsyncIterator<T> {\n    return this;\n  }\n\n  enqueue(value: T | Error): void {\n    if (this._closed) {\n      throw new Error('Closed');\n    }\n\n    if (this._settlers.length > 0) {\n      if (this._values.length > 0) {\n        throw new Error('Illegal internal state');\n      }\n      const settler = this._settlers.dequeue();\n      if (value instanceof Error) {\n        settler.reject(value);\n      } else {\n        settler.resolve({value});\n      }\n    } else {\n      this._values.enqueue(value);\n    }\n  }\n\n  /**\n   * @returns a Promise for an IteratorResult\n   */\n  next(): Promise<any> {\n    if (this._values.length > 0) {\n      const value = this._values.dequeue();\n      if (value instanceof Error) {\n        return Promise.reject(value);\n      }\n      return Promise.resolve({value});\n    }\n\n    if (this._closed) {\n      if (this._settlers.length > 0) {\n        throw new Error('Illegal internal state');\n      }\n      return Promise.resolve({done: true});\n    }\n    // Wait for new values to be enqueued\n    return new Promise((resolve, reject) => {\n      this._settlers.enqueue({resolve, reject});\n    });\n  }\n}\n\n/**\n * @returns a Promise for an Array with the elements in `asyncIterable`\n */\nexport async function takeAsync(\n  asyncIterable: AsyncIterable<any>,\n  count = Infinity\n): Promise<any[]> {\n  const result: Array<any> = [];\n  const iterator = asyncIterable[Symbol.asyncIterator]();\n  while (result.length < count) {\n    const {value, done} = await iterator.next();\n    if (done) {\n      break;\n    }\n    result.push(value);\n  }\n  return result;\n}\n", "import {deduceMeshField, MeshAttribute} from '@loaders.gl/schema';\nimport {Schema, Field} from '@loaders.gl/schema';\nimport type {DracoAttribute, DracoLoaderData, DracoMetadataEntry} from '../draco-types';\n\n/** Extract an arrow-like schema from a Draco mesh */\nexport function getDracoSchema(\n  attributes: {[attributeName: string]: MeshAttribute},\n  loaderData: DracoLoaderData,\n  indices?: MeshAttribute\n): Schema {\n  const metadataMap = makeMetadata(loaderData.metadata);\n  const fields: Field[] = [];\n  const namedLoaderDataAttributes = transformAttributesLoaderData(loaderData.attributes);\n  for (const attributeName in attributes) {\n    const attribute = attributes[attributeName];\n    const field = getArrowFieldFromAttribute(\n      attributeName,\n      attribute,\n      namedLoaderDataAttributes[attributeName]\n    );\n    fields.push(field);\n  }\n  if (indices) {\n    const indicesField = getArrowFieldFromAttribute('indices', indices);\n    fields.push(indicesField);\n  }\n  return new Schema(fields, metadataMap);\n}\n\nfunction transformAttributesLoaderData(loaderData: {[key: number]: DracoAttribute}): {\n  [attributeName: string]: DracoAttribute;\n} {\n  const result: {[attributeName: string]: DracoAttribute} = {};\n  for (const key in loaderData) {\n    const dracoAttribute = loaderData[key];\n    result[dracoAttribute.name || 'undefined'] = dracoAttribute;\n  }\n  return result;\n}\n\nfunction getArrowFieldFromAttribute(\n  attributeName: string,\n  attribute: MeshAttribute,\n  loaderData?: DracoAttribute\n): Field {\n  const metadataMap = loaderData ? makeMetadata(loaderData.metadata) : undefined;\n  const field = deduceMeshField(attributeName, attribute, metadataMap);\n  return field;\n}\n\nfunction makeMetadata(metadata: {[key: string]: DracoMetadataEntry}): Map<string, string> {\n  const metadataMap = new Map();\n  for (const key in metadata) {\n    metadataMap.set(`${key}.string`, JSON.stringify(metadata[key]));\n  }\n  return metadataMap;\n}\n", "/* eslint-disable camelcase */\n\nimport type {TypedArray, MeshAttribute, MeshGeometry} from '@loaders.gl/schema';\n\n// Draco types (input)\nimport type {\n  Draco3D,\n  Decoder,\n  Mesh,\n  PointCloud,\n  PointAttribute,\n  Metadata,\n  MetadataQuerier,\n  DracoInt32Array,\n  draco_DataType\n} from '../draco3d/draco3d-types';\n\n// Parsed data types (output)\nimport type {\n  DracoMesh,\n  DracoLoaderData,\n  DracoAttribute,\n  DracoMetadataEntry,\n  DracoQuantizationTransform,\n  DracoOctahedronTransform\n} from './draco-types';\n\nimport {getMeshBoundingBox} from '@loaders.gl/schema';\nimport {getDracoSchema} from './utils/get-draco-schema';\n\n/**\n * @param topology - How triangle indices should be generated (mesh only)\n * @param attributeNameEntry\n * @param extraAttributes\n * @param quantizedAttributes\n * @param octahedronAttributes\n */\nexport type DracoParseOptions = {\n  topology?: 'triangle-list' | 'triangle-strip';\n  attributeNameEntry?: string;\n  extraAttributes?: {[uniqueId: string]: number};\n  quantizedAttributes?: ('POSITION' | 'NORMAL' | 'COLOR' | 'TEX_COORD' | 'GENERIC')[];\n  octahedronAttributes?: ('POSITION' | 'NORMAL' | 'COLOR' | 'TEX_COORD' | 'GENERIC')[];\n};\n\n// @ts-ignore\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst GEOMETRY_TYPE = {\n  TRIANGULAR_MESH: 0,\n  POINT_CLOUD: 1\n};\n\n// Native Draco attribute names to GLTF attribute names.\nconst DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP = {\n  POSITION: 'POSITION',\n  NORMAL: 'NORMAL',\n  COLOR: 'COLOR_0',\n  TEX_COORD: 'TEXCOORD_0'\n};\n\nconst DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP = {\n  1: Int8Array,\n  2: Uint8Array,\n  3: Int16Array,\n  4: Uint16Array,\n  5: Int32Array,\n  6: Uint32Array,\n  9: Float32Array\n};\n\nconst INDEX_ITEM_SIZE = 4;\n\nexport default class DracoParser {\n  draco: Draco3D;\n  decoder: Decoder;\n  metadataQuerier: MetadataQuerier;\n\n  // draco - the draco decoder, either import `draco3d` or load dynamically\n  constructor(draco: Draco3D) {\n    this.draco = draco;\n    this.decoder = new this.draco.Decoder();\n    this.metadataQuerier = new this.draco.MetadataQuerier();\n  }\n\n  /**\n   * Destroy draco resources\n   */\n  destroy(): void {\n    this.draco.destroy(this.decoder);\n    this.draco.destroy(this.metadataQuerier);\n  }\n\n  /**\n   * NOTE: caller must call `destroyGeometry` on the return value after using it\n   * @param arrayBuffer\n   * @param options\n   */\n  parseSync(arrayBuffer: ArrayBuffer, options: DracoParseOptions = {}): DracoMesh {\n    const buffer = new this.draco.DecoderBuffer();\n    buffer.Init(new Int8Array(arrayBuffer), arrayBuffer.byteLength);\n\n    this._disableAttributeTransforms(options);\n\n    const geometry_type = this.decoder.GetEncodedGeometryType(buffer);\n    const dracoGeometry =\n      geometry_type === this.draco.TRIANGULAR_MESH\n        ? new this.draco.Mesh()\n        : new this.draco.PointCloud();\n\n    try {\n      let dracoStatus;\n      switch (geometry_type) {\n        case this.draco.TRIANGULAR_MESH:\n          dracoStatus = this.decoder.DecodeBufferToMesh(buffer, dracoGeometry as Mesh);\n          break;\n\n        case this.draco.POINT_CLOUD:\n          dracoStatus = this.decoder.DecodeBufferToPointCloud(buffer, dracoGeometry);\n          break;\n\n        default:\n          throw new Error('DRACO: Unknown geometry type.');\n      }\n\n      if (!dracoStatus.ok() || !dracoGeometry.ptr) {\n        const message = `DRACO decompression failed: ${dracoStatus.error_msg()}`;\n        // console.error(message);\n        throw new Error(message);\n      }\n\n      const loaderData = this._getDracoLoaderData(dracoGeometry, geometry_type, options);\n\n      const geometry = this._getMeshData(dracoGeometry, loaderData, options);\n\n      const boundingBox = getMeshBoundingBox(geometry.attributes);\n\n      const schema = getDracoSchema(geometry.attributes, loaderData, geometry.indices);\n\n      const data: DracoMesh = {\n        loader: 'draco',\n        loaderData,\n        header: {\n          vertexCount: dracoGeometry.num_points(),\n          boundingBox\n        },\n        ...geometry,\n        schema\n      };\n      return data;\n    } finally {\n      this.draco.destroy(buffer);\n      if (dracoGeometry) {\n        this.draco.destroy(dracoGeometry);\n      }\n    }\n  }\n\n  // Draco specific \"loader data\"\n\n  /**\n   * Extract\n   * @param dracoGeometry\n   * @param geometry_type\n   * @param options\n   * @returns\n   */\n  _getDracoLoaderData(\n    dracoGeometry: Mesh | PointCloud,\n    geometry_type,\n    options: DracoParseOptions\n  ): DracoLoaderData {\n    const metadata = this._getTopLevelMetadata(dracoGeometry);\n    const attributes = this._getDracoAttributes(dracoGeometry, options);\n\n    return {\n      geometry_type,\n      num_attributes: dracoGeometry.num_attributes(),\n      num_points: dracoGeometry.num_points(),\n      num_faces: dracoGeometry instanceof this.draco.Mesh ? dracoGeometry.num_faces() : 0,\n      metadata,\n      attributes\n    };\n  }\n\n  /**\n   * Extract all draco provided information and metadata for each attribute\n   * @param dracoGeometry\n   * @param options\n   * @returns\n   */\n  _getDracoAttributes(\n    dracoGeometry: Mesh | PointCloud,\n    options: DracoParseOptions\n  ): {[unique_id: number]: DracoAttribute} {\n    const dracoAttributes: {[unique_id: number]: DracoAttribute} = {};\n\n    for (let attributeId = 0; attributeId < dracoGeometry.num_attributes(); attributeId++) {\n      // Note: Draco docs do not seem clear on `GetAttribute` ids just being a zero-based index,\n      // but it does seems to work this way\n      const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attributeId);\n\n      const metadata = this._getAttributeMetadata(dracoGeometry, attributeId);\n\n      dracoAttributes[dracoAttribute.unique_id()] = {\n        unique_id: dracoAttribute.unique_id(),\n        attribute_type: dracoAttribute.attribute_type(),\n        data_type: dracoAttribute.data_type(),\n        num_components: dracoAttribute.num_components(),\n\n        byte_offset: dracoAttribute.byte_offset(),\n        byte_stride: dracoAttribute.byte_stride(),\n        normalized: dracoAttribute.normalized(),\n        attribute_index: attributeId,\n\n        metadata\n      };\n\n      // Add transformation parameters for any attributes app wants untransformed\n      const quantization = this._getQuantizationTransform(dracoAttribute, options);\n      if (quantization) {\n        dracoAttributes[dracoAttribute.unique_id()].quantization_transform = quantization;\n      }\n\n      const octahedron = this._getOctahedronTransform(dracoAttribute, options);\n      if (octahedron) {\n        dracoAttributes[dracoAttribute.unique_id()].octahedron_transform = octahedron;\n      }\n    }\n\n    return dracoAttributes;\n  }\n\n  /**\n   * Get standard loaders.gl mesh category data\n   * Extracts the geometry from draco\n   * @param dracoGeometry\n   * @param options\n   */\n  _getMeshData(\n    dracoGeometry: Mesh | PointCloud,\n    loaderData: DracoLoaderData,\n    options: DracoParseOptions\n  ): MeshGeometry {\n    const attributes = this._getMeshAttributes(loaderData, dracoGeometry, options);\n\n    const positionAttribute = attributes.POSITION;\n    if (!positionAttribute) {\n      throw new Error('DRACO: No position attribute found.');\n    }\n\n    // For meshes, we need indices to define the faces.\n    if (dracoGeometry instanceof this.draco.Mesh) {\n      switch (options.topology) {\n        case 'triangle-strip':\n          return {\n            topology: 'triangle-strip',\n            mode: 4, // GL.TRIANGLES\n            attributes,\n            indices: {\n              value: this._getTriangleStripIndices(dracoGeometry),\n              size: 1\n            }\n          };\n        case 'triangle-list':\n        default:\n          return {\n            topology: 'triangle-list',\n            mode: 5, // GL.TRIANGLE_STRIP\n            attributes,\n            indices: {\n              value: this._getTriangleListIndices(dracoGeometry),\n              size: 1\n            }\n          };\n      }\n    }\n\n    // PointCloud - must come last as Mesh inherits from PointCloud\n    return {\n      topology: 'point-list',\n      mode: 0, // GL.POINTS\n      attributes\n    };\n  }\n\n  _getMeshAttributes(\n    loaderData: DracoLoaderData,\n    dracoGeometry: Mesh | PointCloud,\n    options: DracoParseOptions\n  ): {[attributeName: string]: MeshAttribute} {\n    const attributes: {[key: string]: MeshAttribute} = {};\n\n    for (const loaderAttribute of Object.values(loaderData.attributes)) {\n      const attributeName = this._deduceAttributeName(loaderAttribute, options);\n      loaderAttribute.name = attributeName;\n      const {value, size} = this._getAttributeValues(dracoGeometry, loaderAttribute);\n      attributes[attributeName] = {\n        value,\n        size,\n        byteOffset: loaderAttribute.byte_offset,\n        byteStride: loaderAttribute.byte_stride,\n        normalized: loaderAttribute.normalized\n      };\n    }\n\n    return attributes;\n  }\n\n  // MESH INDICES EXTRACTION\n\n  /**\n   * For meshes, we need indices to define the faces.\n   * @param dracoGeometry\n   */\n  _getTriangleListIndices(dracoGeometry: Mesh) {\n    // Example on how to retrieve mesh and attributes.\n    const numFaces = dracoGeometry.num_faces();\n    const numIndices = numFaces * 3;\n    const byteLength = numIndices * INDEX_ITEM_SIZE;\n\n    const ptr = this.draco._malloc(byteLength);\n    try {\n      this.decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);\n      return new Uint32Array(this.draco.HEAPF32.buffer, ptr, numIndices).slice();\n    } finally {\n      this.draco._free(ptr);\n    }\n  }\n\n  /**\n   * For meshes, we need indices to define the faces.\n   * @param dracoGeometry\n   */\n  _getTriangleStripIndices(dracoGeometry: Mesh) {\n    const dracoArray = new this.draco.DracoInt32Array();\n    try {\n      /* const numStrips = */ this.decoder.GetTriangleStripsFromMesh(dracoGeometry, dracoArray);\n      return getUint32Array(dracoArray);\n    } finally {\n      this.draco.destroy(dracoArray);\n    }\n  }\n\n  /**\n   *\n   * @param dracoGeometry\n   * @param dracoAttribute\n   * @param attributeName\n   */\n  _getAttributeValues(\n    dracoGeometry: Mesh | PointCloud,\n    attribute: DracoAttribute\n  ): {value: TypedArray; size: number} {\n    const TypedArrayCtor = DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP[attribute.data_type];\n    const numComponents = attribute.num_components;\n    const numPoints = dracoGeometry.num_points();\n    const numValues = numPoints * numComponents;\n\n    const byteLength = numValues * TypedArrayCtor.BYTES_PER_ELEMENT;\n    const dataType = getDracoDataType(this.draco, TypedArrayCtor);\n\n    let value: TypedArray;\n\n    const ptr = this.draco._malloc(byteLength);\n    try {\n      const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attribute.attribute_index);\n      this.decoder.GetAttributeDataArrayForAllPoints(\n        dracoGeometry,\n        dracoAttribute,\n        dataType,\n        byteLength,\n        ptr\n      );\n      value = new TypedArrayCtor(this.draco.HEAPF32.buffer, ptr, numValues).slice();\n    } finally {\n      this.draco._free(ptr);\n    }\n\n    return {value, size: numComponents};\n  }\n\n  // Attribute names\n\n  /** \n   * DRACO does not store attribute names - We need to deduce an attribute name\n   * for each attribute\n  _getAttributeNames(\n    dracoGeometry: Mesh | PointCloud,\n    options: DracoParseOptions\n  ): {[unique_id: number]: string} {\n    const attributeNames: {[unique_id: number]: string} = {};\n    for (let attributeId = 0; attributeId < dracoGeometry.num_attributes(); attributeId++) {\n      const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attributeId);\n      const attributeName = this._deduceAttributeName(dracoAttribute, options);\n      attributeNames[attributeName] = attributeName;\n    }\n    return attributeNames;\n  }\n   */\n\n  /**\n   * Deduce an attribute name.\n   * @note DRACO does not save attribute names, just general type (POSITION, COLOR)\n   * to help optimize compression. We generate GLTF compatible names for the Draco-recognized\n   * types\n   * @param attributeData\n   */\n  _deduceAttributeName(attribute: DracoAttribute, options: DracoParseOptions): string {\n    // Deduce name based on application provided map\n    const uniqueId = attribute.unique_id;\n    for (const [attributeName, attributeUniqueId] of Object.entries(\n      options.extraAttributes || {}\n    )) {\n      if (attributeUniqueId === uniqueId) {\n        return attributeName;\n      }\n    }\n\n    // Deduce name based on attribute type\n    const thisAttributeType = attribute.attribute_type;\n    for (const dracoAttributeConstant in DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP) {\n      const attributeType = this.draco[dracoAttributeConstant];\n      if (attributeType === thisAttributeType) {\n        // TODO - Return unique names if there multiple attributes per type\n        // (e.g. multiple TEX_COORDS or COLORS)\n        return DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP[dracoAttributeConstant];\n      }\n    }\n\n    // Look up in metadata\n    // TODO - shouldn't this have priority?\n    const entryName = options.attributeNameEntry || 'name';\n    if (attribute.metadata[entryName]) {\n      return attribute.metadata[entryName].string;\n    }\n\n    // Attribute of \"GENERIC\" type, we need to assign some name\n    return `CUSTOM_ATTRIBUTE_${uniqueId}`;\n  }\n\n  // METADATA EXTRACTION\n\n  /** Get top level metadata */\n  _getTopLevelMetadata(dracoGeometry: Mesh | PointCloud) {\n    const dracoMetadata = this.decoder.GetMetadata(dracoGeometry);\n    return this._getDracoMetadata(dracoMetadata);\n  }\n\n  /** Get per attribute metadata */\n  _getAttributeMetadata(dracoGeometry: Mesh | PointCloud, attributeId: number) {\n    const dracoMetadata = this.decoder.GetAttributeMetadata(dracoGeometry, attributeId);\n    return this._getDracoMetadata(dracoMetadata);\n  }\n\n  /**\n   * Extract metadata field values\n   * @param dracoMetadata\n   * @returns\n   */\n  _getDracoMetadata(dracoMetadata: Metadata): {[entry: string]: DracoMetadataEntry} {\n    // The not so wonderful world of undocumented Draco APIs :(\n    if (!dracoMetadata || !dracoMetadata.ptr) {\n      return {};\n    }\n    const result = {};\n    const numEntries = this.metadataQuerier.NumEntries(dracoMetadata);\n    for (let entryIndex = 0; entryIndex < numEntries; entryIndex++) {\n      const entryName = this.metadataQuerier.GetEntryName(dracoMetadata, entryIndex);\n      result[entryName] = this._getDracoMetadataField(dracoMetadata, entryName);\n    }\n    return result;\n  }\n\n  /**\n   * Extracts possible values for one metadata entry by name\n   * @param dracoMetadata\n   * @param entryName\n   */\n  _getDracoMetadataField(dracoMetadata: Metadata, entryName: string): DracoMetadataEntry {\n    const dracoArray = new this.draco.DracoInt32Array();\n    try {\n      // Draco metadata fields can hold int32 arrays\n      this.metadataQuerier.GetIntEntryArray(dracoMetadata, entryName, dracoArray);\n      const intArray = getInt32Array(dracoArray);\n      return {\n        int: this.metadataQuerier.GetIntEntry(dracoMetadata, entryName),\n        string: this.metadataQuerier.GetStringEntry(dracoMetadata, entryName),\n        double: this.metadataQuerier.GetDoubleEntry(dracoMetadata, entryName),\n        intArray\n      };\n    } finally {\n      this.draco.destroy(dracoArray);\n    }\n  }\n\n  // QUANTIZED ATTRIBUTE SUPPORT (NO DECOMPRESSION)\n\n  /** Skip transforms for specific attribute types */\n  _disableAttributeTransforms(options: DracoParseOptions) {\n    const {quantizedAttributes = [], octahedronAttributes = []} = options;\n    const skipAttributes = [...quantizedAttributes, ...octahedronAttributes];\n    for (const dracoAttributeName of skipAttributes) {\n      this.decoder.SkipAttributeTransform(this.draco[dracoAttributeName]);\n    }\n  }\n\n  /**\n   * Extract (and apply?) Position Transform\n   * @todo not used\n   */\n  _getQuantizationTransform(\n    dracoAttribute: PointAttribute,\n    options: DracoParseOptions\n  ): DracoQuantizationTransform | null {\n    const {quantizedAttributes = []} = options;\n    const attribute_type = dracoAttribute.attribute_type();\n    const skip = quantizedAttributes.map((type) => this.decoder[type]).includes(attribute_type);\n    if (skip) {\n      const transform = new this.draco.AttributeQuantizationTransform();\n      try {\n        if (transform.InitFromAttribute(dracoAttribute)) {\n          return {\n            quantization_bits: transform.quantization_bits(),\n            range: transform.range(),\n            min_values: new Float32Array([1, 2, 3]).map((i) => transform.min_value(i))\n          };\n        }\n      } finally {\n        this.draco.destroy(transform);\n      }\n    }\n    return null;\n  }\n\n  _getOctahedronTransform(\n    dracoAttribute: PointAttribute,\n    options: DracoParseOptions\n  ): DracoOctahedronTransform | null {\n    const {octahedronAttributes = []} = options;\n    const attribute_type = dracoAttribute.attribute_type();\n    const octahedron = octahedronAttributes\n      .map((type) => this.decoder[type])\n      .includes(attribute_type);\n    if (octahedron) {\n      const transform = new this.draco.AttributeQuantizationTransform();\n      try {\n        if (transform.InitFromAttribute(dracoAttribute)) {\n          return {\n            quantization_bits: transform.quantization_bits()\n          };\n        }\n      } finally {\n        this.draco.destroy(transform);\n      }\n    }\n    return null;\n  }\n\n  // HELPERS\n}\n\n/**\n * Get draco specific data type by TypedArray constructor type\n * @param attributeType\n * @returns draco specific data type\n */\nfunction getDracoDataType(draco: Draco3D, attributeType: any): draco_DataType {\n  switch (attributeType) {\n    case Float32Array:\n      return draco.DT_FLOAT32;\n    case Int8Array:\n      return draco.DT_INT8;\n    case Int16Array:\n      return draco.DT_INT16;\n    case Int32Array:\n      return draco.DT_INT32;\n    case Uint8Array:\n      return draco.DT_UINT8;\n    case Uint16Array:\n      return draco.DT_UINT16;\n    case Uint32Array:\n      return draco.DT_UINT32;\n    default:\n      return draco.DT_INVALID;\n  }\n}\n\n/**\n * Copy a Draco int32 array into a JS typed array\n */\nfunction getInt32Array(dracoArray: DracoInt32Array): Int32Array {\n  const numValues = dracoArray.size();\n  const intArray = new Int32Array(numValues);\n  for (let i = 0; i < numValues; i++) {\n    intArray[i] = dracoArray.GetValue(i);\n  }\n  return intArray;\n}\n\n/**\n * Copy a Draco int32 array into a JS typed array\n */\nfunction getUint32Array(dracoArray: DracoInt32Array): Int32Array {\n  const numValues = dracoArray.size();\n  const intArray = new Int32Array(numValues);\n  for (let i = 0; i < numValues; i++) {\n    intArray[i] = dracoArray.GetValue(i);\n  }\n  return intArray;\n}\n", "// Dynamic DRACO module loading inspired by THREE.DRACOLoader\n// https://github.com/mrdoob/three.js/blob/398c4f39ebdb8b23eefd4a7a5ec49ec0c96c7462/examples/jsm/loaders/DRACOLoader.js\n// by Don McCurdy / https://www.donmccurdy.com / MIT license\n\nimport {loadLibrary} from '@loaders.gl/worker-utils';\n\nconst DRACO_DECODER_VERSION = '1.5.5';\nconst DRACO_ENCODER_VERSION = '1.4.1';\n\nconst STATIC_DECODER_URL = `https://www.gstatic.com/draco/versioned/decoders/${DRACO_DECODER_VERSION}`;\n\nconst DRACO_JS_DECODER_URL = `${STATIC_DECODER_URL}/draco_decoder.js`;\nconst DRACO_WASM_WRAPPER_URL = `${STATIC_DECODER_URL}/draco_wasm_wrapper.js`;\nconst DRACO_WASM_DECODER_URL = `${STATIC_DECODER_URL}/draco_decoder.wasm`;\n\nconst DRACO_ENCODER_URL = `https://raw.githubusercontent.com/google/draco/${DRACO_ENCODER_VERSION}/javascript/draco_encoder.js`;\n\nlet loadDecoderPromise;\nlet loadEncoderPromise;\n\nexport async function loadDracoDecoderModule(options) {\n  const modules = options.modules || {};\n\n  // Check if a bundled draco3d library has been supplied by application\n  if (modules.draco3d) {\n    loadDecoderPromise =\n      loadDecoderPromise ||\n      modules.draco3d.createDecoderModule({}).then((draco) => {\n        return {draco};\n      });\n  } else {\n    // If not, dynamically load the WASM script from our CDN\n    loadDecoderPromise = loadDecoderPromise || loadDracoDecoder(options);\n  }\n  return await loadDecoderPromise;\n}\n\nexport async function loadDracoEncoderModule(options) {\n  const modules = options.modules || {};\n\n  // Check if a bundled draco3d library has been supplied by application\n  if (modules.draco3d) {\n    loadEncoderPromise =\n      loadEncoderPromise ||\n      modules.draco3d.createEncoderModule({}).then((draco) => {\n        return {draco};\n      });\n  } else {\n    // If not, dynamically load the WASM script from our CDN\n    loadEncoderPromise = loadEncoderPromise || loadDracoEncoder(options);\n  }\n  return await loadEncoderPromise;\n}\n\n// DRACO DECODER LOADING\n\nasync function loadDracoDecoder(options) {\n  let DracoDecoderModule;\n  let wasmBinary;\n  switch (options.draco && options.draco.decoderType) {\n    case 'js':\n      DracoDecoderModule = await loadLibrary(DRACO_JS_DECODER_URL, 'draco', options);\n      break;\n\n    case 'wasm':\n    default:\n      [DracoDecoderModule, wasmBinary] = await Promise.all([\n        await loadLibrary(DRACO_WASM_WRAPPER_URL, 'draco', options),\n        await loadLibrary(DRACO_WASM_DECODER_URL, 'draco', options)\n      ]);\n  }\n  // Depends on how import happened...\n  // @ts-ignore\n  DracoDecoderModule = DracoDecoderModule || globalThis.DracoDecoderModule;\n  return await initializeDracoDecoder(DracoDecoderModule, wasmBinary);\n}\n\nfunction initializeDracoDecoder(DracoDecoderModule, wasmBinary) {\n  const options: {wasmBinary?: any} = {};\n  if (wasmBinary) {\n    options.wasmBinary = wasmBinary;\n  }\n\n  return new Promise((resolve) => {\n    DracoDecoderModule({\n      ...options,\n      onModuleLoaded: (draco) => resolve({draco}) // Module is Promise-like. Wrap in object to avoid loop.\n    });\n  });\n}\n\n// ENCODER\n\nasync function loadDracoEncoder(options) {\n  let DracoEncoderModule = await loadLibrary(DRACO_ENCODER_URL, 'draco', options);\n  // @ts-ignore\n  DracoEncoderModule = DracoEncoderModule || globalThis.DracoEncoderModule;\n\n  return new Promise((resolve) => {\n    DracoEncoderModule({\n      onModuleLoaded: (draco) => resolve({draco}) // Module is Promise-like. Wrap in object to avoid loop.\n    });\n  });\n}\n", "import type {LoaderWithParser} from '@loaders.gl/loader-utils';\nimport type {DracoMesh, DracoLoaderData} from './lib/draco-types';\nimport type {DracoLoaderOptions} from './draco-loader';\nimport {DracoLoader as DracoWorkerLoader} from './draco-loader';\nimport DracoParser from './lib/draco-parser';\nimport {loadDracoDecoderModule} from './lib/draco-module-loader';\nimport {VERSION} from './lib/utils/version';\nimport {isBrowser} from '@loaders.gl/worker-utils';\n\n// Draco data types\n\nexport type {DracoMesh, DracoLoaderData};\n\n// Draco Writer\n\nexport type {DracoWriterOptions} from './draco-writer';\nexport {DracoWriter} from './draco-writer';\n\n/**\n * Browser worker doesn't work because of issue during \"draco_encoder.js\" loading.\n * Refused to execute script from 'https://raw.githubusercontent.com/google/draco/1.4.1/javascript/draco_encoder.js' because its MIME type ('') is not executable.\n */\nexport const DracoWriterWorker = {\n  id: isBrowser ? 'draco-writer' : 'draco-writer-nodejs',\n  name: 'Draco compressed geometry writer',\n  module: 'draco',\n  version: VERSION,\n  worker: true,\n  options: {\n    draco: {},\n    source: null\n  }\n};\n\n// Draco Loader\n\nexport type {DracoLoaderOptions};\nexport {DracoWorkerLoader};\n\n/**\n * Loader for Draco3D compressed geometries\n */\nexport const DracoLoader = {\n  ...DracoWorkerLoader,\n  parse\n};\n\nasync function parse(arrayBuffer: ArrayBuffer, options?: DracoLoaderOptions): Promise<DracoMesh> {\n  const {draco} = await loadDracoDecoderModule(options);\n  const dracoParser = new DracoParser(draco);\n  try {\n    return dracoParser.parseSync(arrayBuffer, options?.draco);\n  } finally {\n    dracoParser.destroy();\n  }\n}\n\n// TYPE TESTS - TODO find a better way than exporting junk\nexport const _TypecheckDracoLoader: LoaderWithParser = DracoLoader;\n", "// import type {TypedArray} from '../types/loader-utils';\nimport type {GLTFAccessor} from '../types/gltf-types';\n// TODO - remove\nimport {getAccessorTypeFromSize, getComponentTypeFromArray} from './gltf-utils';\n\n// Returns a fresh attributes object with glTF-standardized attributes names\n// Attributes that cannot be identified will not be included\n// Removes `indices` if present, as it should be stored separately from the attributes\nexport function getGLTFAccessors(attributes): {[key: string]: GLTFAccessor} {\n  const accessors = {};\n  for (const name in attributes) {\n    const attribute = attributes[name];\n    if (name !== 'indices') {\n      const glTFAccessor = getGLTFAccessor(attribute);\n      accessors[name] = glTFAccessor;\n    }\n  }\n  return accessors;\n}\n\n// Fix up a single accessor.\n// Input: typed array or a partial accessor object\n// Return: accessor object\nexport function getGLTFAccessor(attribute) {\n  const {buffer, size, count} = getAccessorData(attribute);\n\n  const glTFAccessor: GLTFAccessor = {\n    // glTF Accessor values\n    // TODO: Instead of a bufferView index we could have an actual buffer (typed array)\n    // bufferView: null,\n    // TODO: Deprecate `value` in favor of bufferView?\n    // @ts-ignore\n    value: buffer,\n    size, // Decoded `type` (e.g. SCALAR)\n\n    byteOffset: 0,\n    count,\n    type: getAccessorTypeFromSize(size),\n    componentType: getComponentTypeFromArray(buffer)\n  };\n\n  return glTFAccessor;\n}\n\n// export function getGLTFAttribute(data, gltfAttributeName): GLTFAccessor {\n//   return data.attributes[data.glTFAttributeMap[gltfAttributeName]];\n// }\n\nfunction getAccessorData(attribute) {\n  let buffer = attribute;\n  let size = 1;\n  let count = 0;\n\n  if (attribute && attribute.value) {\n    buffer = attribute.value;\n    size = attribute.size || 1;\n  }\n\n  if (buffer) {\n    if (!ArrayBuffer.isView(buffer)) {\n      buffer = toTypedArray(buffer, Float32Array);\n    }\n    count = buffer.length / size;\n  }\n\n  return {buffer, size, count};\n}\n\n// Convert non-typed arrays to arrays of specified format\nfunction toTypedArray(array, ArrayType, convertTypedArrays = false) {\n  if (!array) {\n    return null;\n  }\n  if (Array.isArray(array)) {\n    return new ArrayType(array);\n  }\n  if (convertTypedArrays && !(array instanceof ArrayType)) {\n    return new ArrayType(array);\n  }\n  return array;\n}\n", "// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\n// Only TRIANGLES: 0x0004 and TRIANGLE_STRIP: 0x0005 are supported\n/* eslint-disable camelcase */\n\n/* eslint-disable camelcase */\nimport type {\n  GLTF,\n  GLTFAccessor,\n  GLTFMeshPrimitive,\n  GLTF_KHR_draco_mesh_compression\n} from '../types/gltf-types';\nimport type {GLTFLoaderOptions} from '../../gltf-loader';\n\nimport type {LoaderContext} from '@loaders.gl/loader-utils';\nimport {DracoLoader} from '@loaders.gl/draco';\nimport {DracoLoaderOptions, DracoMesh} from '@loaders.gl/draco';\nimport {sliceArrayBuffer} from '@loaders.gl/loader-utils';\nimport {default as Scenegraph} from '../api/gltf-scenegraph';\nimport {getGLTFAccessors, getGLTFAccessor} from '../gltf-utils/gltf-attribute-utils';\n\nconst KHR_DRACO_MESH_COMPRESSION = 'KHR_draco_mesh_compression';\n\n/** Extension name */\nexport const name = KHR_DRACO_MESH_COMPRESSION;\n\nexport function preprocess(\n  gltfData: {json: GLTF},\n  options: GLTFLoaderOptions,\n  context: LoaderContext\n): void {\n  const scenegraph = new Scenegraph(gltfData);\n  for (const primitive of makeMeshPrimitiveIterator(scenegraph)) {\n    if (scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION)) {\n      // TODO - Remove fallback accessors to make sure we don't load unnecessary buffers\n    }\n  }\n}\n\nexport async function decode(\n  gltfData: {json: GLTF},\n  options: GLTFLoaderOptions,\n  context: LoaderContext\n): Promise<void> {\n  if (!options?.gltf?.decompressMeshes) {\n    return;\n  }\n\n  const scenegraph = new Scenegraph(gltfData);\n  const promises: Promise<void>[] = [];\n  for (const primitive of makeMeshPrimitiveIterator(scenegraph)) {\n    if (scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION)) {\n      promises.push(decompressPrimitive(scenegraph, primitive, options, context));\n    }\n  }\n\n  // Decompress meshes in parallel\n  await Promise.all(promises);\n\n  // We have now decompressed all primitives, so remove the top-level extension\n  scenegraph.removeExtension(KHR_DRACO_MESH_COMPRESSION);\n}\n\nexport function encode(gltfData, options: GLTFLoaderOptions = {}): void {\n  const scenegraph = new Scenegraph(gltfData);\n\n  for (const mesh of scenegraph.json.meshes || []) {\n    // eslint-disable-next-line camelcase\n    // @ts-ignore\n    compressMesh(mesh, options);\n    // NOTE: Only add the extension if something was actually compressed\n    scenegraph.addRequiredExtension(KHR_DRACO_MESH_COMPRESSION);\n  }\n}\n\n// DECODE\n\n// Unpacks one mesh primitive and removes the extension from the primitive\n// DracoDecoder needs to be imported and registered by app\n// Returns: Promise that resolves when all pending draco decoder jobs for this mesh complete\n\n// TODO - Implement fallback behavior per KHR_DRACO_MESH_COMPRESSION spec\n\nasync function decompressPrimitive(\n  scenegraph: Scenegraph,\n  primitive: GLTFMeshPrimitive,\n  options: GLTFLoaderOptions,\n  context: LoaderContext\n): Promise<void> {\n  const dracoExtension = scenegraph.getObjectExtension<GLTF_KHR_draco_mesh_compression>(\n    primitive,\n    KHR_DRACO_MESH_COMPRESSION\n  );\n  if (!dracoExtension) {\n    return;\n  }\n\n  const buffer = scenegraph.getTypedArrayForBufferView(dracoExtension.bufferView);\n  // TODO - parse does not yet deal well with byte offsets embedded in typed arrays. Copy buffer\n  // TODO - remove when `parse` is fixed to handle `byteOffset`s\n  const bufferCopy = sliceArrayBuffer(buffer.buffer, buffer.byteOffset); // , buffer.byteLength);\n\n  const {parse} = context;\n  const dracoOptions: DracoLoaderOptions = {...options};\n\n  // TODO - remove hack: The entire tileset might be included, too expensive to serialize\n  delete dracoOptions['3d-tiles'];\n  const decodedData = (await parse(bufferCopy, DracoLoader, dracoOptions, context)) as DracoMesh;\n\n  const decodedAttributes: {[key: string]: GLTFAccessor} = getGLTFAccessors(decodedData.attributes);\n\n  // Restore min/max values\n  for (const [attributeName, decodedAttribute] of Object.entries(decodedAttributes)) {\n    if (attributeName in primitive.attributes) {\n      const accessorIndex: number = primitive.attributes[attributeName];\n      const accessor = scenegraph.getAccessor(accessorIndex);\n      if (accessor?.min && accessor?.max) {\n        decodedAttribute.min = accessor.min;\n        decodedAttribute.max = accessor.max;\n      }\n    }\n  }\n\n  // @ts-ignore\n  primitive.attributes = decodedAttributes;\n  if (decodedData.indices) {\n    // @ts-ignore\n    primitive.indices = getGLTFAccessor(decodedData.indices);\n  }\n\n  // Extension has been processed, delete it\n  // delete primitive.extensions[KHR_DRACO_MESH_COMPRESSION];\n\n  checkPrimitive(primitive);\n}\n\n// ENCODE\n\n// eslint-disable-next-line max-len\n// Only TRIANGLES: 0x0004 and TRIANGLE_STRIP: 0x0005 are supported\nfunction compressMesh(attributes, indices, mode: number = 4, options, context: LoaderContext) {\n  if (!options.DracoWriter) {\n    throw new Error('options.gltf.DracoWriter not provided');\n  }\n\n  // TODO - use DracoWriter using encode w/ registered DracoWriter...\n  const compressedData = options.DracoWriter.encodeSync({attributes});\n\n  // Draco compression may change the order and number of vertices in a mesh.\n  // To satisfy the requirement that accessors properties be correct for both\n  // compressed and uncompressed data, generators should create uncompressed\n  // attributes and indices using data that has been decompressed from the Draco buffer,\n  // rather than the original source data.\n  // @ts-ignore TODO this needs to be fixed\n  const decodedData = context?.parseSync?.({attributes});\n  const fauxAccessors = options._addFauxAttributes(decodedData.attributes);\n\n  const bufferViewIndex = options.addBufferView(compressedData);\n\n  const glTFMesh = {\n    primitives: [\n      {\n        attributes: fauxAccessors, // TODO - verify with spec\n        mode, // GL.POINTS\n        extensions: {\n          [KHR_DRACO_MESH_COMPRESSION]: {\n            bufferView: bufferViewIndex,\n            attributes: fauxAccessors // TODO - verify with spec\n          }\n        }\n      }\n    ]\n  };\n\n  return glTFMesh;\n}\n\n// UTILS\n\nfunction checkPrimitive(primitive: GLTFMeshPrimitive) {\n  if (!primitive.attributes && Object.keys(primitive.attributes).length > 0) {\n    throw new Error('glTF: Empty primitive detected: Draco decompression failure?');\n  }\n}\n\nfunction* makeMeshPrimitiveIterator(scenegraph) {\n  for (const mesh of scenegraph.json.meshes || []) {\n    for (const primitive of mesh.primitives) {\n      yield primitive;\n    }\n  }\n}\n", "export const COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\n\nexport const BYTES = {\n  5120: 1, // BYTE\n  5121: 1, // UNSIGNED_BYTE\n  5122: 2, // SHORT\n  5123: 2, // UNSIGNED_SHORT\n  5125: 4, // UNSIGNED_INT\n  5126: 4 // FLOAT\n};\n\n// ENUM LOOKUP\n\nexport function getBytesFromComponentType(componentType) {\n  return BYTES[componentType];\n}\n\nexport function getSizeFromAccessorType(type) {\n  return COMPONENTS[type];\n}\n\nexport function getGLEnumFromSamplerParameter(parameter) {\n  const GL_TEXTURE_MAG_FILTER = 0x2800;\n  const GL_TEXTURE_MIN_FILTER = 0x2801;\n  const GL_TEXTURE_WRAP_S = 0x2802;\n  const GL_TEXTURE_WRAP_T = 0x2803;\n\n  const PARAMETER_MAP = {\n    magFilter: GL_TEXTURE_MAG_FILTER,\n    minFilter: GL_TEXTURE_MIN_FILTER,\n    wrapS: GL_TEXTURE_WRAP_S,\n    wrapT: GL_TEXTURE_WRAP_T\n  };\n\n  return PARAMETER_MAP[parameter];\n}\n", "/**\n * https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_texture_transform/README.md\n */\n\nimport {Vector3, Matrix3} from '@math.gl/core';\nimport type {GLTFMeshPrimitive, GLTFWithBuffers} from '../types/gltf-types';\nimport type {GLTFLoaderOptions} from '../../gltf-loader';\nimport {getAccessorArrayTypeAndLength} from '../gltf-utils/gltf-utils';\nimport {BYTES, COMPONENTS} from '../gltf-utils/gltf-constants';\nimport {\n  Accessor,\n  BufferView,\n  MaterialNormalTextureInfo,\n  MaterialOcclusionTextureInfo,\n  TextureInfo as GLTFTextureInfo\n} from '../types/gltf-json-schema';\nimport GLTFScenegraph from '../api/gltf-scenegraph';\n\n/** Extension name */\nconst EXT_MESHOPT_TRANSFORM = 'KHR_texture_transform';\n\nexport const name = EXT_MESHOPT_TRANSFORM;\n\nconst scratchVector = new Vector3();\nconst scratchRotationMatrix = new Matrix3();\nconst scratchScaleMatrix = new Matrix3();\n\n/** Extension textureInfo https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_texture_transform#gltf-schema-updates */\ntype TextureInfo = {\n  /** The offset of the UV coordinate origin as a factor of the texture dimensions. */\n  offset?: [number, number];\n  /** Rotate the UVs by this many radians counter-clockwise around the origin. This is equivalent to a similar rotation of the image clockwise. */\n  rotation?: number;\n  /** The scale factor applied to the components of the UV coordinates. */\n  scale?: [number, number];\n  /** Overrides the textureInfo texCoord value if supplied, and if this extension is supported. */\n  texCoord?: number;\n};\n/** Intersection of all GLTF textures */\ntype CompoundGLTFTextureInfo = GLTFTextureInfo &\n  MaterialNormalTextureInfo &\n  MaterialOcclusionTextureInfo;\n/** Parameters for TEXCOORD transformation */\ntype TransformParameters = {\n  /** Original texCoord value https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#_textureinfo_texcoord */\n  originalTexCoord: number;\n  /** New texCoord value from extension https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_texture_transform#gltf-schema-updates */\n  texCoord: number;\n  /** Transformation matrix */\n  matrix: Matrix3;\n};\n\n/**\n * The extension entry to process the transformation\n * @param gltfData gltf buffers and json\n * @param options GLTFLoader options\n */\nexport async function decode(gltfData: GLTFWithBuffers, options: GLTFLoaderOptions) {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const extension = gltfScenegraph.getExtension(EXT_MESHOPT_TRANSFORM);\n  if (!extension) {\n    return;\n  }\n  const materials = gltfData.json.materials || [];\n  for (let i = 0; i < materials.length; i++) {\n    transformTexCoords(i, gltfData);\n  }\n}\n\n/**\n * Transform TEXCOORD by material\n * @param materialIndex processing material index\n * @param gltfData gltf buffers and json\n */\nfunction transformTexCoords(materialIndex: number, gltfData: GLTFWithBuffers): void {\n  // Save processed texCoords in order no to process the same twice\n  const processedTexCoords: [number, number][] = [];\n  const material = gltfData.json.materials?.[materialIndex];\n  const baseColorTexture = material?.pbrMetallicRoughness?.baseColorTexture;\n  if (baseColorTexture) {\n    transformPrimitives(gltfData, materialIndex, baseColorTexture, processedTexCoords);\n  }\n  const emisiveTexture = material?.emissiveTexture;\n  if (emisiveTexture) {\n    transformPrimitives(gltfData, materialIndex, emisiveTexture, processedTexCoords);\n  }\n  const normalTexture = material?.normalTexture;\n  if (normalTexture) {\n    transformPrimitives(gltfData, materialIndex, normalTexture, processedTexCoords);\n  }\n  const occlusionTexture = material?.occlusionTexture;\n  if (occlusionTexture) {\n    transformPrimitives(gltfData, materialIndex, occlusionTexture, processedTexCoords);\n  }\n  const metallicRoughnessTexture = material?.pbrMetallicRoughness?.metallicRoughnessTexture;\n  if (metallicRoughnessTexture) {\n    transformPrimitives(gltfData, materialIndex, metallicRoughnessTexture, processedTexCoords);\n  }\n}\n\n/**\n * Transform primitives of the particular material\n * @param gltfData gltf data\n * @param materialIndex primitives with this material will be transformed\n * @param texture texture object\n * @param processedTexCoords storage to save already processed texCoords\n */\nfunction transformPrimitives(\n  gltfData: GLTFWithBuffers,\n  materialIndex: number,\n  texture: CompoundGLTFTextureInfo,\n  processedTexCoords: [number, number][]\n) {\n  const transformParameters = getTransformParameters(texture, processedTexCoords);\n  if (!transformParameters) {\n    return;\n  }\n  const meshes = gltfData.json.meshes || [];\n  for (const mesh of meshes) {\n    for (const primitive of mesh.primitives) {\n      const material = primitive.material;\n      if (Number.isFinite(material) && materialIndex === material) {\n        transformPrimitive(gltfData, primitive, transformParameters);\n      }\n    }\n  }\n}\n\n/**\n * Get parameters for TEXCOORD transformation\n * @param texture texture object\n * @param processedTexCoords storage to save already processed texCoords\n * @returns texCoord couple and transformation matrix\n */\nfunction getTransformParameters(\n  texture: CompoundGLTFTextureInfo,\n  processedTexCoords: [number, number][]\n): TransformParameters | null {\n  const textureInfo = texture.extensions?.[EXT_MESHOPT_TRANSFORM];\n  const {texCoord: originalTexCoord = 0} = texture;\n  // If texCoord is not set in the extension, original attribute data will be replaced\n  const {texCoord = originalTexCoord} = textureInfo;\n  // Make sure that couple [originalTexCoord, extensionTexCoord] is not processed twice\n  const isProcessed =\n    processedTexCoords.findIndex(\n      ([original, newTexCoord]) => original === originalTexCoord && newTexCoord === texCoord\n    ) !== -1;\n  if (!isProcessed) {\n    const matrix = makeTransformationMatrix(textureInfo);\n    if (originalTexCoord !== texCoord) {\n      texture.texCoord = texCoord;\n    }\n    processedTexCoords.push([originalTexCoord, texCoord]);\n    return {originalTexCoord, texCoord, matrix};\n  }\n  return null;\n}\n\n/**\n * Transform `TEXCOORD_0` attribute in the primitive\n * @param gltfData gltf data\n * @param primitive primitive object\n * @param transformParameters texCoord couple and transformation matrix\n */\nfunction transformPrimitive(\n  gltfData: GLTFWithBuffers,\n  primitive: GLTFMeshPrimitive,\n  transformParameters: TransformParameters\n) {\n  const {originalTexCoord, texCoord, matrix} = transformParameters;\n  const texCoordAccessor = primitive.attributes[`TEXCOORD_${originalTexCoord}`];\n  if (Number.isFinite(texCoordAccessor)) {\n    // Get accessor of the `TEXCOORD_0` attribute\n    const accessor = gltfData.json.accessors?.[texCoordAccessor];\n    if (accessor && accessor.bufferView) {\n      // Get `bufferView` of the `accessor`\n      const bufferView = gltfData.json.bufferViews?.[accessor.bufferView];\n      if (bufferView) {\n        // Get `arrayBuffer` the `bufferView` look at\n        const {arrayBuffer, byteOffset: bufferByteOffset} = gltfData.buffers[bufferView.buffer];\n        // Resulting byteOffset is sum of the buffer, accessor and bufferView byte offsets\n        const byteOffset =\n          (bufferByteOffset || 0) + (accessor.byteOffset || 0) + (bufferView.byteOffset || 0);\n        // Deduce TypedArray type and its length from `accessor` and `bufferView` data\n        const {ArrayType, length} = getAccessorArrayTypeAndLength(accessor, bufferView);\n        // Number of bytes each component occupies\n        const bytes = BYTES[accessor.componentType];\n        // Number of components. For the `TEXCOORD_0` with `VEC2` type, it must return 2\n        const components = COMPONENTS[accessor.type];\n        // Multiplier to calculate the address of the `TEXCOORD_0` element in the arrayBuffer\n        const elementAddressScale = bufferView.byteStride || bytes * components;\n        // Data transform to Float32Array\n        const result = new Float32Array(length);\n        for (let i = 0; i < accessor.count; i++) {\n          // Take [u, v] couple from the arrayBuffer\n          const uv = new ArrayType(arrayBuffer, byteOffset + i * elementAddressScale, 2);\n          // Set and transform Vector3 per https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_texture_transform#overview\n          scratchVector.set(uv[0], uv[1], 1);\n          scratchVector.transformByMatrix3(matrix);\n          // Save result in Float32Array\n          result.set([scratchVector[0], scratchVector[1]], i * components);\n        }\n        // If texCoord the same, replace gltf structural data\n        if (originalTexCoord === texCoord) {\n          updateGltf(accessor, bufferView, gltfData.buffers, result);\n        } else {\n          // If texCoord change, create new attribute\n          createAttribute(texCoord, accessor, primitive, gltfData, result);\n        }\n      }\n    }\n  }\n}\n\n/**\n * Update GLTF structural objects with new data as we create new `Float32Array` for `TEXCOORD_0`.\n * @param accessor accessor to change\n * @param bufferView bufferView to change\n * @param buffers binary buffers\n * @param newTexcoordArray typed array with data after transformation\n */\nfunction updateGltf(\n  accessor: Accessor,\n  bufferView: BufferView,\n  buffers: {arrayBuffer: ArrayBuffer; byteOffset: number; byteLength: number}[],\n  newTexCoordArray: Float32Array\n): void {\n  accessor.componentType = 5126;\n  buffers.push({\n    arrayBuffer: newTexCoordArray.buffer,\n    byteOffset: 0,\n    byteLength: newTexCoordArray.buffer.byteLength\n  });\n  bufferView.buffer = buffers.length - 1;\n  bufferView.byteLength = newTexCoordArray.buffer.byteLength;\n  bufferView.byteOffset = 0;\n  delete bufferView.byteStride;\n}\n\n/**\n *\n * @param newTexCoord new `texCoord` value\n * @param originalAccessor original accessor object, that store data before transformation\n * @param primitive primitive object\n * @param gltfData gltf data\n * @param newTexCoordArray typed array with data after transformation\n * @returns\n */\nfunction createAttribute(\n  newTexCoord: number,\n  originalAccessor: Accessor,\n  primitive: GLTFMeshPrimitive,\n  gltfData: GLTFWithBuffers,\n  newTexCoordArray: Float32Array\n) {\n  gltfData.buffers.push({\n    arrayBuffer: newTexCoordArray.buffer,\n    byteOffset: 0,\n    byteLength: newTexCoordArray.buffer.byteLength\n  });\n  const bufferViews = gltfData.json.bufferViews;\n  if (!bufferViews) {\n    return;\n  }\n  bufferViews.push({\n    buffer: gltfData.buffers.length - 1,\n    byteLength: newTexCoordArray.buffer.byteLength,\n    byteOffset: 0\n  });\n  const accessors = gltfData.json.accessors;\n  if (!accessors) {\n    return;\n  }\n  accessors.push({\n    bufferView: bufferViews?.length - 1,\n    byteOffset: 0,\n    componentType: 5126,\n    count: originalAccessor.count,\n    type: 'VEC2'\n  });\n  primitive.attributes[`TEXCOORD_${newTexCoord}`] = accessors.length - 1;\n}\n\n/**\n * Construct transformation matrix from the extension data (transition, rotation, scale)\n * @param extensionData extension data\n * @returns transformation matrix\n */\nfunction makeTransformationMatrix(extensionData: TextureInfo): Matrix3 {\n  const {offset = [0, 0], rotation = 0, scale = [1, 1]} = extensionData;\n  const translationMatirx = new Matrix3().set(1, 0, 0, 0, 1, 0, offset[0], offset[1], 1);\n  const rotationMatirx = scratchRotationMatrix.set(\n    Math.cos(rotation),\n    Math.sin(rotation),\n    0,\n    -Math.sin(rotation),\n    Math.cos(rotation),\n    0,\n    0,\n    0,\n    1\n  );\n  const scaleMatrix = scratchScaleMatrix.set(scale[0], 0, 0, 0, scale[1], 0, 0, 0, 1);\n  return translationMatirx.multiplyRight(rotationMatirx).multiplyRight(scaleMatrix);\n}\n", "// GLTF EXTENSION: KHR_lights_punctual\n// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n\nimport type {GLTF} from '../../types/gltf-types';\n\nimport {assert} from '../../utils/assert';\nimport GLTFScenegraph from '../../api/gltf-scenegraph';\n\nconst KHR_LIGHTS_PUNCTUAL = 'KHR_lights_punctual';\n\nexport const name = KHR_LIGHTS_PUNCTUAL;\n\nexport async function decode(gltfData: {json: GLTF}): Promise<void> {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const {json} = gltfScenegraph;\n\n  // Move the light array out of the extension and remove the extension\n  const extension = gltfScenegraph.getExtension(KHR_LIGHTS_PUNCTUAL);\n  if (extension) {\n    // @ts-ignore\n    gltfScenegraph.json.lights = extension.lights;\n    gltfScenegraph.removeExtension(KHR_LIGHTS_PUNCTUAL);\n  }\n\n  // Any nodes that have the extension, add lights field pointing to light object\n  // and remove the extension\n  for (const node of json.nodes || []) {\n    const nodeExtension = gltfScenegraph.getObjectExtension(node, KHR_LIGHTS_PUNCTUAL);\n    if (nodeExtension) {\n      // @ts-ignore\n      node.light = nodeExtension.light;\n    }\n    gltfScenegraph.removeObjectExtension(node, KHR_LIGHTS_PUNCTUAL);\n  }\n}\n\n// Move the light ar ray out of the extension and remove the extension\nexport async function encode(gltfData): Promise<void> {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const {json} = gltfScenegraph;\n\n  // @ts-ignore\n  if (json.lights) {\n    const extension = gltfScenegraph.addExtension(KHR_LIGHTS_PUNCTUAL);\n    // @ts-ignore\n    assert(!extension.lights);\n    // @ts-ignore\n    extension.lights = json.lights;\n    // @ts-ignore\n    delete json.lights;\n  }\n\n  // Any nodes that have lights field pointing to light object\n  // add the extension\n  // @ts-ignore\n  if (gltfScenegraph.json.lights) {\n    // @ts-ignore\n    for (const light of gltfScenegraph.json.lights) {\n      const node = light.node;\n      gltfScenegraph.addObjectExtension(node, KHR_LIGHTS_PUNCTUAL, light);\n    }\n    // @ts-ignore\n    delete gltfScenegraph.json.lights;\n  }\n}\n", "// GLTF EXTENSION: KHR_materials_unlit\n// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n\nimport type {GLTF} from '../../types/gltf-types';\n\nimport GLTFScenegraph from '../../api/gltf-scenegraph';\n\nconst KHR_MATERIALS_UNLIT = 'KHR_materials_unlit';\n\nexport const name = KHR_MATERIALS_UNLIT;\n\nexport async function decode(gltfData: {json: GLTF}): Promise<void> {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const {json} = gltfScenegraph;\n\n  // Any nodes that have the extension, add lights field pointing to light object\n  // and remove the extension\n  for (const material of json.materials || []) {\n    const extension = material.extensions && material.extensions.KHR_materials_unlit;\n    if (extension) {\n      // @ts-ignore TODO\n      material.unlit = true;\n    }\n    gltfScenegraph.removeObjectExtension(material, KHR_MATERIALS_UNLIT);\n  }\n\n  // Remove the top-level extension\n  gltfScenegraph.removeExtension(KHR_MATERIALS_UNLIT);\n}\n\nexport function encode(gltfData) {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const {json} = gltfScenegraph;\n\n  // Any nodes that have lights field pointing to light object\n  // add the extension\n  // @ts-ignore\n  if (gltfScenegraph.materials) {\n    for (const material of json.materials || []) {\n      // @ts-ignore\n      if (material.unlit) {\n        // @ts-ignore\n        delete material.unlit;\n        gltfScenegraph.addObjectExtension(material, KHR_MATERIALS_UNLIT, {});\n        gltfScenegraph.addExtension(KHR_MATERIALS_UNLIT);\n      }\n    }\n  }\n}\n", "// GLTF EXTENSION: KHR_techniques_webgl\n// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_techniques_webgl\n\nimport type {GLTF} from '../../types/gltf-types';\n\nimport GLTFScenegraph from '../../api/gltf-scenegraph';\n\nconst KHR_TECHNIQUES_WEBGL = 'KHR_techniques_webgl';\n\nexport const name = KHR_TECHNIQUES_WEBGL;\n\nexport async function decode(gltfData: {json: GLTF}): Promise<void> {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const {json} = gltfScenegraph;\n\n  const extension = gltfScenegraph.getExtension(KHR_TECHNIQUES_WEBGL);\n  if (extension) {\n    const techniques = resolveTechniques(extension, gltfScenegraph);\n\n    for (const material of json.materials || []) {\n      const materialExtension = gltfScenegraph.getObjectExtension(material, KHR_TECHNIQUES_WEBGL);\n      if (materialExtension) {\n        // @ts-ignore TODO\n        material.technique = Object.assign(\n          {},\n          materialExtension,\n          // @ts-ignore\n          techniques[materialExtension.technique]\n        );\n        // @ts-ignore TODO\n        material.technique.values = resolveValues(material.technique, gltfScenegraph);\n      }\n      gltfScenegraph.removeObjectExtension(material, KHR_TECHNIQUES_WEBGL);\n    }\n\n    // Remove the top-level extension\n    gltfScenegraph.removeExtension(KHR_TECHNIQUES_WEBGL);\n  }\n}\n// eslint-disable-next-line\nexport async function encode(gltfData, options): Promise<void> {\n  // TODO\n}\n\nfunction resolveTechniques(\n  techniquesExtension: {[key: string]: any},\n  // programs: {[key: string]: any}[],\n  // shaders: {[key: string]: any}[],\n  // techniques: {[key: string]: any}[]\n  gltfScenegraph\n) {\n  const {programs = [], shaders = [], techniques = []} = techniquesExtension;\n  const textDecoder = new TextDecoder();\n\n  shaders.forEach((shader) => {\n    if (Number.isFinite(shader.bufferView)) {\n      shader.code = textDecoder.decode(\n        gltfScenegraph.getTypedArrayForBufferView(shader.bufferView)\n      );\n    } else {\n      // TODO: handle URI shader\n      throw new Error('KHR_techniques_webgl: no shader code');\n    }\n  });\n\n  programs.forEach((program) => {\n    program.fragmentShader = shaders[program.fragmentShader];\n    program.vertexShader = shaders[program.vertexShader];\n  });\n\n  techniques.forEach((technique) => {\n    technique.program = programs[technique.program];\n  });\n\n  return techniques;\n}\n\nfunction resolveValues(technique, gltfScenegraph) {\n  const values = Object.assign({}, technique.values);\n\n  // merge values from uniforms\n  Object.keys(technique.uniforms || {}).forEach((uniform) => {\n    if (technique.uniforms[uniform].value && !(uniform in values)) {\n      values[uniform] = technique.uniforms[uniform].value;\n    }\n  });\n\n  // resolve textures\n  Object.keys(values).forEach((uniform) => {\n    if (typeof values[uniform] === 'object' && values[uniform].index !== undefined) {\n      // Assume this is a texture\n      // TODO: find if there are any other types that can be referenced\n      values[uniform].texture = gltfScenegraph.getTexture(values[uniform].index);\n    }\n  });\n\n  return values;\n}\n", "/* eslint-disable camelcase */\nimport type {GLTF} from '../../types/gltf-types';\n\nimport GLTFScenegraph from '../../api/gltf-scenegraph';\nimport {\n  ClassProperty,\n  EXT_feature_metadata_class_object,\n  EXT_feature_metadata_feature_table,\n  FeatureTableProperty,\n  GLTF_EXT_feature_metadata\n} from '../../types/gltf-json-schema';\n\n/** Extension name */\nconst EXT_FEATURE_METADATA = 'EXT_feature_metadata';\n\nexport const name = EXT_FEATURE_METADATA;\n\nexport async function decode(gltfData: {json: GLTF}): Promise<void> {\n  const scenegraph = new GLTFScenegraph(gltfData);\n  decodeExtFeatureMetadata(scenegraph);\n}\n\n/**\n * Decodes feature metadata from extension\n * @param scenegraph\n */\nfunction decodeExtFeatureMetadata(scenegraph: GLTFScenegraph): void {\n  const extension: GLTF_EXT_feature_metadata | null = scenegraph.getExtension(EXT_FEATURE_METADATA);\n  const schemaClasses = extension?.schema?.classes;\n  const featureTables = extension?.featureTables;\n  const featureTextures = extension?.featureTextures;\n\n  if (featureTextures) {\n    /*\n     * TODO add support for featureTextures\n     * Spec - https://github.com/CesiumGS/glTF/tree/3d-tiles-next/extensions/2.0/Vendor/EXT_feature_metadata#feature-textures\n     */\n    // eslint-disable-next-line no-console\n    console.warn('featureTextures is not yet supported in the \"EXT_feature_metadata\" extension.');\n  }\n\n  if (schemaClasses && featureTables) {\n    for (const schemaName in schemaClasses) {\n      const schemaClass = schemaClasses[schemaName];\n      const featureTable = findFeatureTableByName(featureTables, schemaName);\n\n      if (featureTable) {\n        handleFeatureTableProperties(scenegraph, featureTable, schemaClass);\n      }\n    }\n  }\n}\n\n/**\n * Navigate throw all properies in feature table and gets properties data.\n * @param scenegraph\n * @param featureTable\n * @param schemaClass\n */\nfunction handleFeatureTableProperties(\n  scenegraph: GLTFScenegraph,\n  featureTable: EXT_feature_metadata_feature_table,\n  schemaClass: EXT_feature_metadata_class_object\n): void {\n  for (const propertyName in schemaClass.properties) {\n    const schemaProperty = schemaClass.properties[propertyName];\n    const featureTableProperty = featureTable?.properties?.[propertyName];\n    const numberOfFeatures = featureTable.count;\n\n    if (featureTableProperty) {\n      const data = getPropertyDataFromBinarySource(\n        scenegraph,\n        schemaProperty,\n        numberOfFeatures,\n        featureTableProperty\n      );\n      featureTableProperty.data = data;\n    }\n  }\n}\n\n/**\n * Decode properties from binary sourse based on property type.\n * @param scenegraph\n * @param schemaProperty\n * @param numberOfFeatures\n * @param featureTableProperty\n */\nfunction getPropertyDataFromBinarySource(\n  scenegraph: GLTFScenegraph,\n  schemaProperty: ClassProperty,\n  numberOfFeatures: number,\n  featureTableProperty: FeatureTableProperty\n): Uint8Array | string[] {\n  const bufferView = featureTableProperty.bufferView;\n  // TODO think maybe we shouldn't get data only in Uint8Array format.\n  let data: Uint8Array | string[] = scenegraph.getTypedArrayForBufferView(bufferView);\n\n  switch (schemaProperty.type) {\n    case 'STRING': {\n      // stringOffsetBufferView should be available for string type.\n      const stringOffsetBufferView = featureTableProperty.stringOffsetBufferView!;\n      const offsetsData = scenegraph.getTypedArrayForBufferView(stringOffsetBufferView);\n      data = getStringAttributes(data, offsetsData, numberOfFeatures);\n      break;\n    }\n    default:\n  }\n\n  return data;\n}\n\n/**\n * Find the feature table by class name.\n * @param featureTables\n * @param schemaClassName\n */\nfunction findFeatureTableByName(\n  featureTables: {[key: string]: EXT_feature_metadata_feature_table},\n  schemaClassName: string\n): EXT_feature_metadata_feature_table | null {\n  for (const featureTableName in featureTables) {\n    const featureTable = featureTables[featureTableName];\n\n    if (featureTable.class === schemaClassName) {\n      return featureTable;\n    }\n  }\n\n  return null;\n}\n\n/**\n * Getting string attributes from binary data.\n * Spec - https://github.com/CesiumGS/3d-tiles/tree/main/specification/Metadata#strings\n * @param data\n * @param offsetsData\n * @param stringsCount\n */\nfunction getStringAttributes(\n  data: Uint8Array,\n  offsetsData: Uint8Array,\n  stringsCount: number\n): string[] {\n  const stringsArray: string[] = [];\n  const textDecoder = new TextDecoder('utf8');\n\n  let stringOffset = 0;\n  const bytesPerStringSize = 4;\n\n  for (let index = 0; index < stringsCount; index++) {\n    // TODO check if it is multiplication on bytesPerStringSize is valid operation?\n    const stringByteSize =\n      offsetsData[(index + 1) * bytesPerStringSize] - offsetsData[index * bytesPerStringSize];\n    const stringData = data.subarray(stringOffset, stringByteSize + stringOffset);\n    const stringAttribute = textDecoder.decode(stringData);\n\n    stringsArray.push(stringAttribute);\n    stringOffset += stringByteSize;\n  }\n\n  return stringsArray;\n}\n", "/* eslint-disable camelcase */\nimport {GLTF} from '../types/gltf-types';\nimport type {GLTFLoaderOptions} from '../../gltf-loader';\n\n// GLTF 1.0 extensions (decode only)\n// import * as KHR_binary_gltf from './KHR_draco_mesh_compression';\n\n// GLTF 2.0 Khronos extensions (decode/encode)\nimport * as EXT_meshopt_compression from '../extensions/EXT_meshopt_compression';\nimport * as EXT_texture_webp from '../extensions/EXT_texture_webp';\nimport * as KHR_texture_basisu from '../extensions/KHR_texture_basisu';\nimport * as KHR_draco_mesh_compression from '../extensions/KHR_draco_mesh_compression';\nimport * as KHR_texture_transform from '../extensions/KHR_texture_transform';\n\n// Deprecated. These should be handled by rendering library (e.g. luma.gl), not the loader.\nimport * as KHR_lights_punctual from '../extensions/deprecated/KHR_lights_punctual';\nimport * as KHR_materials_unlit from '../extensions/deprecated/KHR_materials_unlit';\nimport * as KHR_techniques_webgl from '../extensions/deprecated/KHR_techniques_webgl';\nimport * as EXT_feature_metadata from '../extensions/deprecated/EXT_feature_metadata';\n\n// Vendor extensions\n\ntype GLTFExtensionPlugin = {\n  name: string;\n  preprocess?: (gltfData: {json: GLTF}, options: GLTFLoaderOptions, context) => void;\n  decode?: (\n    gltfData: {\n      json: GLTF;\n      buffers: {arrayBuffer: ArrayBuffer; byteOffset: number; byteLength: number}[];\n    },\n    options: GLTFLoaderOptions,\n    context\n  ) => Promise<void>;\n  encode?: (gltfData: {json: GLTF}, options: GLTFLoaderOptions) => void;\n};\n\n/**\n * List of extensions processed by the GLTFLoader\n * Note that may extensions can only be handled on the rendering stage and are left out here\n * These are just extensions that can be handled fully or partially during loading.\n */\nexport const EXTENSIONS: GLTFExtensionPlugin[] = [\n  // 1.0\n  // KHR_binary_gltf is handled separately - must be processed before other parsing starts\n  // KHR_binary_gltf,\n\n  // 2.0\n  EXT_meshopt_compression,\n  EXT_texture_webp,\n  // Basisu should come after webp, we want basisu to be preferred if both are provided\n  KHR_texture_basisu,\n  KHR_draco_mesh_compression,\n  KHR_lights_punctual,\n  KHR_materials_unlit,\n  KHR_techniques_webgl,\n  KHR_texture_transform,\n  EXT_feature_metadata\n];\n\n/** Call before any resource loading starts */\nexport function preprocessExtensions(gltf, options: GLTFLoaderOptions = {}, context?) {\n  const extensions = EXTENSIONS.filter((extension) => useExtension(extension.name, options));\n  for (const extension of extensions) {\n    extension.preprocess?.(gltf, options, context);\n  }\n}\n\n/** Call after resource loading */\nexport async function decodeExtensions(gltf, options: GLTFLoaderOptions = {}, context?) {\n  const extensions = EXTENSIONS.filter((extension) => useExtension(extension.name, options));\n  for (const extension of extensions) {\n    // Note: We decode async extensions sequentially, this might not be necessary\n    // Currently we only have Draco, but when we add Basis we may revisit\n    await extension.decode?.(gltf, options, context);\n  }\n}\n\nfunction useExtension(extensionName: string, options: GLTFLoaderOptions) {\n  const excludes = options?.gltf?.excludeExtensions || {};\n  const exclude = extensionName in excludes && !excludes[extensionName];\n  return !exclude;\n}\n", "// GLTF 1.0 EXTENSION: KHR_binary_glTF\n// https://github.com/KhronosGroup/glTF/tree/master/extensions/1.0/Khronos/KHR_binary_glTF\n/* eslint-disable camelcase */\n\nimport type {GLTF, GLTF_KHR_binary_glTF} from '../types/gltf-types';\n\nimport GLTFScenegraph from '../api/gltf-scenegraph';\n\nconst KHR_BINARY_GLTF = 'KHR_binary_glTF';\n\n/** Extension name */\nexport const name = KHR_BINARY_GLTF;\n\nexport function preprocess(gltfData: {json: GLTF}): void {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const {json} = gltfScenegraph;\n\n  // Note: json.buffers.binary_glTF also needs to be replaced\n  // This is currently done during gltf normalization\n\n  // Image and shader nodes can have the extension\n  // https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Khronos/KHR_binary_glTF/schema/image.KHR_binary_glTF.schema.json\n  for (const image of json.images || []) {\n    const extension = gltfScenegraph.getObjectExtension<GLTF_KHR_binary_glTF>(\n      image,\n      KHR_BINARY_GLTF\n    );\n    // The data in the extension is valid as glTF 2.0 data inside the object, so just copy it in\n    if (extension) {\n      Object.assign(image, extension);\n    }\n    gltfScenegraph.removeObjectExtension(image, KHR_BINARY_GLTF);\n  }\n\n  // TODO shaders - At least traverse and throw error if used?\n  // https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Khronos/KHR_binary_glTF/schema/shader.KHR_binary_glTF.schema.json\n\n  // glTF v1 one files have a partially formed URI field that is not expected in (and causes problems in) 2.0\n  if (json.buffers && json.buffers[0]) {\n    delete json.buffers[0].uri;\n  }\n\n  // Remove the top-level extension as it has now been processed\n  gltfScenegraph.removeExtension(KHR_BINARY_GLTF);\n}\n\n// KHR_binary_gltf is a 1.0 extension that is supported natively by 2.0\n// export function encode() {\n//   throw new Error(KHR_BINARY_GLTF);\n// }\n", "/* eslint-disable camelcase */\nimport * as KHR_binary_glTF from '../extensions/KHR_binary_gltf';\n\n// Binary format changes (mainly implemented by GLBLoader)\n// https://github.com/KhronosGroup/glTF/tree/master/extensions/1.0/Khronos/KHR_binary_glTF\n\n// JSON format changes:\n// https://github.com/khronosgroup/gltf/issues/605\n\n// - [x] Top-level JSON objects are arrays now\n// - [ ] Removed indirection from animation: sampler now refers directly to accessors, #712\n// - [ ] material.parameter.value and technique.parameter.value must be an array, #690\n// - [ ] Node can have only one mesh #821\n// - [ ] Added reqs on JSON encoding\n// - [ ] Added reqs on binary data alignment #802 (comment)\n\n// Additions:\n// - [ ] Added accessor.normalized, #691, #706\n// - [ ] Added glExtensionsUsed property and 5125 (UNSIGNED_INT) accessor.componentType value, #619\n// - [ ] Added extensionsRequired property, #720, #721\n// - [ ] Added \"STEP\" as valid animation.sampler.interpolation value, #712\n\n// Removals:\n// - [x] Removed buffer.type, #786, #629\n// - [ ] Removed revision number from profile.version, #709\n// - [ ] Removed technique.functions.scissor and removed 3089 (SCISSOR_TEST) as a valid value for technique.states.enable, #681\n// - [ ] Techniques, programs, and shaders were moved out to KHR_technique_webgl extension.\n\n// Other edits:\n// - [x] asset is now required, #642\n// - [ ] buffer.byteLength and bufferView.byteLength are now required, #560.\n// - [ ] accessor.min and accessor.max are now required, #593, and clarified that the JSON value and binary data must be the same, #628.\n// - [ ] Clarified animation.sampler and animation.channel restrictions, #712\n// - [ ] skin.inverseBindMatrices is now optional, #461.\n// - [ ] Attribute parameters can't have a value defined in the technique or parameter, #563 (comment).\n// - [ ] Only TEXCOORD and COLOR attribute semantics can be written in the form [semantic]_[set_index], #563 (comment).\n// - [ ] TEXCOORD and COLOR attribute semantics must be written in the form [semantic]_[set_index], e.g., just TEXCOORD should be TEXCOORD_0, and just COLOR should be COLOR_0, #649\n// - [ ] camera.perspective.aspectRatio and camera.perspective.yfov must now be > 0, not >= 0, #563 (comment).\n// - [ ] Application-specific parameter semantics must start with an underscore, e.g., _TEMPERATURE and _SIMULATION_TIME, #563 (comment).\n// - [ ] Properties in technique.parameters must be defined in technique.uniforms or technique.attributes,\n\n// #563 (comment).\n// - [ ] technique.parameter.count can only be defined when the semantic is JOINTMATRIX or an application-specific semantic is used. It can never be defined for attribute parameters; only uniforms, d2f6945\n// - [ ] technique.parameter.semantic is required when the parameter is an attribute, 28e113d\n// - [ ] Mesh-only models are allowed, e.g., without materials, #642\n// - [ ] Skeleton hierarchies (nodes containing jointName) must be separated from non-skeleton hierarchies., #647\n// - [ ] technique.states.functions.blendColor and technique.states.functions.depthRange parameters now must match WebGL function min/max, #707\n\nconst GLTF_ARRAYS = {\n  accessors: 'accessor',\n  animations: 'animation',\n  buffers: 'buffer',\n  bufferViews: 'bufferView',\n  images: 'image',\n  materials: 'material',\n  meshes: 'mesh',\n  nodes: 'node',\n  samplers: 'sampler',\n  scenes: 'scene',\n  skins: 'skin',\n  textures: 'texture'\n};\n\nconst GLTF_KEYS = {\n  accessor: 'accessors',\n  animations: 'animation',\n  buffer: 'buffers',\n  bufferView: 'bufferViews',\n  image: 'images',\n  material: 'materials',\n  mesh: 'meshes',\n  node: 'nodes',\n  sampler: 'samplers',\n  scene: 'scenes',\n  skin: 'skins',\n  texture: 'textures'\n};\n\n/**\n * Converts (normalizes) glTF v1 to v2\n */\nclass GLTFV1Normalizer {\n  idToIndexMap = {\n    animations: {},\n    accessors: {},\n    buffers: {},\n    bufferViews: {},\n    images: {},\n    materials: {},\n    meshes: {},\n    nodes: {},\n    samplers: {},\n    scenes: {},\n    skins: {},\n    textures: {}\n  };\n\n  json;\n\n  // constructor() {}\n\n  /**\n   * Convert (normalize) glTF < 2.0 to glTF 2.0\n   * @param gltf - object with json and binChunks\n   * @param options\n   * @param options normalize Whether to actually normalize\n   */\n  normalize(gltf, options) {\n    this.json = gltf.json;\n    const json = gltf.json;\n\n    // Check version\n    switch (json.asset && json.asset.version) {\n      // We are converting to v2 format. Return if there is nothing to do\n      case '2.0':\n        return;\n\n      // This class is written to convert 1.0\n      case undefined:\n      case '1.0':\n        break;\n\n      default:\n        // eslint-disable-next-line no-undef, no-console\n        console.warn(`glTF: Unknown version ${json.asset.version}`);\n        return;\n    }\n\n    if (!options.normalize) {\n      // We are still missing a few conversion tricks, remove once addressed\n      throw new Error('glTF v1 is not supported.');\n    }\n\n    // eslint-disable-next-line no-undef, no-console\n    console.warn('Converting glTF v1 to glTF v2 format. This is experimental and may fail.');\n\n    this._addAsset(json);\n\n    // In glTF2 top-level fields are Arrays not Object maps\n    this._convertTopLevelObjectsToArrays(json);\n\n    // Extract bufferView indices for images\n    // (this extension needs to be invoked early in the normalization process)\n    // TODO can this be handled by standard extension processing instead of called explicitly?\n    KHR_binary_glTF.preprocess(gltf);\n\n    // Convert object references from ids to indices\n    this._convertObjectIdsToArrayIndices(json);\n\n    this._updateObjects(json);\n\n    this._updateMaterial(json);\n  }\n\n  // asset is now required, #642 https://github.com/KhronosGroup/glTF/issues/639\n  _addAsset(json) {\n    json.asset = json.asset || {};\n    // We are normalizing to glTF v2, so change version to \"2.0\"\n    json.asset.version = '2.0';\n    json.asset.generator = json.asset.generator || 'Normalized to glTF 2.0 by loaders.gl';\n  }\n\n  _convertTopLevelObjectsToArrays(json) {\n    // TODO check that all arrays are covered\n    for (const arrayName in GLTF_ARRAYS) {\n      this._convertTopLevelObjectToArray(json, arrayName);\n    }\n  }\n\n  /** Convert one top level object to array */\n  _convertTopLevelObjectToArray(json, mapName) {\n    const objectMap = json[mapName];\n    if (!objectMap || Array.isArray(objectMap)) {\n      return;\n    }\n\n    // Rewrite the top-level field as an array\n    json[mapName] = [];\n    // Copy the map key into object.id\n    for (const id in objectMap) {\n      const object = objectMap[id];\n      object.id = object.id || id; // Mutates the loaded object\n      const index = json[mapName].length;\n      json[mapName].push(object);\n      this.idToIndexMap[mapName][id] = index;\n    }\n  }\n\n  /** Go through all objects in all top-level arrays and replace ids with indices */\n  _convertObjectIdsToArrayIndices(json) {\n    for (const arrayName in GLTF_ARRAYS) {\n      this._convertIdsToIndices(json, arrayName);\n    }\n    if ('scene' in json) {\n      json.scene = this._convertIdToIndex(json.scene, 'scene');\n    }\n\n    // Convert any index references that are not using array names\n\n    // texture.source (image)\n    for (const texture of json.textures) {\n      this._convertTextureIds(texture);\n    }\n    for (const mesh of json.meshes) {\n      this._convertMeshIds(mesh);\n    }\n    for (const node of json.nodes) {\n      this._convertNodeIds(node);\n    }\n    for (const node of json.scenes) {\n      this._convertSceneIds(node);\n    }\n  }\n\n  _convertTextureIds(texture) {\n    if (texture.source) {\n      texture.source = this._convertIdToIndex(texture.source, 'image');\n    }\n  }\n\n  _convertMeshIds(mesh) {\n    for (const primitive of mesh.primitives) {\n      const {attributes, indices, material} = primitive;\n      for (const attributeName in attributes) {\n        attributes[attributeName] = this._convertIdToIndex(attributes[attributeName], 'accessor');\n      }\n      if (indices) {\n        primitive.indices = this._convertIdToIndex(indices, 'accessor');\n      }\n      if (material) {\n        primitive.material = this._convertIdToIndex(material, 'material');\n      }\n    }\n  }\n\n  _convertNodeIds(node) {\n    if (node.children) {\n      node.children = node.children.map((child) => this._convertIdToIndex(child, 'node'));\n    }\n    if (node.meshes) {\n      node.meshes = node.meshes.map((mesh) => this._convertIdToIndex(mesh, 'mesh'));\n    }\n  }\n\n  _convertSceneIds(scene) {\n    if (scene.nodes) {\n      scene.nodes = scene.nodes.map((node) => this._convertIdToIndex(node, 'node'));\n    }\n  }\n\n  /** Go through all objects in a top-level array and replace ids with indices */\n  _convertIdsToIndices(json, topLevelArrayName) {\n    if (!json[topLevelArrayName]) {\n      console.warn(`gltf v1: json doesn't contain attribute ${topLevelArrayName}`); // eslint-disable-line no-console, no-undef\n      json[topLevelArrayName] = [];\n    }\n    for (const object of json[topLevelArrayName]) {\n      for (const key in object) {\n        const id = object[key];\n        const index = this._convertIdToIndex(id, key);\n        object[key] = index;\n      }\n    }\n  }\n\n  _convertIdToIndex(id, key) {\n    const arrayName = GLTF_KEYS[key];\n    if (arrayName in this.idToIndexMap) {\n      const index = this.idToIndexMap[arrayName][id];\n      if (!Number.isFinite(index)) {\n        throw new Error(`gltf v1: failed to resolve ${key} with id ${id}`);\n      }\n      return index;\n    }\n    return id;\n  }\n\n  /**\n   *\n   * @param {*} json\n   */\n  _updateObjects(json) {\n    for (const buffer of this.json.buffers) {\n      // - [x] Removed buffer.type, #786, #629\n      delete buffer.type;\n    }\n  }\n\n  /**\n   * Update material (set pbrMetallicRoughness)\n   * @param {*} json\n   */\n  _updateMaterial(json) {\n    for (const material of json.materials) {\n      material.pbrMetallicRoughness = {\n        baseColorFactor: [1, 1, 1, 1],\n        metallicFactor: 1,\n        roughnessFactor: 1\n      };\n\n      const textureId =\n        material.values?.tex || material.values?.texture2d_0 || material.values?.diffuseTex;\n      const textureIndex = json.textures.findIndex((texture) => texture.id === textureId);\n      if (textureIndex !== -1) {\n        material.pbrMetallicRoughness.baseColorTexture = {index: textureIndex};\n      }\n    }\n  }\n}\n\nexport function normalizeGLTFV1(gltf, options = {}) {\n  return new GLTFV1Normalizer().normalize(gltf, options);\n}\n", "import {assert} from '../utils/assert';\nimport {getAccessorArrayTypeAndLength} from '../gltf-utils/gltf-utils';\nimport {BufferView} from '../types/gltf-json-schema';\nimport {BufferView as BufferViewPostprocessed} from '../types/gltf-postprocessed-schema';\n\n// This is a post processor for loaded glTF files\n// The goal is to make the loaded data easier to use in WebGL applications\n//\n// Functions:\n// * Resolve indexed arrays structure of glTF into a linked tree.\n// * Translate stringified enum keys and values into WebGL constants.\n// * Load images (optional)\n\n// ENUM LOOKUP\n\nconst COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\n\nconst BYTES = {\n  5120: 1, // BYTE\n  5121: 1, // UNSIGNED_BYTE\n  5122: 2, // SHORT\n  5123: 2, // UNSIGNED_SHORT\n  5125: 4, // UNSIGNED_INT\n  5126: 4 // FLOAT\n};\n\nconst GL_SAMPLER = {\n  // Sampler parameters\n  TEXTURE_MAG_FILTER: 0x2800,\n  TEXTURE_MIN_FILTER: 0x2801,\n  TEXTURE_WRAP_S: 0x2802,\n  TEXTURE_WRAP_T: 0x2803,\n\n  // Sampler default values\n  REPEAT: 0x2901,\n  LINEAR: 0x2601,\n  NEAREST_MIPMAP_LINEAR: 0x2702\n};\n\nconst SAMPLER_PARAMETER_GLTF_TO_GL = {\n  magFilter: GL_SAMPLER.TEXTURE_MAG_FILTER,\n  minFilter: GL_SAMPLER.TEXTURE_MIN_FILTER,\n  wrapS: GL_SAMPLER.TEXTURE_WRAP_S,\n  wrapT: GL_SAMPLER.TEXTURE_WRAP_T\n};\n\n// When undefined, a sampler with repeat wrapping and auto filtering should be used.\n// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#texture\nconst DEFAULT_SAMPLER = {\n  [GL_SAMPLER.TEXTURE_MAG_FILTER]: GL_SAMPLER.LINEAR,\n  [GL_SAMPLER.TEXTURE_MIN_FILTER]: GL_SAMPLER.NEAREST_MIPMAP_LINEAR,\n  [GL_SAMPLER.TEXTURE_WRAP_S]: GL_SAMPLER.REPEAT,\n  [GL_SAMPLER.TEXTURE_WRAP_T]: GL_SAMPLER.REPEAT\n};\n\nfunction getBytesFromComponentType(componentType) {\n  return BYTES[componentType];\n}\n\nfunction getSizeFromAccessorType(type) {\n  return COMPONENTS[type];\n}\n\nclass GLTFPostProcessor {\n  baseUri: string = '';\n  json: Record<string, any> = {};\n  buffers: [] = [];\n  images: [] = [];\n\n  postProcess(gltf, options = {}) {\n    const {json, buffers = [], images = [], baseUri = ''} = gltf;\n    assert(json);\n\n    this.baseUri = baseUri;\n    this.json = json;\n    this.buffers = buffers;\n    this.images = images;\n\n    this._resolveTree(this.json, options);\n\n    return this.json;\n  }\n\n  // Convert indexed glTF structure into tree structure\n  // cross-link index resolution, enum lookup, convenience calculations\n  // eslint-disable-next-line complexity\n  _resolveTree(json, options = {}) {\n    if (json.bufferViews) {\n      json.bufferViews = json.bufferViews.map((bufView, i) => this._resolveBufferView(bufView, i));\n    }\n    if (json.images) {\n      json.images = json.images.map((image, i) => this._resolveImage(image, i));\n    }\n    if (json.samplers) {\n      json.samplers = json.samplers.map((sampler, i) => this._resolveSampler(sampler, i));\n    }\n    if (json.textures) {\n      json.textures = json.textures.map((texture, i) => this._resolveTexture(texture, i));\n    }\n    if (json.accessors) {\n      json.accessors = json.accessors.map((accessor, i) => this._resolveAccessor(accessor, i));\n    }\n    if (json.materials) {\n      json.materials = json.materials.map((material, i) => this._resolveMaterial(material, i));\n    }\n    if (json.meshes) {\n      json.meshes = json.meshes.map((mesh, i) => this._resolveMesh(mesh, i));\n    }\n    if (json.nodes) {\n      json.nodes = json.nodes.map((node, i) => this._resolveNode(node, i));\n    }\n    if (json.skins) {\n      json.skins = json.skins.map((skin, i) => this._resolveSkin(skin, i));\n    }\n    if (json.scenes) {\n      json.scenes = json.scenes.map((scene, i) => this._resolveScene(scene, i));\n    }\n    if (json.scene !== undefined) {\n      json.scene = json.scenes[this.json.scene];\n    }\n  }\n\n  getScene(index) {\n    return this._get('scenes', index);\n  }\n\n  getNode(index) {\n    return this._get('nodes', index);\n  }\n\n  getSkin(index) {\n    return this._get('skins', index);\n  }\n\n  getMesh(index) {\n    return this._get('meshes', index);\n  }\n\n  getMaterial(index) {\n    return this._get('materials', index);\n  }\n\n  getAccessor(index) {\n    return this._get('accessors', index);\n  }\n\n  getCamera(index) {\n    return null; // TODO: fix this\n  }\n\n  getTexture(index) {\n    return this._get('textures', index);\n  }\n\n  getSampler(index) {\n    return this._get('samplers', index);\n  }\n\n  getImage(index) {\n    return this._get('images', index);\n  }\n\n  getBufferView(index) {\n    return this._get('bufferViews', index);\n  }\n\n  getBuffer(index) {\n    return this._get('buffers', index);\n  }\n\n  _get(array, index) {\n    // check if already resolved\n    if (typeof index === 'object') {\n      return index;\n    }\n    const object = this.json[array] && this.json[array][index];\n    if (!object) {\n      console.warn(`glTF file error: Could not find ${array}[${index}]`); // eslint-disable-line\n    }\n    return object;\n  }\n\n  // PARSING HELPERS\n\n  _resolveScene(scene, index) {\n    // scene = {...scene};\n    scene.id = scene.id || `scene-${index}`;\n    scene.nodes = (scene.nodes || []).map((node) => this.getNode(node));\n    return scene;\n  }\n\n  _resolveNode(node, index) {\n    // node = {...node};\n    node.id = node.id || `node-${index}`;\n    if (node.children) {\n      node.children = node.children.map((child) => this.getNode(child));\n    }\n    if (node.mesh !== undefined) {\n      node.mesh = this.getMesh(node.mesh);\n    } else if (node.meshes !== undefined && node.meshes.length) {\n      node.mesh = node.meshes.reduce(\n        (accum, meshIndex) => {\n          const mesh = this.getMesh(meshIndex);\n          accum.id = mesh.id;\n          accum.primitives = accum.primitives.concat(mesh.primitives);\n          return accum;\n        },\n        {primitives: []}\n      );\n    }\n    if (node.camera !== undefined) {\n      node.camera = this.getCamera(node.camera);\n    }\n    if (node.skin !== undefined) {\n      node.skin = this.getSkin(node.skin);\n    }\n    return node;\n  }\n\n  _resolveSkin(skin, index) {\n    // skin = {...skin};\n    skin.id = skin.id || `skin-${index}`;\n    skin.inverseBindMatrices = this.getAccessor(skin.inverseBindMatrices);\n    return skin;\n  }\n\n  _resolveMesh(mesh, index) {\n    // mesh = {...mesh};\n    mesh.id = mesh.id || `mesh-${index}`;\n    if (mesh.primitives) {\n      mesh.primitives = mesh.primitives.map((primitive) => {\n        primitive = {...primitive};\n        const attributes = primitive.attributes;\n        primitive.attributes = {};\n        for (const attribute in attributes) {\n          primitive.attributes[attribute] = this.getAccessor(attributes[attribute]);\n        }\n        if (primitive.indices !== undefined) {\n          primitive.indices = this.getAccessor(primitive.indices);\n        }\n        if (primitive.material !== undefined) {\n          primitive.material = this.getMaterial(primitive.material);\n        }\n        return primitive;\n      });\n    }\n    return mesh;\n  }\n\n  _resolveMaterial(material, index) {\n    // material = {...material};\n    material.id = material.id || `material-${index}`;\n    if (material.normalTexture) {\n      material.normalTexture = {...material.normalTexture};\n      material.normalTexture.texture = this.getTexture(material.normalTexture.index);\n    }\n    if (material.occlusionTexture) {\n      material.occlustionTexture = {...material.occlustionTexture};\n      material.occlusionTexture.texture = this.getTexture(material.occlusionTexture.index);\n    }\n    if (material.emissiveTexture) {\n      material.emmisiveTexture = {...material.emmisiveTexture};\n      material.emissiveTexture.texture = this.getTexture(material.emissiveTexture.index);\n    }\n    if (!material.emissiveFactor) {\n      material.emissiveFactor = material.emmisiveTexture ? [1, 1, 1] : [0, 0, 0];\n    }\n\n    if (material.pbrMetallicRoughness) {\n      material.pbrMetallicRoughness = {...material.pbrMetallicRoughness};\n      const mr = material.pbrMetallicRoughness;\n      if (mr.baseColorTexture) {\n        mr.baseColorTexture = {...mr.baseColorTexture};\n        mr.baseColorTexture.texture = this.getTexture(mr.baseColorTexture.index);\n      }\n      if (mr.metallicRoughnessTexture) {\n        mr.metallicRoughnessTexture = {...mr.metallicRoughnessTexture};\n        mr.metallicRoughnessTexture.texture = this.getTexture(mr.metallicRoughnessTexture.index);\n      }\n    }\n    return material;\n  }\n\n  _resolveAccessor(accessor, index) {\n    // accessor = {...accessor};\n    accessor.id = accessor.id || `accessor-${index}`;\n    if (accessor.bufferView !== undefined) {\n      // Draco encoded meshes don't have bufferView\n      accessor.bufferView = this.getBufferView(accessor.bufferView);\n    }\n\n    // Look up enums\n    accessor.bytesPerComponent = getBytesFromComponentType(accessor.componentType);\n    accessor.components = getSizeFromAccessorType(accessor.type);\n    accessor.bytesPerElement = accessor.bytesPerComponent * accessor.components;\n\n    // Create TypedArray for the accessor\n    // Note: The canonical way to instantiate is to ignore this array and create\n    // WebGLBuffer's using the bufferViews.\n    if (accessor.bufferView) {\n      const buffer = accessor.bufferView.buffer;\n      const {ArrayType, byteLength} = getAccessorArrayTypeAndLength(accessor, accessor.bufferView);\n      const byteOffset =\n        (accessor.bufferView.byteOffset || 0) + (accessor.byteOffset || 0) + buffer.byteOffset;\n      let cutBuffer = buffer.arrayBuffer.slice(byteOffset, byteOffset + byteLength);\n      if (accessor.bufferView.byteStride) {\n        cutBuffer = this._getValueFromInterleavedBuffer(\n          buffer,\n          byteOffset,\n          accessor.bufferView.byteStride,\n          accessor.bytesPerElement,\n          accessor.count\n        );\n      }\n      accessor.value = new ArrayType(cutBuffer);\n    }\n\n    return accessor;\n  }\n\n  /**\n   * Take values of particular accessor from interleaved buffer\n   * various parts of the buffer\n   * @param buffer\n   * @param byteOffset\n   * @param byteStride\n   * @param bytesPerElement\n   * @param count\n   * @returns\n   */\n  _getValueFromInterleavedBuffer(buffer, byteOffset, byteStride, bytesPerElement, count) {\n    const result = new Uint8Array(count * bytesPerElement);\n    for (let i = 0; i < count; i++) {\n      const elementOffset = byteOffset + i * byteStride;\n      result.set(\n        new Uint8Array(buffer.arrayBuffer.slice(elementOffset, elementOffset + bytesPerElement)),\n        i * bytesPerElement\n      );\n    }\n    return result.buffer;\n  }\n\n  _resolveTexture(texture, index) {\n    // texture = {...texture};\n    texture.id = texture.id || `texture-${index}`;\n    texture.sampler = 'sampler' in texture ? this.getSampler(texture.sampler) : DEFAULT_SAMPLER;\n    texture.source = this.getImage(texture.source);\n    return texture;\n  }\n\n  _resolveSampler(sampler, index) {\n    // sampler = {...sampler};\n    sampler.id = sampler.id || `sampler-${index}`;\n    // Map textual parameters to GL parameter values\n    sampler.parameters = {};\n    for (const key in sampler) {\n      const glEnum = this._enumSamplerParameter(key);\n      if (glEnum !== undefined) {\n        sampler.parameters[glEnum] = sampler[key];\n      }\n    }\n    return sampler;\n  }\n\n  _enumSamplerParameter(key) {\n    return SAMPLER_PARAMETER_GLTF_TO_GL[key];\n  }\n\n  _resolveImage(image, index) {\n    // image = {...image};\n    image.id = image.id || `image-${index}`;\n    if (image.bufferView !== undefined) {\n      image.bufferView = this.getBufferView(image.bufferView);\n    }\n\n    // Check if image has been preloaded by the GLTFLoader\n    // If so, link it into the JSON and drop the URI\n    const preloadedImage = this.images[index];\n    if (preloadedImage) {\n      image.image = preloadedImage;\n    }\n\n    return image;\n  }\n\n  _resolveBufferView(bufferView: BufferView, index: number): BufferViewPostprocessed {\n    // bufferView = {...bufferView};\n    const bufferIndex = bufferView.buffer;\n    const result: BufferViewPostprocessed = {\n      id: `bufferView-${index}`,\n      ...bufferView,\n      buffer: this.buffers[bufferIndex]\n    };\n\n    // @ts-expect-error\n    const arrayBuffer = this.buffers[bufferIndex].arrayBuffer;\n    // @ts-expect-error\n    let byteOffset = this.buffers[bufferIndex].byteOffset || 0;\n\n    if ('byteOffset' in bufferView) {\n      byteOffset += bufferView.byteOffset;\n    }\n\n    result.data = new Uint8Array(arrayBuffer, byteOffset, bufferView.byteLength);\n    return result;\n  }\n\n  _resolveCamera(camera, index) {\n    camera.id = camera.id || `camera-${index}`;\n    // TODO - create 4x4 matrices\n    if (camera.perspective) {\n      // camera.matrix = createPerspectiveMatrix(camera.perspective);\n    }\n    if (camera.orthographic) {\n      // camera.matrix = createOrthographicMatrix(camera.orthographic);\n    }\n    return camera;\n  }\n}\n\nexport function postProcessGLTF(gltf, options?) {\n  return new GLTFPostProcessor().postProcess(gltf, options);\n}\n", "/* eslint-disable camelcase, max-statements */\n// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#glb-file-format-specification\n// https://github.com/KhronosGroup/glTF/tree/master/extensions/1.0/Khronos/KHR_binary_glTF\nimport type {GLB} from '../types/glb-types';\nimport {padToNBytes, assert} from '@loaders.gl/loader-utils';\n\nexport type GLBParseOptions = {\n  magic?: number;\n  strict?: boolean;\n};\n\nconst MAGIC_glTF = 0x676c5446; // glTF in Big-Endian ASCII\n\nconst GLB_FILE_HEADER_SIZE = 12;\nconst GLB_CHUNK_HEADER_SIZE = 8;\n\nconst GLB_CHUNK_TYPE_JSON = 0x4e4f534a;\nconst GLB_CHUNK_TYPE_BIN = 0x004e4942;\nconst GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED = 0; // DEPRECATED - Backward compatibility for old xviz files\nconst GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED = 1; // DEPRECATED - Backward compatibility for old xviz files\n\nconst GLB_V1_CONTENT_FORMAT_JSON = 0x0;\n\nconst LE = true; // Binary GLTF is little endian.\n\nfunction getMagicString(dataView, byteOffset = 0) {\n  return `\\\n${String.fromCharCode(dataView.getUint8(byteOffset + 0))}\\\n${String.fromCharCode(dataView.getUint8(byteOffset + 1))}\\\n${String.fromCharCode(dataView.getUint8(byteOffset + 2))}\\\n${String.fromCharCode(dataView.getUint8(byteOffset + 3))}`;\n}\n\n// Check if a data view is a GLB\nexport function isGLB(\n  arrayBuffer: ArrayBuffer,\n  byteOffset: number = 0,\n  options: GLBParseOptions = {}\n): boolean {\n  const dataView = new DataView(arrayBuffer);\n  // Check that GLB Header starts with the magic number\n  const {magic = MAGIC_glTF} = options;\n  const magic1 = dataView.getUint32(byteOffset, false);\n  return magic1 === magic || magic1 === MAGIC_glTF;\n}\n\nexport default function parseGLBSync(\n  glb: GLB,\n  arrayBuffer: ArrayBuffer,\n  byteOffset: number = 0,\n  options: GLBParseOptions = {}\n) {\n  // Check that GLB Header starts with the magic number\n  const dataView = new DataView(arrayBuffer);\n\n  // Compare format with GLBLoader documentation\n  const type = getMagicString(dataView, byteOffset + 0);\n  const version = dataView.getUint32(byteOffset + 4, LE); // Version 2 of binary glTF container format\n  const byteLength = dataView.getUint32(byteOffset + 8, LE); // Total byte length of binary file\n\n  Object.assign(glb, {\n    // Put less important stuff in a header, to avoid clutter\n    header: {\n      byteOffset, // Byte offset into the initial arrayBuffer\n      byteLength,\n      hasBinChunk: false\n    },\n\n    type,\n    version,\n\n    json: {},\n    binChunks: []\n  } as GLB);\n\n  byteOffset += GLB_FILE_HEADER_SIZE;\n\n  switch (glb.version) {\n    case 1:\n      // eslint-disable-next-line\n      return parseGLBV1(glb, dataView, byteOffset);\n    case 2:\n      // eslint-disable-next-line\n      return parseGLBV2(glb, dataView, byteOffset, (options = {}));\n    default:\n      throw new Error(`Invalid GLB version ${glb.version}. Only supports v1 and v2.`);\n  }\n}\n\nfunction parseGLBV1(glb: GLB, dataView: DataView, byteOffset: number): number {\n  // Sanity: ensure file is big enough to hold at least the headers\n  assert(glb.header.byteLength > GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE);\n\n  // Explanation of GLB structure:\n  // https://cloud.githubusercontent.com/assets/3479527/22600725/36b87122-ea55-11e6-9d40-6fd42819fcab.png\n  const contentLength = dataView.getUint32(byteOffset + 0, LE); // Byte length of chunk\n  const contentFormat = dataView.getUint32(byteOffset + 4, LE); // Chunk format as uint32\n  byteOffset += GLB_CHUNK_HEADER_SIZE;\n\n  // GLB v1 only supports a single chunk type\n  assert(contentFormat === GLB_V1_CONTENT_FORMAT_JSON);\n\n  parseJSONChunk(glb, dataView, byteOffset, contentLength);\n  // No need to call the function padToBytes() from parseJSONChunk()\n  byteOffset += contentLength;\n  byteOffset += parseBINChunk(glb, dataView, byteOffset, glb.header.byteLength);\n\n  return byteOffset;\n}\n\nfunction parseGLBV2(\n  glb: GLB,\n  dataView: DataView,\n  byteOffset: number,\n  options: GLBParseOptions\n): number {\n  // Sanity: ensure file is big enough to hold at least the first chunk header\n  assert(glb.header.byteLength > GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE);\n\n  parseGLBChunksSync(glb, dataView, byteOffset, options);\n\n  return byteOffset + glb.header.byteLength;\n}\n\nfunction parseGLBChunksSync(\n  glb: GLB,\n  dataView: DataView,\n  byteOffset: number,\n  options: GLBParseOptions\n) {\n  // Per spec we must iterate over chunks, ignoring all except JSON and BIN\n  // Iterate as long as there is space left for another chunk header\n  while (byteOffset + 8 <= glb.header.byteLength) {\n    const chunkLength = dataView.getUint32(byteOffset + 0, LE); // Byte length of chunk\n    const chunkFormat = dataView.getUint32(byteOffset + 4, LE); // Chunk format as uint32\n    byteOffset += GLB_CHUNK_HEADER_SIZE;\n\n    // Per spec we must iterate over chunks, ignoring all except JSON and BIN\n    switch (chunkFormat) {\n      case GLB_CHUNK_TYPE_JSON:\n        parseJSONChunk(glb, dataView, byteOffset, chunkLength);\n        break;\n      case GLB_CHUNK_TYPE_BIN:\n        parseBINChunk(glb, dataView, byteOffset, chunkLength);\n        break;\n\n      // Backward compatibility for very old xviz files\n      case GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED:\n        if (!options.strict) {\n          parseJSONChunk(glb, dataView, byteOffset, chunkLength);\n        }\n        break;\n      case GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED:\n        if (!options.strict) {\n          parseBINChunk(glb, dataView, byteOffset, chunkLength);\n        }\n        break;\n\n      default:\n        // Ignore, per spec\n        // console.warn(`Unknown GLB chunk type`); // eslint-disable-line\n        break;\n    }\n\n    byteOffset += padToNBytes(chunkLength, 4);\n  }\n\n  return byteOffset;\n}\n\n// Parse a GLB JSON chunk\nfunction parseJSONChunk(glb: GLB, dataView: DataView, byteOffset: number, chunkLength: number) {\n  // 1. Create a \"view\" of the binary encoded JSON data inside the GLB\n  const jsonChunk = new Uint8Array(dataView.buffer, byteOffset, chunkLength);\n\n  // 2. Decode the JSON binary array into clear text\n  const textDecoder = new TextDecoder('utf8');\n  const jsonText = textDecoder.decode(jsonChunk);\n\n  // 3. Parse the JSON text into a JavaScript data structure\n  glb.json = JSON.parse(jsonText);\n\n  return padToNBytes(chunkLength, 4);\n}\n\n// Parse a GLB BIN chunk\nfunction parseBINChunk(glb: GLB, dataView, byteOffset, chunkLength) {\n  // Note: BIN chunk can be optional\n  glb.header.hasBinChunk = true;\n  glb.binChunks.push({\n    byteOffset,\n    byteLength: chunkLength,\n    arrayBuffer: dataView.buffer\n    // TODO - copy, or create typed array view?\n  });\n\n  return padToNBytes(chunkLength, 4);\n}\n", "/* eslint-disable camelcase, max-statements, no-restricted-globals */\nimport type {LoaderContext} from '@loaders.gl/loader-utils';\nimport {BasisLoader, selectSupportedBasisFormat} from '@loaders.gl/textures';\nimport type {GLTFLoaderOptions} from '../../gltf-loader';\nimport type {GLB} from '../types/glb-types';\nimport type {GLTFWithBuffers} from '../types/gltf-types';\n\nimport {ImageLoader} from '@loaders.gl/images';\nimport {parseJSON, sliceArrayBuffer} from '@loaders.gl/loader-utils';\nimport {assert} from '../utils/assert';\nimport {resolveUrl} from '../gltf-utils/resolve-url';\nimport {getTypedArrayForBufferView} from '../gltf-utils/get-typed-array';\nimport {preprocessExtensions, decodeExtensions} from '../api/gltf-extensions';\nimport {normalizeGLTFV1} from '../api/normalize-gltf-v1';\nimport {postProcessGLTF} from '../api/post-process-gltf';\nimport parseGLBSync, {isGLB} from './parse-glb';\n\nexport type GLTFParseOptions = {\n  normalize?: boolean;\n  loadImages?: boolean;\n  loadBuffers?: boolean;\n  decompressMeshes?: boolean;\n  postProcess?: boolean;\n  excludeExtensions?: string[];\n};\n\n// export type GLTFOptions = {\n//   gltf?: GLTFParseOptions;\n// };\n\nexport function isGLTF(arrayBuffer, options?): boolean {\n  const byteOffset = 0;\n  return isGLB(arrayBuffer, byteOffset, options);\n}\n\nexport async function parseGLTF(\n  gltf: GLTFWithBuffers,\n  arrayBufferOrString,\n  byteOffset = 0,\n  options: GLTFLoaderOptions,\n  context: LoaderContext\n) {\n  parseGLTFContainerSync(gltf, arrayBufferOrString, byteOffset, options);\n\n  normalizeGLTFV1(gltf, {normalize: options?.gltf?.normalize});\n\n  preprocessExtensions(gltf, options, context);\n\n  const promises: Promise<any>[] = [];\n\n  // Load linked buffers asynchronously and decodes base64 buffers in parallel\n  if (options?.gltf?.loadBuffers && gltf.json.buffers) {\n    await loadBuffers(gltf, options, context);\n  }\n\n  if (options?.gltf?.loadImages) {\n    const promise = loadImages(gltf, options, context);\n    promises.push(promise);\n  }\n\n  const promise = decodeExtensions(gltf, options, context);\n  promises.push(promise);\n\n  // Parallelize image loading and buffer loading/extension decoding\n  await Promise.all(promises);\n\n  // Post processing resolves indices to objects, buffers\n  return options?.gltf?.postProcess ? postProcessGLTF(gltf, options) : gltf;\n}\n\n// `data` - can be ArrayBuffer (GLB), ArrayBuffer (Binary JSON), String (JSON), or Object (parsed JSON)\nfunction parseGLTFContainerSync(gltf, data, byteOffset, options) {\n  // Initialize gltf container\n  if (options.uri) {\n    gltf.baseUri = options.uri;\n  }\n\n  // If data is binary and starting with magic bytes, assume binary JSON text, convert to string\n  if (data instanceof ArrayBuffer && !isGLB(data, byteOffset, options)) {\n    const textDecoder = new TextDecoder();\n    data = textDecoder.decode(data);\n  }\n\n  if (typeof data === 'string') {\n    // If string, try to parse as JSON\n    gltf.json = parseJSON(data);\n  } else if (data instanceof ArrayBuffer) {\n    // If still ArrayBuffer, parse as GLB container\n    const glb: GLB = {} as GLB;\n    byteOffset = parseGLBSync(glb, data, byteOffset, options.glb);\n\n    assert(glb.type === 'glTF', `Invalid GLB magic string ${glb.type}`);\n\n    gltf._glb = glb;\n    gltf.json = glb.json;\n  } else {\n    assert(false, 'GLTF: must be ArrayBuffer or string');\n  }\n\n  // Populate buffers\n  // Create an external buffers array to hold binary data\n  const buffers = gltf.json.buffers || [];\n  gltf.buffers = new Array(buffers.length).fill(null);\n\n  // Populates JSON and some bin chunk info\n  if (gltf._glb && gltf._glb.header.hasBinChunk) {\n    const {binChunks} = gltf._glb;\n    gltf.buffers[0] = {\n      arrayBuffer: binChunks[0].arrayBuffer,\n      byteOffset: binChunks[0].byteOffset,\n      byteLength: binChunks[0].byteLength\n    };\n\n    // TODO - this modifies JSON and is a post processing thing\n    // gltf.json.buffers[0].data = gltf.buffers[0].arrayBuffer;\n    // gltf.json.buffers[0].byteOffset = gltf.buffers[0].byteOffset;\n  }\n\n  // Populate images\n  const images = gltf.json.images || [];\n  gltf.images = new Array(images.length).fill({});\n}\n\n/** Asynchronously fetch and parse buffers, store in buffers array outside of json\n * TODO - traverse gltf and determine which buffers are actually needed\n */\nasync function loadBuffers(gltf: GLTFWithBuffers, options, context: LoaderContext) {\n  // TODO\n  const buffers = gltf.json.buffers || [];\n  for (let i = 0; i < buffers.length; ++i) {\n    const buffer = buffers[i];\n    if (buffer.uri) {\n      const {fetch} = context;\n      assert(fetch);\n\n      const uri = resolveUrl(buffer.uri, options);\n      const response = await context?.fetch?.(uri);\n      const arrayBuffer = await response?.arrayBuffer?.();\n\n      gltf.buffers[i] = {\n        arrayBuffer,\n        byteOffset: 0,\n        byteLength: arrayBuffer.byteLength\n      };\n\n      delete buffer.uri;\n    } else if (gltf.buffers[i] === null) {\n      gltf.buffers[i] = {\n        arrayBuffer: new ArrayBuffer(buffer.byteLength),\n        byteOffset: 0,\n        byteLength: buffer.byteLength\n      };\n    }\n  }\n}\n\n/**\n * Loads all images\n * TODO - traverse gltf and determine which images are actually needed\n * @param gltf\n * @param options\n * @param context\n * @returns\n */\nasync function loadImages(gltf: GLTFWithBuffers, options, context: LoaderContext) {\n  const imageIndices = getReferencesImageIndices(gltf);\n\n  const images = gltf.json.images || [];\n\n  const promises: Promise<any>[] = [];\n  for (const imageIndex of imageIndices) {\n    promises.push(loadImage(gltf, images[imageIndex], imageIndex, options, context));\n  }\n\n  return await Promise.all(promises);\n}\n\n/** Make sure we only load images that are actually referenced by textures */\nfunction getReferencesImageIndices(gltf: GLTFWithBuffers): number[] {\n  const imageIndices = new Set<number>();\n\n  const textures = gltf.json.textures || [];\n  for (const texture of textures) {\n    if (texture.source !== undefined) {\n      imageIndices.add(texture.source);\n    }\n  }\n\n  return Array.from(imageIndices).sort();\n}\n\n/** Asynchronously fetches and parses one image, store in images array outside of json */\nasync function loadImage(\n  gltf: GLTFWithBuffers,\n  image,\n  index: number,\n  options,\n  context: LoaderContext\n) {\n  const {fetch, parse} = context;\n\n  let arrayBuffer;\n\n  if (image.uri && !image.hasOwnProperty('bufferView')) {\n    const uri = resolveUrl(image.uri, options);\n    const response = await fetch(uri);\n    arrayBuffer = await response.arrayBuffer();\n    image.bufferView = {\n      data: arrayBuffer\n    };\n  }\n\n  if (Number.isFinite(image.bufferView)) {\n    const array = getTypedArrayForBufferView(gltf.json, gltf.buffers, image.bufferView);\n    arrayBuffer = sliceArrayBuffer(array.buffer, array.byteOffset, array.byteLength);\n  }\n\n  assert(arrayBuffer, 'glTF image has no data');\n\n  // Call `parse`\n  let parsedImage = await parse(\n    arrayBuffer,\n    [ImageLoader, BasisLoader],\n    {mimeType: image.mimeType, basis: options.basis || {format: selectSupportedBasisFormat()}},\n    context\n  );\n\n  if (parsedImage && parsedImage[0]) {\n    parsedImage = {\n      compressed: true,\n      mipmaps: false,\n      width: parsedImage[0].width,\n      height: parsedImage[0].height,\n      data: parsedImage[0]\n    };\n  }\n  // TODO making sure ImageLoader is overridable by using array of loaders\n  // const parsedImage = await parse(arrayBuffer, [ImageLoader]);\n\n  // Store the loaded image\n  gltf.images = gltf.images || [];\n  gltf.images[index] = parsedImage;\n}\n", "import type {LoaderWithParser, LoaderOptions} from '@loaders.gl/loader-utils';\nimport type {DracoLoaderOptions} from '@loaders.gl/draco';\nimport {VERSION} from './lib/utils/version';\nimport type {ImageLoaderOptions} from '@loaders.gl/images';\nimport type {TextureLoaderOptions} from '@loaders.gl/textures';\nimport type {GLTFParseOptions} from './lib/parsers/parse-gltf';\nimport type {GLTFWithBuffers} from './lib/types/gltf-types';\nimport {parseGLTF} from './lib/parsers/parse-gltf';\nimport {GLBLoaderOptions} from './glb-loader';\n\n/**\n * GLTF loader options\n */\nexport type GLTFLoaderOptions = LoaderOptions &\n  ImageLoaderOptions &\n  TextureLoaderOptions &\n  GLBLoaderOptions &\n  DracoLoaderOptions & {\n    gltf?: GLTFParseOptions;\n  };\n\n/**\n * GLTF loader\n */\nexport const GLTFLoader: LoaderWithParser = {\n  name: 'glTF',\n  id: 'gltf',\n  module: 'gltf',\n  version: VERSION,\n  extensions: ['gltf', 'glb'],\n  mimeTypes: ['model/gltf+json', 'model/gltf-binary'],\n\n  text: true,\n  binary: true,\n  tests: ['glTF'],\n  parse,\n\n  options: {\n    gltf: {\n      normalize: true, // Normalize glTF v1 to glTF v2 format (not yet stable)\n      loadBuffers: true, // Fetch any linked .BIN buffers, decode base64\n      loadImages: true, // Create image objects\n      decompressMeshes: true, // Decompress Draco encoded meshes\n      postProcess: true // Postprocess glTF and return json structure directly\n    },\n\n    // common?\n    log: console // eslint-disable-line\n  },\n  deprecatedOptions: {\n    fetchImages: 'gltf.loadImages',\n    createImages: 'gltf.loadImages',\n    decompress: 'gltf.decompressMeshes',\n    postProcess: 'gltf.postProcess',\n    gltf: {\n      decompress: 'gltf.decompressMeshes'\n    }\n  }\n};\n\nexport async function parse(arrayBuffer, options: GLTFLoaderOptions = {}, context) {\n  // Apps can call the parse method directly, we so apply default options here\n  options = {...GLTFLoader.options, ...options};\n  // @ts-ignore\n  options.gltf = {...GLTFLoader.options.gltf, ...options.gltf};\n\n  const {byteOffset = 0} = options;\n  const gltf = {};\n  return await parseGLTF(gltf as GLTFWithBuffers, arrayBuffer, byteOffset, options, context);\n}\n", "/* eslint-disable camelcase, max-statements */\nimport {\n  copyPaddedStringToDataView,\n  copyPaddedArrayBufferToDataView\n} from '@loaders.gl/loader-utils';\n\nconst MAGIC_glTF = 0x46546c67; // glTF in ASCII\nconst MAGIC_JSON = 0x4e4f534a; // JSON in ASCII\nconst MAGIC_BIN = 0x004e4942; // BIN\\0 in ASCII\n\nconst LE = true; // Binary GLTF is little endian.\n\n// Encode the full GLB buffer with header etc\n// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#\n// glb-file-format-specification\nexport default function encodeGLBSync(glb, dataView, byteOffset = 0, options = {}) {\n  const {magic = MAGIC_glTF, version = 2, json = {}, binary} = glb;\n\n  const byteOffsetStart = byteOffset;\n\n  // Write GLB Header\n  if (dataView) {\n    dataView.setUint32(byteOffset + 0, magic, LE); // Magic number (the ASCII string 'glTF').\n    dataView.setUint32(byteOffset + 4, version, LE); // Version 2 of binary glTF container format uint32\n    dataView.setUint32(byteOffset + 8, 0, LE); // Total byte length of generated file (uint32), will be set last\n  }\n  const byteOffsetFileLength = byteOffset + 8;\n  byteOffset += 12; // GLB_FILE_HEADER_SIZE\n\n  // Write the JSON chunk header\n  const byteOffsetJsonHeader = byteOffset;\n  if (dataView) {\n    dataView.setUint32(byteOffset + 0, 0, LE); // Byte length of json chunk (will be written later)\n    dataView.setUint32(byteOffset + 4, MAGIC_JSON, LE); // Chunk type\n  }\n  byteOffset += 8; // GLB_CHUNK_HEADER_SIZE\n\n  // Write the JSON chunk\n  const jsonString = JSON.stringify(json);\n  byteOffset = copyPaddedStringToDataView(dataView, byteOffset, jsonString, 4);\n\n  // Now we know the JSON chunk length so we can write it.\n  if (dataView) {\n    const jsonByteLength = byteOffset - byteOffsetJsonHeader - 8; // GLB_CHUNK_HEADER_SIZE\n    dataView.setUint32(byteOffsetJsonHeader + 0, jsonByteLength, LE); // Byte length of json chunk (uint32)\n  }\n\n  // Write the BIN chunk if present. The BIN chunk is optional.\n  if (binary) {\n    const byteOffsetBinHeader = byteOffset;\n\n    // Write the BIN chunk header\n    if (dataView) {\n      dataView.setUint32(byteOffset + 0, 0, LE); // Byte length BIN (uint32)\n      dataView.setUint32(byteOffset + 4, MAGIC_BIN, LE); // Chunk type\n    }\n    byteOffset += 8; // GLB_CHUNK_HEADER_SIZE\n\n    byteOffset = copyPaddedArrayBufferToDataView(dataView, byteOffset, binary, 4);\n\n    // Now we know the BIN chunk length so we can write it.\n    if (dataView) {\n      const binByteLength = byteOffset - byteOffsetBinHeader - 8; // GLB_CHUNK_HEADER_SIZE\n      dataView.setUint32(byteOffsetBinHeader + 0, binByteLength, LE); // Byte length BIN (uint32)\n    }\n  }\n\n  // Now we know the glb file length so we can write it.\n  if (dataView) {\n    const fileByteLength = byteOffset - byteOffsetStart;\n    dataView.setUint32(byteOffsetFileLength, fileByteLength, LE); // Total byte length of generated file (uint32)\n  }\n\n  return byteOffset;\n}\n", "import encodeGLBSync from './encode-glb';\n\n// Encode the full glTF file as a binary GLB file\n// Returns an ArrayBuffer that represents the complete GLB image that can be saved to file\n//\n// TODO - Does not support encoding to non-GLB versions of glTF format\n// - Encode as a textual JSON file with binary data in base64 data URLs.\n// - Encode as a JSON with all images (and buffers?) in separate binary files\n//\n// glb-file-format-specification\n// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#\n\nexport function encodeGLTFSync(gltf, arrayBuffer, byteOffset, options) {\n  convertBuffersToBase64(gltf);\n\n  // TODO: Copy buffers to binary\n\n  return encodeGLBSync(gltf, arrayBuffer, byteOffset, options);\n}\n\nfunction convertBuffersToBase64(gltf, {firstBuffer = 0} = {}) {\n  if (gltf.buffers && gltf.buffers.length > firstBuffer) {\n    throw new Error('encodeGLTF: multiple buffers not yet implemented');\n  }\n}\n", "import type {Writer, WriterOptions} from '@loaders.gl/loader-utils';\nimport {VERSION} from './lib/utils/version';\nimport {encodeGLTFSync} from './lib/encoders/encode-gltf';\n\nexport type GLTFWriterOptions = WriterOptions & {\n  gltf?: {};\n  byteOffset?: number;\n};\n\n/**\n * GLTF exporter\n */\nexport const GLTFWriter = {\n  name: 'glTF',\n  id: 'gltf',\n  module: 'gltf',\n  version: VERSION,\n\n  extensions: ['glb'], // We only support encoding to binary GLB, not to JSON GLTF\n  mimeTypes: ['model/gltf-binary'], // 'model/gltf+json',\n  binary: true,\n\n  encodeSync,\n\n  options: {\n    gltf: {}\n  }\n};\n\nfunction encodeSync(gltf, options: GLTFWriterOptions = {}) {\n  const {byteOffset = 0} = options;\n\n  // Calculate length, then create arraybuffer and encode\n  const byteLength = encodeGLTFSync(gltf, null, byteOffset, options);\n  const arrayBuffer = new ArrayBuffer(byteLength);\n  const dataView = new DataView(arrayBuffer);\n  encodeGLTFSync(gltf, dataView, byteOffset, options);\n\n  return arrayBuffer;\n}\n\n// TYPE TESTS - TODO find a better way than exporting junk\nexport const _TypecheckGLBLoader: Writer = GLTFWriter;\n", "import type {LoaderWithParser, LoaderOptions} from '@loaders.gl/loader-utils';\nimport type {GLB} from './lib/types/glb-types';\nimport type {GLBParseOptions} from './lib/parsers/parse-glb';\nimport {VERSION} from './lib/utils/version';\nimport parseGLBSync from './lib/parsers/parse-glb';\n\nexport type GLBLoaderOptions = LoaderOptions & {\n  glb?: GLBParseOptions;\n  byteOffset?: number;\n};\n\n/**\n * GLB Loader -\n * GLB is the binary container format for GLTF\n */\nexport const GLBLoader: LoaderWithParser = {\n  name: 'GLB',\n  id: 'glb',\n  module: 'gltf',\n  version: VERSION,\n  extensions: ['glb'],\n  mimeTypes: ['model/gltf-binary'],\n  binary: true,\n  parse,\n  parseSync,\n  options: {\n    glb: {\n      strict: false // Enables deprecated XVIZ support (illegal CHUNK formats)\n    }\n  }\n};\n\nasync function parse(arrayBuffer: ArrayBuffer, options?: GLBLoaderOptions): Promise<GLB> {\n  return parseSync(arrayBuffer, options);\n}\n\nfunction parseSync(arrayBuffer: ArrayBuffer, options?: GLBLoaderOptions): GLB {\n  const {byteOffset = 0} = options || {};\n  const glb: GLB = {} as GLB;\n  parseGLBSync(glb, arrayBuffer, byteOffset, options?.glb);\n  return glb;\n}\n\n// TYPE TESTS - TODO find a better way than exporting junk\nexport const _TypecheckGLBLoader: LoaderWithParser = GLBLoader;\n", "import type {Writer} from '@loaders.gl/loader-utils';\nimport {VERSION} from './lib/utils/version';\nimport encodeGLBSync from './lib/encoders/encode-glb';\n\n/**\n * GLB exporter\n * GLB is the binary container format for GLTF\n */\nexport const GLBWriter = {\n  name: 'GLB',\n  id: 'glb',\n  module: 'gltf',\n  version: VERSION,\n\n  extensions: ['glb'],\n  mimeTypes: ['model/gltf-binary'],\n  binary: true,\n\n  encodeSync,\n\n  options: {\n    glb: {}\n  }\n};\n\nfunction encodeSync(glb, options) {\n  const {byteOffset = 0} = options;\n\n  // Calculate length and allocate buffer\n  const byteLength = encodeGLBSync(glb, null, byteOffset, options);\n  const arrayBuffer = new ArrayBuffer(byteLength);\n\n  // Encode into buffer\n  const dataView = new DataView(arrayBuffer);\n  encodeGLBSync(glb, dataView, byteOffset, options);\n\n  return arrayBuffer;\n}\n\n// TYPE TESTS - TODO find a better way than exporting junk\nexport const _TypecheckGLBLoader: Writer = GLBWriter;\n"],
  "mappings": "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",
  "names": ["VERSION", "VERSION", "VERSION", "BASIS_CDN_ENCODER_WASM", "BASIS_CDN_ENCODER_JS", "loadBasisTranscoderPromise", "loadBasisTrascoderModule", "options", "modules", "basis", "loadBasisTrascoder", "BASIS", "wasmBinary", "Promise", "all", "loadLibrary", "globalThis", "initializeBasisTrascoderModule", "BasisModule", "resolve", "then", "module", "BasisFile", "initializeBasis", "loadBasisEncoderPromise", "loadBasisEncoderModule", "basisEncoder", "loadBasisEncoder", "BASIS_ENCODER", "initializeBasisEncoderModule", "BasisEncoderModule", "KTX2File", "BasisEncoder", "GL_EXTENSIONS_CONSTANTS", "COMPRESSED_RGB_S3TC_DXT1_EXT", "COMPRESSED_RGBA_S3TC_DXT1_EXT", "COMPRESSED_RGBA_S3TC_DXT3_EXT", "COMPRESSED_RGBA_S3TC_DXT5_EXT", "COMPRESSED_R11_EAC", "COMPRESSED_SIGNED_R11_EAC", "COMPRESSED_RG11_EAC", "COMPRESSED_SIGNED_RG11_EAC", "COMPRESSED_RGB8_ETC2", "COMPRESSED_RGBA8_ETC2_EAC", "COMPRESSED_SRGB8_ETC2", "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC", "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2", "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2", "COMPRESSED_RGB_PVRTC_4BPPV1_IMG", "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG", "COMPRESSED_RGB_PVRTC_2BPPV1_IMG", "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG", "COMPRESSED_RGB_ETC1_WEBGL", "COMPRESSED_RGB_ATC_WEBGL", "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL", "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL", "COMPRESSED_RGBA_ASTC_4X4_KHR", "COMPRESSED_RGBA_ASTC_5X4_KHR", "COMPRESSED_RGBA_ASTC_5X5_KHR", "COMPRESSED_RGBA_ASTC_6X5_KHR", "COMPRESSED_RGBA_ASTC_6X6_KHR", "COMPRESSED_RGBA_ASTC_8X5_KHR", "COMPRESSED_RGBA_ASTC_8X6_KHR", "COMPRESSED_RGBA_ASTC_8X8_KHR", "COMPRESSED_RGBA_ASTC_10X5_KHR", "COMPRESSED_RGBA_ASTC_10X6_KHR", "COMPRESSED_RGBA_ASTC_10X8_KHR", "COMPRESSED_RGBA_ASTC_10X10_KHR", "COMPRESSED_RGBA_ASTC_12X10_KHR", "COMPRESSED_RGBA_ASTC_12X12_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_4X4_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_5X4_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_5X5_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_6X5_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_6X6_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_8X5_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_8X6_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_8X8_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_10X5_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_10X6_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_10X8_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_10X10_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_12X10_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_12X12_KHR", "COMPRESSED_RED_RGTC1_EXT", "COMPRESSED_SIGNED_RED_RGTC1_EXT", "COMPRESSED_RED_GREEN_RGTC2_EXT", "COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT", "COMPRESSED_SRGB_S3TC_DXT1_EXT", "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT", "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT", "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT", "BROWSER_PREFIXES", "WEBGL_EXTENSIONS", "WEBGL_compressed_texture_s3tc", "WEBGL_compressed_texture_s3tc_srgb", "WEBGL_compressed_texture_etc1", "WEBGL_compressed_texture_etc", "WEBGL_compressed_texture_pvrtc", "WEBGL_compressed_texture_atc", "WEBGL_compressed_texture_astc", "EXT_texture_compression_rgtc", "formats", "getSupportedGPUTextureFormats", "gl", "getWebGLContext", "undefined", "Set", "prefix", "extension", "getExtension", "gpuTextureFormat", "add", "canvas", "document", "createElement", "getContext", "error", "NUL", "Uint8Array", "KTX2_ID", "KTX2SupercompressionScheme", "KTX2DataFormatType", "KTX2DataFormatModel", "KTX2DataFormatPrimaries", "KTX2DataFormatTransfer", "KTX2DataFormatFlags", "KTX2DataFormatChannelETC1S", "KTX2DataFormatChannelUASTC", "KTX2Container", "constructor", "this", "NONE", "vendorId", "descriptorType", "BASICFORMAT", "versionNumber", "descriptorBlockSize", "colorModel", "UNSPECIFIED", "colorPrimaries", "SRGB", "transferFunction", "flags", "ALPHA_STRAIGHT", "texelBlockDimension", "x", "y", "z", "w", "bytesPlane", "samples", "BufferReader", "data", "byteOffset", "byteLength", "littleEndian", "_dataView", "DataView", "buffer", "_littleEndian", "_offset", "_nextUint8", "value", "getUint8", "_nextUint16", "getUint16", "_nextUint32", "getUint32", "_nextUint64", "_skip", "bytes", "_scan", "maxByteLength", "term", "text", "decodeText", "buffer", "TextDecoder", "decode", "Buffer", "from", "toString", "result", "read", "data", "id", "Uint8Array", "buffer", "byteOffset", "KTX2_ID", "length", "Error", "container", "KTX2Container", "headerByteLength", "Uint32Array", "BYTES_PER_ELEMENT", "headerReader", "BufferReader", "vkFormat", "_nextUint32", "typeSize", "pixelWidth", "pixelHeight", "pixelDepth", "layerCount", "faceCount", "levelCount", "supercompressionScheme", "dfdByteOffset", "dfdByteLength", "kvdByteOffset", "kvdByteLength", "sgdByteOffset", "_nextUint64", "sgdByteLength", "levelReader", "i", "levels", "push", "levelData", "uncompressedByteLength", "dfdReader", "dfd", "vendorId", "_skip", "_nextUint16", "descriptorType", "versionNumber", "descriptorBlockSize", "colorModel", "_nextUint8", "colorPrimaries", "transferFunction", "flags", "texelBlockDimension", "x", "y", "z", "w", "bytesPlane", "samples", "numSamples", "bitOffset", "bitLength", "channelID", "samplePosition", "sampleLower", "sampleUpper", "dataFormatDescriptor", "kvdReader", "_offset", "keyValueByteLength", "keyData", "_scan", "key", "decodeText", "valueData", "byteLength", "keyValue", "match", "sgdReader", "endpointCount", "selectorCount", "endpointsByteLength", "selectorsByteLength", "tablesByteLength", "extendedByteLength", "imageDescs", "imageFlags", "rgbSliceByteOffset", "rgbSliceByteLength", "alphaSliceByteOffset", "alphaSliceByteLength", "endpointsByteOffset", "selectorsByteOffset", "tablesByteOffset", "extendedByteOffset", "endpointsData", "selectorsData", "tablesData", "extendedData", "globalData", "extractMipmapImages", "data", "options", "images", "Array", "mipMapLevels", "levelWidth", "width", "levelHeight", "height", "offset", "i", "levelSize", "getLevelSize", "levelData", "getLevelData", "compressed", "format", "internalFormat", "Math", "max", "index", "isArray", "Uint8Array", "buffer", "byteOffset", "sizeFunction", "VULKAN_TO_WEBGL_FORMAT_MAP", "GL_EXTENSIONS_CONSTANTS", "COMPRESSED_RGB_S3TC_DXT1_EXT", "COMPRESSED_SRGB_S3TC_DXT1_EXT", "COMPRESSED_RGBA_S3TC_DXT1_EXT", "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT", "COMPRESSED_RGBA_S3TC_DXT3_EXT", "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT", "COMPRESSED_RGBA_S3TC_DXT5_EXT", "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT", "COMPRESSED_RED_RGTC1_EXT", "COMPRESSED_SIGNED_RED_RGTC1_EXT", "COMPRESSED_RED_GREEN_RGTC2_EXT", "COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT", "COMPRESSED_RGB8_ETC2", "COMPRESSED_SRGB8_ETC2", "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2", "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2", "COMPRESSED_RGBA8_ETC2_EAC", "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC", "COMPRESSED_R11_EAC", "COMPRESSED_SIGNED_R11_EAC", "COMPRESSED_RG11_EAC", "COMPRESSED_SIGNED_RG11_EAC", "COMPRESSED_RGBA_ASTC_4x4_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR", "COMPRESSED_RGBA_ASTC_5x4_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_5X4_KHR", "COMPRESSED_RGBA_ASTC_5x5_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR", "COMPRESSED_RGBA_ASTC_6x5_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR", "COMPRESSED_RGBA_ASTC_6x6_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR", "COMPRESSED_RGBA_ASTC_8x5_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR", "COMPRESSED_RGBA_ASTC_8x6_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR", "COMPRESSED_RGBA_ASTC_8x8_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR", "COMPRESSED_RGBA_ASTC_10x5_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR", "COMPRESSED_RGBA_ASTC_10x6_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR", "COMPRESSED_RGBA_ASTC_10x8_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR", "COMPRESSED_RGBA_ASTC_10x10_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR", "COMPRESSED_RGBA_ASTC_12x10_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR", "COMPRESSED_RGBA_ASTC_12x12_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR", "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG", "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG", "mapVkFormatToWebGL", "vkFormat", "KTX2_ID", "isKTX", "data", "id", "Uint8Array", "notKTX", "byteLength", "length", "parseKTX", "arrayBuffer", "uint8Array", "ktx", "read", "mipMapLevels", "Math", "max", "levels", "width", "pixelWidth", "height", "pixelHeight", "internalFormat", "mapVkFormatToWebGL", "vkFormat", "extractMipmapImages", "sizeFunction", "level", "uncompressedByteLength", "OutputFormat", "etc1", "basisFormat", "compressed", "format", "GL_EXTENSIONS_CONSTANTS", "COMPRESSED_RGB_ETC1_WEBGL", "etc2", "bc1", "COMPRESSED_RGB_S3TC_DXT1_EXT", "bc3", "COMPRESSED_RGBA_S3TC_DXT5_EXT", "bc4", "bc5", "COMPRESSED_RGB_PVRTC_4BPPV1_IMG", "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG", "COMPRESSED_RGBA_ASTC_4X4_KHR", "rgba32", "rgb565", "bgr565", "rgba4444", "data", "options", "basis", "containerFormat", "isKTX", "fileConstructors", "loadBasisEncoderModule", "parseKTX2File", "KTX2File", "BasisFile", "loadBasisTrascoderModule", "parseBasisFile", "module", "basisFile", "Uint8Array", "startTranscoding", "Error", "imageCount", "getNumImages", "images", "imageIndex", "levelsCount", "getNumLevels", "levels", "levelIndex", "push", "transcodeImage", "close", "delete", "width", "getImageWidth", "height", "getImageHeight", "hasAlpha", "getHasAlpha", "getBasisOptions", "decodedSize", "getImageTranscodedSizeInBytes", "decodedData", "ktx2File", "getLevels", "transcodeKTX2Image", "alphaFlag", "getImageLevelInfo", "levelSize", "selectSupportedBasisFormat", "alpha", "noAlpha", "toLowerCase", "supportedFormats", "getSupportedGPUTextureFormats", "has", "BasisWorkerLoader", "name", "id", "isBrowser", "module", "version", "VERSION", "worker", "extensions", "mimeTypes", "tests", "binary", "options", "basis", "format", "libraryPath", "containerFormat", "BasisLoader", "parse", "parseBasis", "DDS_CONSTANTS", "MAGIC_NUMBER", "HEADER_LENGTH", "MAGIC_NUMBER_INDEX", "HEADER_SIZE_INDEX", "HEADER_FLAGS_INDEX", "HEADER_HEIGHT_INDEX", "HEADER_WIDTH_INDEX", "MIPMAPCOUNT_INDEX", "HEADER_PF_FLAGS_INDEX", "HEADER_PF_FOURCC_INDEX", "DDSD_MIPMAPCOUNT", "DDPF_FOURCC", "DDS_PIXEL_FORMATS", "DXT1", "GL_EXTENSIONS_CONSTANTS", "COMPRESSED_RGB_S3TC_DXT1_EXT", "DXT3", "COMPRESSED_RGBA_S3TC_DXT3_EXT", "DXT5", "COMPRESSED_RGBA_S3TC_DXT5_EXT", "COMPRESSED_RGB_ATC_WEBGL", "ATCA", "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL", "ATCI", "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL", "getATCLevelSize", "getDxt1LevelSize", "getATCALevelSize", "getDxtXLevelSize", "getATCILevelSize", "DDS_SIZE_FUNCTIONS", "isDDS", "data", "header", "Uint32Array", "magic", "parseDDS", "Int32Array", "pixelFormatNumber", "assert", "Boolean", "fourCC", "int32ToFourCC", "internalFormat", "sizeFunction", "mipMapLevels", "Math", "max", "width", "height", "dataOffset", "image", "Uint8Array", "extractMipmapImages", "value", "String", "fromCharCode", "PVR_CONSTANTS", "MAGIC_NUMBER", "MAGIC_NUMBER_EXTRA", "HEADER_LENGTH", "HEADER_SIZE", "MAGIC_NUMBER_INDEX", "PIXEL_FORMAT_INDEX", "COLOUR_SPACE_INDEX", "HEIGHT_INDEX", "WIDTH_INDEX", "MIPMAPCOUNT_INDEX", "METADATA_SIZE_INDEX", "PVR_PIXEL_FORMATS", "GL_EXTENSIONS_CONSTANTS", "COMPRESSED_RGB_PVRTC_2BPPV1_IMG", "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG", "COMPRESSED_RGB_PVRTC_4BPPV1_IMG", "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG", "COMPRESSED_RGB_ETC1_WEBGL", "COMPRESSED_RGB_S3TC_DXT1_EXT", "COMPRESSED_RGBA_S3TC_DXT3_EXT", "COMPRESSED_RGBA_S3TC_DXT5_EXT", "COMPRESSED_RGB8_ETC2", "COMPRESSED_RGBA8_ETC2_EAC", "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2", "COMPRESSED_R11_EAC", "COMPRESSED_RG11_EAC", "COMPRESSED_RGBA_ASTC_4X4_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_4X4_KHR", "COMPRESSED_RGBA_ASTC_5X4_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_5X4_KHR", "COMPRESSED_RGBA_ASTC_5X5_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_5X5_KHR", "COMPRESSED_RGBA_ASTC_6X5_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_6X5_KHR", "COMPRESSED_RGBA_ASTC_6X6_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_6X6_KHR", "COMPRESSED_RGBA_ASTC_8X5_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_8X5_KHR", "COMPRESSED_RGBA_ASTC_8X6_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_8X6_KHR", "COMPRESSED_RGBA_ASTC_8X8_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_8X8_KHR", "COMPRESSED_RGBA_ASTC_10X5_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_10X5_KHR", "COMPRESSED_RGBA_ASTC_10X6_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_10X6_KHR", "COMPRESSED_RGBA_ASTC_10X8_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_10X8_KHR", "COMPRESSED_RGBA_ASTC_10X10_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_10X10_KHR", "COMPRESSED_RGBA_ASTC_12X10_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_12X10_KHR", "COMPRESSED_RGBA_ASTC_12X12_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_12X12_KHR", "PVR_SIZE_FUNCTIONS", "pvrtc2bppSize", "pvrtc4bppSize", "dxtEtcSmallSize", "dxtEtcAstcBigSize", "atc5x4Size", "atc5x5Size", "atc6x5Size", "atc6x6Size", "atc8x5Size", "atc8x6Size", "atc8x8Size", "atc10x5Size", "atc10x6Size", "atc10x8Size", "atc10x10Size", "atc12x10Size", "atc12x12Size", "isPVR", "data", "header", "Uint32Array", "version", "parsePVR", "pvrFormat", "colourSpace", "pixelFormats", "internalFormat", "length", "sizeFunction", "mipMapLevels", "width", "height", "dataOffset", "image", "Uint8Array", "extractMipmapImages", "Math", "max", "floor", "parseCompressedTexture", "data", "isKTX", "parseKTX", "isDDS", "parseDDS", "isPVR", "parsePVR", "Error", "DEFAULT_TEXTURE_LOADER_OPTIONS", "libraryPath", "useBasis", "CompressedTextureWorkerLoader", "name", "id", "module", "version", "VERSION", "worker", "extensions", "mimeTypes", "binary", "options", "CompressedTextureLoader", "parse", "arrayBuffer", "basis", "format", "alpha", "noAlpha", "containerFormat", "parseBasis", "parseCompressedTexture", "systemIsLittleEndian", "a", "Uint32Array", "b", "Uint8Array", "buffer", "byteOffset", "byteLength", "LITTLE_ENDIAN_OS", "DTYPES", "u1", "i1", "Int8Array", "u2", "Uint16Array", "i2", "Int16Array", "u4", "i4", "Int32Array", "f4", "Float32Array", "f8", "Float64Array", "parseNPY", "arrayBuffer", "options", "view", "DataView", "header", "headerEndOffset", "parseHeader", "numpyType", "descr", "ArrayType", "slice", "Error", "nArrayElements", "shape", "reduce", "arrayByteLength", "BYTES_PER_ELEMENT", "data", "majorVersion", "getUint8", "offset", "headerLength", "getUint32", "getUint16", "encoding", "decoder", "TextDecoder", "headerArray", "headerText", "decode", "JSON", "parse", "replace", "NPY_MAGIC_NUMBER", "Uint8Array", "NPYWorkerLoader", "name", "id", "module", "version", "VERSION", "worker", "extensions", "mimeTypes", "tests", "buffer", "options", "npy", "NPYLoader", "parseSync", "parseNPY", "parse", "arrayBuffer", "assert", "condition", "message", "Error", "resolveUrl", "url", "options", "absolute", "startsWith", "baseUrl", "baseUri", "uri", "Error", "substr", "lastIndexOf", "getTypedArrayForBufferView", "json", "buffers", "bufferViewIndex", "bufferView", "bufferViews", "assert", "bufferIndex", "buffer", "binChunk", "byteOffset", "Uint8Array", "arrayBuffer", "byteLength", "TYPES", "ARRAY_CONSTRUCTOR_TO_WEBGL_CONSTANT", "Int8Array", "Uint8Array", "Int16Array", "Uint16Array", "Uint32Array", "Float32Array", "Float64Array", "ARRAY_TO_COMPONENT_TYPE", "Map", "ATTRIBUTE_TYPE_TO_COMPONENTS", "SCALAR", "VEC2", "VEC3", "VEC4", "MAT2", "MAT3", "MAT4", "ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE", "ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY", "getAccessorTypeFromSize", "size", "type", "getComponentTypeFromArray", "typedArray", "componentType", "get", "constructor", "Error", "getAccessorArrayTypeAndLength", "accessor", "bufferView", "ArrayType", "components", "bytesPerComponent", "length", "count", "byteLength", "assert", "DEFAULT_GLTF_JSON", "asset", "version", "generator", "buffers", "GLTFScenegraph", "constructor", "gltf", "json", "sourceBuffers", "byteLength", "getApplicationData", "key", "data", "getExtraData", "extras", "getExtension", "extensionName", "isExtension", "getUsedExtensions", "find", "name", "extensions", "getRequiredExtension", "isRequired", "getRequiredExtensions", "extensionsRequired", "extensionsUsed", "getRemovedExtensions", "extensionsRemoved", "getObjectExtension", "object", "getScene", "index", "getObject", "getNode", "getSkin", "getMesh", "getMaterial", "getAccessor", "getTexture", "getSampler", "getImage", "getBufferView", "getBuffer", "array", "Error", "getTypedArrayForBufferView", "bufferView", "bufferIndex", "buffer", "binChunk", "assert", "byteOffset", "Uint8Array", "arrayBuffer", "getTypedArrayForAccessor", "accessor", "ArrayType", "length", "getAccessorArrayTypeAndLength", "getTypedArrayForImageData", "image", "addApplicationData", "addExtraData", "addObjectExtension", "registerUsedExtension", "setObjectExtension", "removeObjectExtension", "extension", "addExtension", "extensionData", "addRequiredExtension", "registerRequiredExtension", "ext", "push", "removeExtension", "_removeStringFromArray", "Array", "isArray", "includes", "setDefaultScene", "sceneIndex", "scene", "addScene", "nodeIndices", "scenes", "nodes", "addNode", "node", "meshIndex", "matrix", "nodeData", "mesh", "addMesh", "attributes", "indices", "material", "mode", "accessors", "_addAttributes", "glTFMesh", "primitives", "indicesAccessor", "_addIndices", "Number", "isFinite", "meshes", "addPointCloud", "accessorIndices", "addImage", "imageData", "mimeTypeOpt", "metadata", "getBinaryImageMetadata", "mimeType", "bufferViewIndex", "addBufferView", "glTFImage", "images", "glTFBufferView", "padToNBytes", "bufferViews", "addAccessor", "glTFAccessor", "type", "getAccessorTypeFromSize", "size", "componentType", "count", "max", "min", "addBinaryBuffer", "sourceBuffer", "minMax", "_getAccessorMinMax", "accessorDefaults", "getComponentTypeFromArray", "Math", "round", "Object", "assign", "addTexture", "texture", "imageIndex", "glTFTexture", "source", "textures", "addMaterial", "pbrMaterialInfo", "materials", "createBinaryChunk", "totalByteLength", "ArrayBuffer", "targetArray", "dstByteOffset", "copyToArray", "binary", "string", "found", "indexOf", "splice", "result", "attributeKey", "attributeData", "attrName", "_getGltfAttributeName", "value", "attributeName", "toLowerCase", "initValues", "subarray", "componentIndex", "wasm_base", "wasm_simd", "detector", "Uint8Array", "wasmpack", "FILTERS", "NONE", "OCTAHEDRAL", "QUATERNION", "EXPONENTIAL", "DECODERS", "ATTRIBUTES", "TRIANGLES", "INDICES", "meshoptDecodeGltfBuffer", "target", "count", "size", "source", "mode", "filter", "instance", "loadWasmInstance", "decode", "exports", "DECODERS", "FILTERS", "wasmPromise", "loadWasmModule", "wasm", "wasm_base", "WebAssembly", "validate", "detector", "wasm_simd", "console", "log", "result", "instantiate", "unpack", "__wasm_call_ctors", "data", "Uint8Array", "length", "i", "ch", "charCodeAt", "write", "wasmpack", "buffer", "slice", "fun", "sbrk", "count4", "tp", "sp", "heap", "memory", "set", "res", "subarray", "Error", "EXT_MESHOPT_COMPRESSION", "name", "decode", "gltfData", "options", "scenegraph", "GLTFScenegraph", "gltf", "decompressMeshes", "promises", "bufferViewIndex", "json", "bufferViews", "push", "decodeMeshoptBufferView", "Promise", "all", "removeExtension", "bufferView", "meshoptExtension", "getObjectExtension", "byteOffset", "byteLength", "byteStride", "count", "mode", "filter", "buffer", "bufferIndex", "buffers", "source", "Uint8Array", "arrayBuffer", "result", "meshoptDecodeGltfBuffer", "EXT_TEXTURE_WEBP", "name", "preprocess", "gltfData", "options", "scenegraph", "GLTFScenegraph", "_isImageFormatSupported", "getRequiredExtensions", "includes", "Error", "json", "texture", "textures", "extension", "getObjectExtension", "source", "removeObjectExtension", "removeExtension", "KHR_TEXTURE_BASISU", "name", "preprocess", "gltfData", "options", "scene", "GLTFScenegraph", "json", "texture", "textures", "extension", "getObjectExtension", "source", "removeObjectExtension", "removeExtension", "VERSION", "DEFAULT_DRACO_OPTIONS", "draco", "decoderType", "WebAssembly", "libraryPath", "extraAttributes", "attributeNameEntry", "undefined", "DracoLoader", "name", "id", "isBrowser", "module", "shapes", "version", "VERSION", "worker", "extensions", "mimeTypes", "binary", "tests", "options", "DEFAULT_ROW_COUNT", "RowTableBatchAggregator", "constructor", "schema", "options", "Array", "isArray", "_headers", "key", "index", "name", "rowCount", "length", "addArrayRow", "row", "cursor", "Number", "isFinite", "rows", "addObjectRow", "getBatch", "slice", "batch", "shape", "batchType", "data", "convertToObjectRow", "arrayRow", "headers", "Error", "objectRow", "i", "length", "convertToArrayRow", "Array", "DEFAULT_ROW_COUNT", "RowTableBatchAggregator", "constructor", "schema", "options", "Array", "isArray", "_headers", "key", "index", "name", "rowCount", "length", "addArrayRow", "row", "cursor", "Number", "isFinite", "shape", "rowObject", "convertToObjectRow", "addObjectRow", "arrayRows", "rowArray", "convertToArrayRow", "objectRows", "getBatch", "rows", "slice", "batchType", "data", "DEFAULT_ROW_COUNT", "ColumnarTableBatchAggregator", "constructor", "schema", "options", "_reallocateColumns", "rowCount", "length", "addArrayRow", "row", "i", "fieldName", "columns", "addObjectRow", "getBatch", "_pruneColumns", "Array", "isArray", "field", "name", "index", "batch", "shape", "batchType", "data", "allocated", "ArrayType", "type", "Float32Array", "oldColumn", "ArrayBuffer", "isView", "typedArray", "set", "columnName", "column", "Object", "entries", "slice", "DEFAULT_OPTIONS", "shape", "batchSize", "batchDebounceMs", "limit", "_limitMB", "ERR_MESSAGE", "TableBatchBuilder", "constructor", "schema", "options", "Date", "now", "limitReached", "Boolean", "totalLength", "totalBytes", "addRow", "row", "rowBytes", "_estimateRowMB", "Array", "isArray", "addArrayRow", "addObjectRow", "aggregator", "TableBatchType", "_getTableBatchType", "chunkComplete", "chunk", "ArrayBuffer", "bytesUsed", "byteLength", "length", "isChunkComplete", "getFullBatch", "_isFull", "_getBatch", "getFinalBatch", "Object", "keys", "rowCount", "lastBatchEmittedMs", "normalizedBatch", "getBatch", "count", "batchCount", "assign", "BaseTableBatchAggregator", "RowTableBatchAggregator", "ColumnarTableBatchAggregator", "ArrowBatch", "Error", "getMeshBoundingBox", "attributes", "minX", "Infinity", "minY", "minZ", "maxX", "maxY", "maxZ", "positions", "POSITION", "value", "len", "length", "i", "x", "y", "z", "assert", "condition", "message", "Error", "Schema", "constructor", "fields", "metadata", "assert", "Array", "isArray", "checkNames", "Map", "compareTo", "other", "length", "i", "select", "nameMap", "Object", "create", "columnNames", "name", "selectedFields", "filter", "field", "selectAt", "columnIndices", "map", "index", "Boolean", "assign", "schemaOrFields", "otherSchema", "mergeMaps", "fieldMap", "mergedFields", "values", "usedNames", "console", "warn", "m1", "m2", "Field", "constructor", "name", "type", "nullable", "metadata", "Map", "typeId", "clone", "compareTo", "other", "toString", "Type", "DataType", "isNull", "x", "typeId", "Type", "Null", "isInt", "Int", "isFloat", "Float", "isBinary", "Binary", "isUtf8", "Utf8", "isBool", "Bool", "isDecimal", "Decimal", "isDate", "Date", "isTime", "Time", "isTimestamp", "Timestamp", "isInterval", "Interval", "isList", "List", "isStruct", "Struct", "isUnion", "Union", "isFixedSizeBinary", "FixedSizeBinary", "isFixedSizeList", "FixedSizeList", "isMap", "Map", "isDictionary", "Dictionary", "NONE", "compareTo", "other", "Symbol", "toStringTag", "toString", "constructor", "isSigned", "bitWidth", "Int8", "Int16", "Int32", "Uint8", "Int", "constructor", "Uint16", "Uint32", "Precision", "HALF", "SINGLE", "DOUBLE", "Symbol", "toStringTag", "Float", "DataType", "constructor", "precision", "typeId", "Type", "toString", "Float32", "Float", "constructor", "Precision", "SINGLE", "Float64", "DOUBLE", "Binary", "DataType", "typeId", "Type", "toString", "Symbol", "toStringTag", "Utf8", "DateUnit", "DAY", "MILLISECOND", "Date", "unit", "TimeUnit", "SECOND", "MILLISECOND", "MICROSECOND", "NANOSECOND", "Symbol", "toStringTag", "Time", "DataType", "constructor", "unit", "bitWidth", "typeId", "Type", "toString", "Symbol", "toStringTag", "Timestamp", "DataType", "constructor", "unit", "timezone", "typeId", "Type", "toString", "TimeUnit", "IntervalUnit", "DAY_TIME", "YEAR_MONTH", "Symbol", "toStringTag", "Interval", "DataType", "constructor", "unit", "typeId", "Type", "toString", "Symbol", "toStringTag", "FixedSizeList", "DataType", "constructor", "listSize", "child", "children", "typeId", "Type", "valueType", "type", "valueField", "toString", "Struct", "map", "f", "name", "join", "getArrowTypeFromTypedArray", "array", "constructor", "Int8Array", "Int8", "Uint8Array", "Uint8", "Int16Array", "Int16", "Uint16Array", "Uint16", "Int32Array", "Int32", "Uint32Array", "Uint32", "Float32Array", "Float32", "Float64Array", "Float64", "Error", "deduceMeshField", "attributeName", "attribute", "optionalMetadata", "type", "getArrowTypeFromTypedArray", "value", "metadata", "makeMeshAttributeMetadata", "field", "Field", "FixedSizeList", "size", "makeMeshAttributeMetadata", "attribute", "result", "Map", "set", "byteOffset", "toString", "byteStride", "normalized", "ArrayQueue", "Array", "enqueue", "value", "push", "dequeue", "shift", "Symbol", "asyncIterator", "AsyncQueue", "constructor", "_values", "_settlers", "_closed", "close", "length", "resolve", "done", "Error", "settler", "reject", "next", "Promise", "getDracoSchema", "attributes", "loaderData", "indices", "metadataMap", "makeMetadata", "metadata", "fields", "namedLoaderDataAttributes", "transformAttributesLoaderData", "attributeName", "attribute", "field", "getArrowFieldFromAttribute", "push", "indicesField", "Schema", "result", "key", "dracoAttribute", "name", "undefined", "deduceMeshField", "Map", "set", "JSON", "stringify", "DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP", "POSITION", "NORMAL", "COLOR", "TEX_COORD", "DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP", "Int8Array", "Uint8Array", "Int16Array", "Uint16Array", "Int32Array", "Uint32Array", "Float32Array", "INDEX_ITEM_SIZE", "DracoParser", "constructor", "draco", "decoder", "Decoder", "metadataQuerier", "MetadataQuerier", "destroy", "parseSync", "arrayBuffer", "options", "buffer", "DecoderBuffer", "Init", "byteLength", "_disableAttributeTransforms", "geometry_type", "GetEncodedGeometryType", "dracoGeometry", "TRIANGULAR_MESH", "Mesh", "PointCloud", "dracoStatus", "DecodeBufferToMesh", "POINT_CLOUD", "DecodeBufferToPointCloud", "Error", "ok", "ptr", "message", "error_msg", "loaderData", "_getDracoLoaderData", "geometry", "_getMeshData", "boundingBox", "getMeshBoundingBox", "attributes", "schema", "getDracoSchema", "indices", "data", "loader", "header", "vertexCount", "num_points", "metadata", "_getTopLevelMetadata", "_getDracoAttributes", "num_attributes", "num_faces", "dracoAttributes", "attributeId", "dracoAttribute", "GetAttribute", "_getAttributeMetadata", "unique_id", "attribute_type", "data_type", "num_components", "byte_offset", "byte_stride", "normalized", "attribute_index", "quantization", "_getQuantizationTransform", "quantization_transform", "octahedron", "_getOctahedronTransform", "octahedron_transform", "_getMeshAttributes", "positionAttribute", "topology", "mode", "value", "_getTriangleStripIndices", "size", "_getTriangleListIndices", "loaderAttribute", "Object", "values", "attributeName", "_deduceAttributeName", "name", "_getAttributeValues", "byteOffset", "byteStride", "numFaces", "numIndices", "_malloc", "GetTrianglesUInt32Array", "HEAPF32", "slice", "_free", "dracoArray", "DracoInt32Array", "GetTriangleStripsFromMesh", "getUint32Array", "attribute", "TypedArrayCtor", "numComponents", "numPoints", "numValues", "BYTES_PER_ELEMENT", "dataType", "getDracoDataType", "GetAttributeDataArrayForAllPoints", "uniqueId", "attributeUniqueId", "entries", "extraAttributes", "thisAttributeType", "dracoAttributeConstant", "attributeType", "entryName", "attributeNameEntry", "string", "dracoMetadata", "GetMetadata", "_getDracoMetadata", "GetAttributeMetadata", "result", "numEntries", "NumEntries", "entryIndex", "GetEntryName", "_getDracoMetadataField", "GetIntEntryArray", "intArray", "getInt32Array", "int", "GetIntEntry", "GetStringEntry", "double", "GetDoubleEntry", "quantizedAttributes", "octahedronAttributes", "skipAttributes", "dracoAttributeName", "SkipAttributeTransform", "skip", "map", "type", "includes", "transform", "AttributeQuantizationTransform", "InitFromAttribute", "quantization_bits", "range", "min_values", "i", "min_value", "DT_FLOAT32", "DT_INT8", "DT_INT16", "DT_INT32", "DT_UINT8", "DT_UINT16", "DT_UINT32", "DT_INVALID", "GetValue", "DRACO_DECODER_VERSION", "DRACO_ENCODER_VERSION", "STATIC_DECODER_URL", "DRACO_JS_DECODER_URL", "DRACO_WASM_WRAPPER_URL", "DRACO_WASM_DECODER_URL", "DRACO_ENCODER_URL", "loadDecoderPromise", "loadDracoDecoderModule", "options", "modules", "draco3d", "loadDecoderPromise", "createDecoderModule", "then", "draco", "loadDracoDecoder", "loadDracoDecoder", "options", "DracoDecoderModule", "wasmBinary", "draco", "decoderType", "loadLibrary", "DRACO_JS_DECODER_URL", "Promise", "all", "DRACO_WASM_WRAPPER_URL", "DRACO_WASM_DECODER_URL", "globalThis", "initializeDracoDecoder", "resolve", "onModuleLoaded", "DracoLoader", "DracoWorkerLoader", "parse", "arrayBuffer", "options", "draco", "loadDracoDecoderModule", "dracoParser", "DracoParser", "parseSync", "destroy", "getGLTFAccessors", "attributes", "accessors", "name", "attribute", "glTFAccessor", "getGLTFAccessor", "buffer", "size", "count", "getAccessorData", "value", "byteOffset", "type", "getAccessorTypeFromSize", "componentType", "getComponentTypeFromArray", "ArrayBuffer", "isView", "toTypedArray", "Float32Array", "length", "array", "ArrayType", "convertTypedArrays", "Array", "isArray", "KHR_DRACO_MESH_COMPRESSION", "name", "preprocess", "gltfData", "options", "context", "scenegraph", "Scenegraph", "primitive", "makeMeshPrimitiveIterator", "getObjectExtension", "decode", "gltf", "decompressMeshes", "promises", "push", "decompressPrimitive", "Promise", "all", "removeExtension", "encode", "mesh", "json", "meshes", "compressMesh", "addRequiredExtension", "dracoExtension", "buffer", "getTypedArrayForBufferView", "bufferView", "bufferCopy", "sliceArrayBuffer", "byteOffset", "parse", "dracoOptions", "decodedData", "DracoLoader", "decodedAttributes", "getGLTFAccessors", "attributes", "attributeName", "decodedAttribute", "Object", "entries", "accessorIndex", "accessor", "getAccessor", "min", "max", "indices", "getGLTFAccessor", "checkPrimitive", "mode", "DracoWriter", "Error", "compressedData", "encodeSync", "parseSync", "fauxAccessors", "_addFauxAttributes", "bufferViewIndex", "addBufferView", "glTFMesh", "primitives", "extensions", "keys", "length", "COMPONENTS", "SCALAR", "VEC2", "VEC3", "VEC4", "MAT2", "MAT3", "MAT4", "BYTES", "EXT_MESHOPT_TRANSFORM", "name", "scratchVector", "Vector3", "scratchRotationMatrix", "Matrix3", "scratchScaleMatrix", "decode", "gltfData", "options", "gltfScenegraph", "GLTFScenegraph", "extension", "getExtension", "materials", "json", "i", "length", "transformTexCoords", "materialIndex", "processedTexCoords", "material", "baseColorTexture", "pbrMetallicRoughness", "transformPrimitives", "emisiveTexture", "emissiveTexture", "normalTexture", "occlusionTexture", "metallicRoughnessTexture", "texture", "transformParameters", "getTransformParameters", "meshes", "mesh", "primitive", "primitives", "Number", "isFinite", "transformPrimitive", "textureInfo", "extensions", "texCoord", "originalTexCoord", "isProcessed", "findIndex", "original", "newTexCoord", "matrix", "makeTransformationMatrix", "push", "texCoordAccessor", "attributes", "accessor", "accessors", "bufferView", "bufferViews", "arrayBuffer", "byteOffset", "bufferByteOffset", "buffers", "buffer", "ArrayType", "getAccessorArrayTypeAndLength", "bytes", "BYTES", "componentType", "components", "COMPONENTS", "type", "elementAddressScale", "byteStride", "result", "Float32Array", "count", "uv", "set", "transformByMatrix3", "updateGltf", "createAttribute", "newTexCoordArray", "byteLength", "originalAccessor", "extensionData", "offset", "rotation", "scale", "translationMatirx", "rotationMatirx", "Math", "cos", "sin", "scaleMatrix", "multiplyRight", "KHR_LIGHTS_PUNCTUAL", "name", "decode", "gltfData", "gltfScenegraph", "GLTFScenegraph", "json", "extension", "getExtension", "lights", "removeExtension", "node", "nodes", "nodeExtension", "getObjectExtension", "light", "removeObjectExtension", "encode", "addExtension", "assert", "addObjectExtension", "KHR_MATERIALS_UNLIT", "name", "decode", "gltfData", "gltfScenegraph", "GLTFScenegraph", "json", "material", "materials", "extension", "extensions", "KHR_materials_unlit", "unlit", "removeObjectExtension", "removeExtension", "encode", "addObjectExtension", "addExtension", "KHR_TECHNIQUES_WEBGL", "name", "decode", "gltfData", "gltfScenegraph", "GLTFScenegraph", "json", "extension", "getExtension", "techniques", "resolveTechniques", "material", "materials", "materialExtension", "getObjectExtension", "technique", "Object", "assign", "values", "resolveValues", "removeObjectExtension", "removeExtension", "encode", "options", "techniquesExtension", "programs", "shaders", "textDecoder", "TextDecoder", "forEach", "shader", "Number", "isFinite", "bufferView", "code", "getTypedArrayForBufferView", "Error", "program", "fragmentShader", "vertexShader", "keys", "uniforms", "uniform", "value", "index", "undefined", "texture", "getTexture", "EXT_FEATURE_METADATA", "name", "decode", "gltfData", "scenegraph", "GLTFScenegraph", "decodeExtFeatureMetadata", "extension", "getExtension", "schemaClasses", "schema", "classes", "featureTables", "featureTextures", "console", "warn", "schemaName", "schemaClass", "featureTable", "findFeatureTableByName", "handleFeatureTableProperties", "propertyName", "properties", "schemaProperty", "featureTableProperty", "numberOfFeatures", "count", "data", "getPropertyDataFromBinarySource", "bufferView", "getTypedArrayForBufferView", "type", "stringOffsetBufferView", "offsetsData", "getStringAttributes", "schemaClassName", "featureTableName", "class", "stringsCount", "stringsArray", "textDecoder", "TextDecoder", "stringOffset", "bytesPerStringSize", "index", "stringByteSize", "stringData", "subarray", "stringAttribute", "push", "EXTENSIONS", "EXT_meshopt_compression", "EXT_texture_webp", "KHR_texture_basisu", "KHR_draco_mesh_compression", "KHR_lights_punctual", "KHR_materials_unlit", "KHR_techniques_webgl", "KHR_texture_transform", "EXT_feature_metadata", "preprocessExtensions", "gltf", "options", "context", "extensions", "filter", "extension", "useExtension", "name", "preprocess", "decodeExtensions", "decode", "extensionName", "excludes", "excludeExtensions", "exclude", "KHR_BINARY_GLTF", "preprocess", "gltfData", "gltfScenegraph", "GLTFScenegraph", "json", "image", "images", "extension", "getObjectExtension", "KHR_BINARY_GLTF", "Object", "assign", "removeObjectExtension", "buffers", "uri", "removeExtension", "GLTF_ARRAYS", "accessors", "animations", "buffers", "bufferViews", "images", "materials", "meshes", "nodes", "samplers", "scenes", "skins", "textures", "GLTF_KEYS", "accessor", "buffer", "bufferView", "image", "material", "mesh", "node", "sampler", "scene", "skin", "texture", "GLTFV1Normalizer", "normalize", "gltf", "options", "json", "asset", "version", "undefined", "console", "warn", "Error", "_addAsset", "_convertTopLevelObjectsToArrays", "KHR_binary_glTF", "preprocess", "_convertObjectIdsToArrayIndices", "_updateObjects", "_updateMaterial", "generator", "arrayName", "_convertTopLevelObjectToArray", "mapName", "objectMap", "Array", "isArray", "id", "object", "index", "length", "push", "idToIndexMap", "_convertIdsToIndices", "_convertIdToIndex", "_convertTextureIds", "_convertMeshIds", "_convertNodeIds", "_convertSceneIds", "source", "primitive", "primitives", "attributes", "indices", "attributeName", "children", "map", "child", "topLevelArrayName", "key", "Number", "isFinite", "type", "pbrMetallicRoughness", "baseColorFactor", "metallicFactor", "roughnessFactor", "textureId", "values", "tex", "texture2d_0", "diffuseTex", "textureIndex", "findIndex", "baseColorTexture", "normalizeGLTFV1", "COMPONENTS", "SCALAR", "VEC2", "VEC3", "VEC4", "MAT2", "MAT3", "MAT4", "BYTES", "GL_SAMPLER", "TEXTURE_MAG_FILTER", "TEXTURE_MIN_FILTER", "TEXTURE_WRAP_S", "TEXTURE_WRAP_T", "REPEAT", "LINEAR", "NEAREST_MIPMAP_LINEAR", "SAMPLER_PARAMETER_GLTF_TO_GL", "magFilter", "minFilter", "wrapS", "wrapT", "DEFAULT_SAMPLER", "getBytesFromComponentType", "componentType", "getSizeFromAccessorType", "type", "GLTFPostProcessor", "postProcess", "gltf", "options", "json", "buffers", "images", "baseUri", "assert", "_resolveTree", "bufferViews", "map", "bufView", "i", "_resolveBufferView", "image", "_resolveImage", "samplers", "sampler", "_resolveSampler", "textures", "texture", "_resolveTexture", "accessors", "accessor", "_resolveAccessor", "materials", "material", "_resolveMaterial", "meshes", "mesh", "_resolveMesh", "nodes", "node", "_resolveNode", "skins", "skin", "_resolveSkin", "scenes", "scene", "_resolveScene", "undefined", "getScene", "index", "_get", "getNode", "getSkin", "getMesh", "getMaterial", "getAccessor", "getCamera", "getTexture", "getSampler", "getImage", "getBufferView", "getBuffer", "array", "object", "console", "warn", "id", "children", "child", "length", "reduce", "accum", "meshIndex", "primitives", "concat", "camera", "inverseBindMatrices", "primitive", "attributes", "attribute", "indices", "normalTexture", "occlusionTexture", "occlustionTexture", "emissiveTexture", "emmisiveTexture", "emissiveFactor", "pbrMetallicRoughness", "mr", "baseColorTexture", "metallicRoughnessTexture", "bufferView", "bytesPerComponent", "components", "bytesPerElement", "buffer", "ArrayType", "byteLength", "getAccessorArrayTypeAndLength", "byteOffset", "cutBuffer", "arrayBuffer", "slice", "byteStride", "_getValueFromInterleavedBuffer", "count", "value", "result", "Uint8Array", "elementOffset", "set", "source", "parameters", "key", "glEnum", "_enumSamplerParameter", "preloadedImage", "bufferIndex", "data", "_resolveCamera", "perspective", "orthographic", "postProcessGLTF", "MAGIC_glTF", "GLB_FILE_HEADER_SIZE", "GLB_CHUNK_HEADER_SIZE", "GLB_CHUNK_TYPE_JSON", "GLB_CHUNK_TYPE_BIN", "GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED", "GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED", "GLB_V1_CONTENT_FORMAT_JSON", "LE", "getMagicString", "dataView", "byteOffset", "String", "fromCharCode", "getUint8", "isGLB", "arrayBuffer", "options", "DataView", "magic", "magic1", "getUint32", "glb", "type", "version", "byteLength", "Object", "assign", "header", "hasBinChunk", "json", "binChunks", "parseGLBV1", "parseGLBV2", "Error", "assert", "contentLength", "contentFormat", "parseJSONChunk", "parseBINChunk", "parseGLBChunksSync", "chunkLength", "chunkFormat", "strict", "padToNBytes", "jsonChunk", "Uint8Array", "buffer", "textDecoder", "TextDecoder", "jsonText", "decode", "JSON", "parse", "push", "parseGLTF", "gltf", "arrayBufferOrString", "byteOffset", "options", "context", "parseGLTFContainerSync", "normalizeGLTFV1", "normalize", "preprocessExtensions", "promises", "loadBuffers", "json", "buffers", "loadImages", "promise", "push", "decodeExtensions", "Promise", "all", "postProcess", "postProcessGLTF", "data", "uri", "baseUri", "ArrayBuffer", "isGLB", "textDecoder", "TextDecoder", "decode", "parseJSON", "glb", "parseGLBSync", "assert", "type", "_glb", "Array", "length", "fill", "header", "hasBinChunk", "binChunks", "arrayBuffer", "byteLength", "images", "i", "buffer", "fetch", "resolveUrl", "response", "imageIndices", "getReferencesImageIndices", "imageIndex", "loadImage", "Set", "textures", "texture", "source", "undefined", "add", "from", "sort", "image", "index", "parse", "hasOwnProperty", "bufferView", "Number", "isFinite", "array", "getTypedArrayForBufferView", "sliceArrayBuffer", "parsedImage", "ImageLoader", "BasisLoader", "mimeType", "basis", "format", "selectSupportedBasisFormat", "compressed", "mipmaps", "width", "height", "GLTFLoader", "name", "id", "module", "version", "VERSION", "extensions", "mimeTypes", "text", "binary", "tests", "parse", "options", "gltf", "normalize", "loadBuffers", "loadImages", "decompressMeshes", "postProcess", "log", "console", "deprecatedOptions", "fetchImages", "createImages", "decompress", "arrayBuffer", "context", "byteOffset", "parseGLTF", "MAGIC_glTF", "MAGIC_JSON", "MAGIC_BIN", "LE", "glb", "dataView", "byteOffset", "options", "magic", "version", "json", "binary", "byteOffsetStart", "setUint32", "byteOffsetFileLength", "byteOffsetJsonHeader", "jsonString", "JSON", "stringify", "copyPaddedStringToDataView", "jsonByteLength", "byteOffsetBinHeader", "copyPaddedArrayBufferToDataView", "binByteLength", "fileByteLength", "encodeGLTFSync", "gltf", "arrayBuffer", "byteOffset", "options", "convertBuffersToBase64", "encodeGLBSync", "firstBuffer", "buffers", "length", "Error", "GLTFWriter", "name", "id", "module", "version", "VERSION", "extensions", "mimeTypes", "binary", "encodeSync", "options", "gltf", "byteOffset", "byteLength", "encodeGLTFSync", "arrayBuffer", "ArrayBuffer", "dataView", "DataView", "GLBLoader", "name", "id", "module", "version", "VERSION", "extensions", "mimeTypes", "binary", "parse", "parseSync", "options", "glb", "strict", "arrayBuffer", "byteOffset", "parseGLBSync", "GLBWriter", "name", "id", "module", "version", "VERSION", "extensions", "mimeTypes", "binary", "encodeSync", "options", "glb", "byteOffset", "byteLength", "encodeGLBSync", "arrayBuffer", "ArrayBuffer", "dataView", "DataView"]
}
