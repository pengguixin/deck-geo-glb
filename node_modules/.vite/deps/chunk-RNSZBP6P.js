import {
  _defineProperty,
  assert,
  assert2,
  canEncodeWithWorker,
  canParseWithWorker,
  compareArrayBuffers,
  concatenateArrayBuffers,
  concatenateArrayBuffersAsync,
  fs,
  isBrowser,
  parseWithWorker,
  path_exports,
  processOnWorker,
  resolvePath,
  toArrayBuffer,
  toBuffer,
  validateWorkerVersion
} from "./chunk-NVCU2VMH.js";

// node_modules/@loaders.gl/core/dist/esm/javascript-utils/is-type.js
var isBoolean = (x) => typeof x === "boolean";
var isFunction = (x) => typeof x === "function";
var isObject = (x) => x !== null && typeof x === "object";
var isPureObject = (x) => isObject(x) && x.constructor === {}.constructor;
var isPromise = (x) => isObject(x) && isFunction(x.then);
var isIterable = (x) => x && typeof x[Symbol.iterator] === "function";
var isAsyncIterable = (x) => x && typeof x[Symbol.asyncIterator] === "function";
var isIterator = (x) => x && isFunction(x.next);
var isResponse = (x) => typeof Response !== "undefined" && x instanceof Response || x && x.arrayBuffer && x.text && x.json;
var isBlob = (x) => typeof Blob !== "undefined" && x instanceof Blob;
var isBuffer = (x) => x && typeof x === "object" && x.isBuffer;
var isWritableDOMStream = (x) => isObject(x) && isFunction(x.abort) && isFunction(x.getWriter);
var isReadableDOMStream = (x) => typeof ReadableStream !== "undefined" && x instanceof ReadableStream || isObject(x) && isFunction(x.tee) && isFunction(x.cancel) && isFunction(x.getReader);
var isWritableNodeStream = (x) => isObject(x) && isFunction(x.end) && isFunction(x.write) && isBoolean(x.writable);
var isReadableNodeStream = (x) => isObject(x) && isFunction(x.read) && isFunction(x.pipe) && isBoolean(x.readable);
var isReadableStream = (x) => isReadableDOMStream(x) || isReadableNodeStream(x);
var isWritableStream = (x) => isWritableDOMStream(x) || isWritableNodeStream(x);

// node_modules/@loaders.gl/core/dist/esm/lib/utils/mime-type-utils.js
var DATA_URL_PATTERN = /^data:([-\w.]+\/[-\w.+]+)(;|,)/;
var MIME_TYPE_PATTERN = /^([-\w.]+\/[-\w.+]+)/;
function parseMIMEType(mimeString) {
  const matches = MIME_TYPE_PATTERN.exec(mimeString);
  if (matches) {
    return matches[1];
  }
  return mimeString;
}
function parseMIMETypeFromURL(url) {
  const matches = DATA_URL_PATTERN.exec(url);
  if (matches) {
    return matches[1];
  }
  return "";
}

// node_modules/@loaders.gl/core/dist/esm/lib/utils/resource-utils.js
var QUERY_STRING_PATTERN = /\?.*/;
function getResourceUrlAndType(resource) {
  if (isResponse(resource)) {
    const url = stripQueryString(resource.url || "");
    const contentTypeHeader = resource.headers.get("content-type") || "";
    return {
      url,
      type: parseMIMEType(contentTypeHeader) || parseMIMETypeFromURL(url)
    };
  }
  if (isBlob(resource)) {
    return {
      url: stripQueryString(resource.name || ""),
      type: resource.type || ""
    };
  }
  if (typeof resource === "string") {
    return {
      url: stripQueryString(resource),
      type: parseMIMETypeFromURL(resource)
    };
  }
  return {
    url: "",
    type: ""
  };
}
function getResourceContentLength(resource) {
  if (isResponse(resource)) {
    return resource.headers["content-length"] || -1;
  }
  if (isBlob(resource)) {
    return resource.size;
  }
  if (typeof resource === "string") {
    return resource.length;
  }
  if (resource instanceof ArrayBuffer) {
    return resource.byteLength;
  }
  if (ArrayBuffer.isView(resource)) {
    return resource.byteLength;
  }
  return -1;
}
function stripQueryString(url) {
  return url.replace(QUERY_STRING_PATTERN, "");
}

// node_modules/@loaders.gl/core/dist/esm/lib/utils/response-utils.js
async function makeResponse(resource) {
  if (isResponse(resource)) {
    return resource;
  }
  const headers = {};
  const contentLength = getResourceContentLength(resource);
  if (contentLength >= 0) {
    headers["content-length"] = String(contentLength);
  }
  const {
    url,
    type
  } = getResourceUrlAndType(resource);
  if (type) {
    headers["content-type"] = type;
  }
  const initialDataUrl = await getInitialDataUrl(resource);
  if (initialDataUrl) {
    headers["x-first-bytes"] = initialDataUrl;
  }
  if (typeof resource === "string") {
    resource = new TextEncoder().encode(resource);
  }
  const response = new Response(resource, {
    headers
  });
  Object.defineProperty(response, "url", {
    value: url
  });
  return response;
}
async function checkResponse(response) {
  if (!response.ok) {
    const message = await getResponseError(response);
    throw new Error(message);
  }
}
async function getResponseError(response) {
  let message = "Failed to fetch resource ".concat(response.url, " (").concat(response.status, "): ");
  try {
    const contentType = response.headers.get("Content-Type");
    let text = response.statusText;
    if (contentType.includes("application/json")) {
      text += " ".concat(await response.text());
    }
    message += text;
    message = message.length > 60 ? "".concat(message.slice(0, 60), "...") : message;
  } catch (error) {
  }
  return message;
}
async function getInitialDataUrl(resource) {
  const INITIAL_DATA_LENGTH = 5;
  if (typeof resource === "string") {
    return "data:,".concat(resource.slice(0, INITIAL_DATA_LENGTH));
  }
  if (resource instanceof Blob) {
    const blobSlice = resource.slice(0, 5);
    return await new Promise((resolve) => {
      const reader = new FileReader();
      reader.onload = (event) => {
        var _event$target;
        return resolve(event === null || event === void 0 ? void 0 : (_event$target = event.target) === null || _event$target === void 0 ? void 0 : _event$target.result);
      };
      reader.readAsDataURL(blobSlice);
    });
  }
  if (resource instanceof ArrayBuffer) {
    const slice = resource.slice(0, INITIAL_DATA_LENGTH);
    const base64 = arrayBufferToBase64(slice);
    return "data:base64,".concat(base64);
  }
  return null;
}
function arrayBufferToBase64(buffer) {
  let binary = "";
  const bytes = new Uint8Array(buffer);
  for (let i = 0; i < bytes.byteLength; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return btoa(binary);
}

// node_modules/@loaders.gl/core/dist/esm/lib/fetch/fetch-file.js
async function fetchFile(url, options) {
  if (typeof url === "string") {
    url = resolvePath(url);
    let fetchOptions = options;
    if (options !== null && options !== void 0 && options.fetch && typeof (options === null || options === void 0 ? void 0 : options.fetch) !== "function") {
      fetchOptions = options.fetch;
    }
    return await fetch(url, fetchOptions);
  }
  return await makeResponse(url);
}

// node_modules/@loaders.gl/core/dist/esm/lib/fetch/read-array-buffer.js
async function readArrayBuffer(file, start, length) {
  if (typeof file === "number") {
    return await fs._readToArrayBuffer(file, start, length);
  }
  if (!(file instanceof Blob)) {
    file = new Blob([file]);
  }
  const slice = file.slice(start, start + length);
  return await readBlob(slice);
}
async function readBlob(blob) {
  return await new Promise((resolve, reject) => {
    const fileReader = new FileReader();
    fileReader.onload = (event) => {
      var _event$target;
      return resolve(event === null || event === void 0 ? void 0 : (_event$target = event.target) === null || _event$target === void 0 ? void 0 : _event$target.result);
    };
    fileReader.onerror = (error) => reject(error);
    fileReader.readAsArrayBuffer(blob);
  });
}

// node_modules/@loaders.gl/core/dist/esm/lib/fetch/read-file.js
function readFileSync(url) {
  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  url = resolvePath(url);
  if (!isBrowser) {
    const buffer = fs.readFileSync(url, options);
    return typeof buffer !== "string" ? toArrayBuffer(buffer) : buffer;
  }
  if (!options.nothrow) {
    assert(false);
  }
  return null;
}

// node_modules/@loaders.gl/core/dist/esm/lib/fetch/write-file.js
async function writeFile(filePath, arrayBufferOrString, options) {
  filePath = resolvePath(filePath);
  if (!isBrowser) {
    await fs.writeFile(filePath, toBuffer(arrayBufferOrString), {
      flag: "w"
    });
  }
  assert(false);
}
function writeFileSync(filePath, arrayBufferOrString, options) {
  filePath = resolvePath(filePath);
  if (!isBrowser) {
    fs.writeFileSync(filePath, toBuffer(arrayBufferOrString), {
      flag: "w"
    });
  }
  assert(false);
}

// node_modules/@probe.gl/env/dist/esm/lib/is-electron.js
function isElectron(mockUserAgent) {
  if (typeof window !== "undefined" && typeof window.process === "object" && window.process.type === "renderer") {
    return true;
  }
  if (typeof process !== "undefined" && typeof process.versions === "object" && Boolean(process.versions["electron"])) {
    return true;
  }
  const realUserAgent = typeof navigator === "object" && typeof navigator.userAgent === "string" && navigator.userAgent;
  const userAgent = mockUserAgent || realUserAgent;
  if (userAgent && userAgent.indexOf("Electron") >= 0) {
    return true;
  }
  return false;
}

// node_modules/@probe.gl/env/dist/esm/lib/is-browser.js
function isBrowser2() {
  const isNode = typeof process === "object" && String(process) === "[object process]" && !process.browser;
  return !isNode || isElectron();
}

// node_modules/@probe.gl/env/dist/esm/lib/globals.js
var globals = {
  self: typeof self !== "undefined" && self,
  window: typeof window !== "undefined" && window,
  global: typeof global !== "undefined" && global,
  document: typeof document !== "undefined" && document,
  process: typeof process === "object" && process
};
var self_ = globals.self || globals.window || globals.global;
var window_ = globals.window || globals.self || globals.global;
var document_ = globals.document || {};
var process_ = globals.process || {};

// node_modules/@probe.gl/env/dist/esm/utils/globals.js
var VERSION = typeof __VERSION__ !== "undefined" ? __VERSION__ : "untranspiled source";
var isBrowser3 = isBrowser2();

// node_modules/@probe.gl/env/dist/esm/lib/get-browser.js
var window2 = globalThis;
function getBrowser(mockUserAgent) {
  if (!mockUserAgent && !isBrowser2()) {
    return "Node";
  }
  if (isElectron(mockUserAgent)) {
    return "Electron";
  }
  const navigator_ = typeof navigator !== "undefined" ? navigator : {};
  const userAgent = mockUserAgent || navigator_.userAgent || "";
  if (userAgent.indexOf("Edge") > -1) {
    return "Edge";
  }
  const isMSIE = userAgent.indexOf("MSIE ") !== -1;
  const isTrident = userAgent.indexOf("Trident/") !== -1;
  if (isMSIE || isTrident) {
    return "IE";
  }
  if (window2.chrome) {
    return "Chrome";
  }
  if (window2.safari) {
    return "Safari";
  }
  if (window2.mozInnerScreenX) {
    return "Firefox";
  }
  return "Unknown";
}

// node_modules/@probe.gl/log/dist/esm/utils/local-storage.js
function getStorage(type) {
  try {
    const storage = window[type];
    const x = "__storage_test__";
    storage.setItem(x, x);
    storage.removeItem(x);
    return storage;
  } catch (e) {
    return null;
  }
}
var LocalStorage = class {
  constructor(id, defaultConfig) {
    let type = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "sessionStorage";
    _defineProperty(this, "storage", void 0);
    _defineProperty(this, "id", void 0);
    _defineProperty(this, "config", void 0);
    this.storage = getStorage(type);
    this.id = id;
    this.config = defaultConfig;
    this._loadConfiguration();
  }
  getConfiguration() {
    return this.config;
  }
  setConfiguration(configuration) {
    Object.assign(this.config, configuration);
    if (this.storage) {
      const serialized = JSON.stringify(this.config);
      this.storage.setItem(this.id, serialized);
    }
  }
  _loadConfiguration() {
    let configuration = {};
    if (this.storage) {
      const serializedConfiguration = this.storage.getItem(this.id);
      configuration = serializedConfiguration ? JSON.parse(serializedConfiguration) : {};
    }
    Object.assign(this.config, configuration);
    return this;
  }
};

// node_modules/@probe.gl/log/dist/esm/utils/formatters.js
function formatTime(ms) {
  let formatted;
  if (ms < 10) {
    formatted = "".concat(ms.toFixed(2), "ms");
  } else if (ms < 100) {
    formatted = "".concat(ms.toFixed(1), "ms");
  } else if (ms < 1e3) {
    formatted = "".concat(ms.toFixed(0), "ms");
  } else {
    formatted = "".concat((ms / 1e3).toFixed(2), "s");
  }
  return formatted;
}
function leftPad(string) {
  let length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 8;
  const padLength = Math.max(length - string.length, 0);
  return "".concat(" ".repeat(padLength)).concat(string);
}
function formatImage(image, message, scale) {
  let maxWidth = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 600;
  const imageUrl = image.src.replace(/\(/g, "%28").replace(/\)/g, "%29");
  if (image.width > maxWidth) {
    scale = Math.min(scale, maxWidth / image.width);
  }
  const width = image.width * scale;
  const height = image.height * scale;
  const style = ["font-size:1px;", "padding:".concat(Math.floor(height / 2), "px ").concat(Math.floor(width / 2), "px;"), "line-height:".concat(height, "px;"), "background:url(".concat(imageUrl, ");"), "background-size:".concat(width, "px ").concat(height, "px;"), "color:transparent;"].join("");
  return ["".concat(message, " %c+"), style];
}

// node_modules/@probe.gl/log/dist/esm/utils/color.js
var COLOR;
(function(COLOR2) {
  COLOR2[COLOR2["BLACK"] = 30] = "BLACK";
  COLOR2[COLOR2["RED"] = 31] = "RED";
  COLOR2[COLOR2["GREEN"] = 32] = "GREEN";
  COLOR2[COLOR2["YELLOW"] = 33] = "YELLOW";
  COLOR2[COLOR2["BLUE"] = 34] = "BLUE";
  COLOR2[COLOR2["MAGENTA"] = 35] = "MAGENTA";
  COLOR2[COLOR2["CYAN"] = 36] = "CYAN";
  COLOR2[COLOR2["WHITE"] = 37] = "WHITE";
  COLOR2[COLOR2["BRIGHT_BLACK"] = 90] = "BRIGHT_BLACK";
  COLOR2[COLOR2["BRIGHT_RED"] = 91] = "BRIGHT_RED";
  COLOR2[COLOR2["BRIGHT_GREEN"] = 92] = "BRIGHT_GREEN";
  COLOR2[COLOR2["BRIGHT_YELLOW"] = 93] = "BRIGHT_YELLOW";
  COLOR2[COLOR2["BRIGHT_BLUE"] = 94] = "BRIGHT_BLUE";
  COLOR2[COLOR2["BRIGHT_MAGENTA"] = 95] = "BRIGHT_MAGENTA";
  COLOR2[COLOR2["BRIGHT_CYAN"] = 96] = "BRIGHT_CYAN";
  COLOR2[COLOR2["BRIGHT_WHITE"] = 97] = "BRIGHT_WHITE";
})(COLOR || (COLOR = {}));
function getColor(color) {
  return typeof color === "string" ? COLOR[color.toUpperCase()] || COLOR.WHITE : color;
}
function addColor(string, color, background) {
  if (!isBrowser2 && typeof string === "string") {
    if (color) {
      color = getColor(color);
      string = "\x1B[".concat(color, "m").concat(string, "\x1B[39m");
    }
    if (background) {
      color = getColor(background);
      string = "\x1B[".concat(background + 10, "m").concat(string, "\x1B[49m");
    }
  }
  return string;
}

// node_modules/@probe.gl/log/dist/esm/utils/autobind.js
function autobind(obj) {
  let predefined = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ["constructor"];
  const proto = Object.getPrototypeOf(obj);
  const propNames = Object.getOwnPropertyNames(proto);
  for (const key of propNames) {
    if (typeof obj[key] === "function") {
      if (!predefined.find((name) => key === name)) {
        obj[key] = obj[key].bind(obj);
      }
    }
  }
}

// node_modules/@probe.gl/log/dist/esm/utils/assert.js
function assert4(condition, message) {
  if (!condition) {
    throw new Error(message || "Assertion failed");
  }
}

// node_modules/@probe.gl/log/dist/esm/utils/hi-res-timestamp.js
function getHiResTimestamp() {
  let timestamp;
  if (isBrowser2 && "performance" in window_) {
    var _window$performance, _window$performance$n;
    timestamp = window_ === null || window_ === void 0 ? void 0 : (_window$performance = window_.performance) === null || _window$performance === void 0 ? void 0 : (_window$performance$n = _window$performance.now) === null || _window$performance$n === void 0 ? void 0 : _window$performance$n.call(_window$performance);
  } else if ("hrtime" in process_) {
    var _process$hrtime;
    const timeParts = process_ === null || process_ === void 0 ? void 0 : (_process$hrtime = process_.hrtime) === null || _process$hrtime === void 0 ? void 0 : _process$hrtime.call(process_);
    timestamp = timeParts[0] * 1e3 + timeParts[1] / 1e6;
  } else {
    timestamp = Date.now();
  }
  return timestamp;
}

// node_modules/@probe.gl/log/dist/esm/log.js
var originalConsole = {
  debug: isBrowser2 ? console.debug || console.log : console.log,
  log: console.log,
  info: console.info,
  warn: console.warn,
  error: console.error
};
var DEFAULT_SETTINGS = {
  enabled: true,
  level: 0
};
function noop() {
}
var cache = {};
var ONCE = {
  once: true
};
var Log = class {
  constructor() {
    let {
      id
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      id: ""
    };
    _defineProperty(this, "id", void 0);
    _defineProperty(this, "VERSION", VERSION);
    _defineProperty(this, "_startTs", getHiResTimestamp());
    _defineProperty(this, "_deltaTs", getHiResTimestamp());
    _defineProperty(this, "_storage", void 0);
    _defineProperty(this, "userData", {});
    _defineProperty(this, "LOG_THROTTLE_TIMEOUT", 0);
    this.id = id;
    this.userData = {};
    this._storage = new LocalStorage("__probe-".concat(this.id, "__"), DEFAULT_SETTINGS);
    this.timeStamp("".concat(this.id, " started"));
    autobind(this);
    Object.seal(this);
  }
  set level(newLevel) {
    this.setLevel(newLevel);
  }
  get level() {
    return this.getLevel();
  }
  isEnabled() {
    return this._storage.config.enabled;
  }
  getLevel() {
    return this._storage.config.level;
  }
  getTotal() {
    return Number((getHiResTimestamp() - this._startTs).toPrecision(10));
  }
  getDelta() {
    return Number((getHiResTimestamp() - this._deltaTs).toPrecision(10));
  }
  set priority(newPriority) {
    this.level = newPriority;
  }
  get priority() {
    return this.level;
  }
  getPriority() {
    return this.level;
  }
  enable() {
    let enabled = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
    this._storage.setConfiguration({
      enabled
    });
    return this;
  }
  setLevel(level) {
    this._storage.setConfiguration({
      level
    });
    return this;
  }
  get(setting) {
    return this._storage.config[setting];
  }
  set(setting, value) {
    this._storage.setConfiguration({
      [setting]: value
    });
  }
  settings() {
    if (console.table) {
      console.table(this._storage.config);
    } else {
      console.log(this._storage.config);
    }
  }
  assert(condition, message) {
    assert4(condition, message);
  }
  warn(message) {
    return this._getLogFunction(0, message, originalConsole.warn, arguments, ONCE);
  }
  error(message) {
    return this._getLogFunction(0, message, originalConsole.error, arguments);
  }
  deprecated(oldUsage, newUsage) {
    return this.warn("`".concat(oldUsage, "` is deprecated and will be removed in a later version. Use `").concat(newUsage, "` instead"));
  }
  removed(oldUsage, newUsage) {
    return this.error("`".concat(oldUsage, "` has been removed. Use `").concat(newUsage, "` instead"));
  }
  probe(logLevel, message) {
    return this._getLogFunction(logLevel, message, originalConsole.log, arguments, {
      time: true,
      once: true
    });
  }
  log(logLevel, message) {
    return this._getLogFunction(logLevel, message, originalConsole.debug, arguments);
  }
  info(logLevel, message) {
    return this._getLogFunction(logLevel, message, console.info, arguments);
  }
  once(logLevel, message) {
    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }
    return this._getLogFunction(logLevel, message, originalConsole.debug || originalConsole.info, arguments, ONCE);
  }
  table(logLevel, table, columns) {
    if (table) {
      return this._getLogFunction(logLevel, table, console.table || noop, columns && [columns], {
        tag: getTableHeader(table)
      });
    }
    return noop;
  }
  image(_ref) {
    let {
      logLevel,
      priority,
      image,
      message = "",
      scale = 1
    } = _ref;
    if (!this._shouldLog(logLevel || priority)) {
      return noop;
    }
    return isBrowser2 ? logImageInBrowser({
      image,
      message,
      scale
    }) : logImageInNode({
      image,
      message,
      scale
    });
  }
  time(logLevel, message) {
    return this._getLogFunction(logLevel, message, console.time ? console.time : console.info);
  }
  timeEnd(logLevel, message) {
    return this._getLogFunction(logLevel, message, console.timeEnd ? console.timeEnd : console.info);
  }
  timeStamp(logLevel, message) {
    return this._getLogFunction(logLevel, message, console.timeStamp || noop);
  }
  group(logLevel, message) {
    let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
      collapsed: false
    };
    const options = normalizeArguments({
      logLevel,
      message,
      opts
    });
    const {
      collapsed
    } = opts;
    options.method = (collapsed ? console.groupCollapsed : console.group) || console.info;
    return this._getLogFunction(options);
  }
  groupCollapsed(logLevel, message) {
    let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return this.group(logLevel, message, Object.assign({}, opts, {
      collapsed: true
    }));
  }
  groupEnd(logLevel) {
    return this._getLogFunction(logLevel, "", console.groupEnd || noop);
  }
  withGroup(logLevel, message, func) {
    this.group(logLevel, message)();
    try {
      func();
    } finally {
      this.groupEnd(logLevel)();
    }
  }
  trace() {
    if (console.trace) {
      console.trace();
    }
  }
  _shouldLog(logLevel) {
    return this.isEnabled() && this.getLevel() >= normalizeLogLevel(logLevel);
  }
  _getLogFunction(logLevel, message, method, args, opts) {
    if (this._shouldLog(logLevel)) {
      opts = normalizeArguments({
        logLevel,
        message,
        args,
        opts
      });
      method = method || opts.method;
      assert4(method);
      opts.total = this.getTotal();
      opts.delta = this.getDelta();
      this._deltaTs = getHiResTimestamp();
      const tag = opts.tag || opts.message;
      if (opts.once) {
        if (!cache[tag]) {
          cache[tag] = getHiResTimestamp();
        } else {
          return noop;
        }
      }
      message = decorateMessage(this.id, opts.message, opts);
      return method.bind(console, message, ...opts.args);
    }
    return noop;
  }
};
_defineProperty(Log, "VERSION", VERSION);
function normalizeLogLevel(logLevel) {
  if (!logLevel) {
    return 0;
  }
  let resolvedLevel;
  switch (typeof logLevel) {
    case "number":
      resolvedLevel = logLevel;
      break;
    case "object":
      resolvedLevel = logLevel.logLevel || logLevel.priority || 0;
      break;
    default:
      return 0;
  }
  assert4(Number.isFinite(resolvedLevel) && resolvedLevel >= 0);
  return resolvedLevel;
}
function normalizeArguments(opts) {
  const {
    logLevel,
    message
  } = opts;
  opts.logLevel = normalizeLogLevel(logLevel);
  const args = opts.args ? Array.from(opts.args) : [];
  while (args.length && args.shift() !== message) {
  }
  switch (typeof logLevel) {
    case "string":
    case "function":
      if (message !== void 0) {
        args.unshift(message);
      }
      opts.message = logLevel;
      break;
    case "object":
      Object.assign(opts, logLevel);
      break;
    default:
  }
  if (typeof opts.message === "function") {
    opts.message = opts.message();
  }
  const messageType = typeof opts.message;
  assert4(messageType === "string" || messageType === "object");
  return Object.assign(opts, {
    args
  }, opts.opts);
}
function decorateMessage(id, message, opts) {
  if (typeof message === "string") {
    const time = opts.time ? leftPad(formatTime(opts.total)) : "";
    message = opts.time ? "".concat(id, ": ").concat(time, "  ").concat(message) : "".concat(id, ": ").concat(message);
    message = addColor(message, opts.color, opts.background);
  }
  return message;
}
function logImageInNode(_ref2) {
  let {
    image,
    message = "",
    scale = 1
  } = _ref2;
  console.warn("removed");
  return noop;
}
function logImageInBrowser(_ref3) {
  let {
    image,
    message = "",
    scale = 1
  } = _ref3;
  if (typeof image === "string") {
    const img = new Image();
    img.onload = () => {
      const args = formatImage(img, message, scale);
      console.log(...args);
    };
    img.src = image;
    return noop;
  }
  const element = image.nodeName || "";
  if (element.toLowerCase() === "img") {
    console.log(...formatImage(image, message, scale));
    return noop;
  }
  if (element.toLowerCase() === "canvas") {
    const img = new Image();
    img.onload = () => console.log(...formatImage(img, message, scale));
    img.src = image.toDataURL();
    return noop;
  }
  return noop;
}
function getTableHeader(table) {
  for (const key in table) {
    for (const title in table[key]) {
      return title || "untitled";
    }
  }
  return "empty";
}

// node_modules/@probe.gl/log/dist/esm/init.js
globalThis.probe = {};

// node_modules/@probe.gl/log/dist/esm/index.js
var esm_default = new Log({
  id: "@probe.gl/log"
});

// node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/loggers.js
var probeLog = new Log({
  id: "loaders.gl"
});
var NullLog = class {
  log() {
    return () => {
    };
  }
  info() {
    return () => {
    };
  }
  warn() {
    return () => {
    };
  }
  error() {
    return () => {
    };
  }
};
var ConsoleLog = class {
  constructor() {
    _defineProperty(this, "console", void 0);
    this.console = console;
  }
  log() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return this.console.log.bind(this.console, ...args);
  }
  info() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return this.console.info.bind(this.console, ...args);
  }
  warn() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    return this.console.warn.bind(this.console, ...args);
  }
  error() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    return this.console.error.bind(this.console, ...args);
  }
};

// node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/option-defaults.js
var DEFAULT_LOADER_OPTIONS = {
  fetch: null,
  mimeType: void 0,
  nothrow: false,
  log: new ConsoleLog(),
  CDN: "https://unpkg.com/@loaders.gl",
  worker: true,
  maxConcurrency: 3,
  maxMobileConcurrency: 1,
  reuseWorkers: isBrowser,
  _nodeWorkers: false,
  _workerType: "",
  limit: 0,
  _limitMB: 0,
  batchSize: "auto",
  batchDebounceMs: 0,
  metadata: false,
  transforms: []
};
var REMOVED_LOADER_OPTIONS = {
  throws: "nothrow",
  dataType: "(no longer used)",
  uri: "baseUri",
  method: "fetch.method",
  headers: "fetch.headers",
  body: "fetch.body",
  mode: "fetch.mode",
  credentials: "fetch.credentials",
  cache: "fetch.cache",
  redirect: "fetch.redirect",
  referrer: "fetch.referrer",
  referrerPolicy: "fetch.referrerPolicy",
  integrity: "fetch.integrity",
  keepalive: "fetch.keepalive",
  signal: "fetch.signal"
};

// node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/option-utils.js
function getGlobalLoaderState() {
  globalThis.loaders = globalThis.loaders || {};
  const {
    loaders
  } = globalThis;
  loaders._state = loaders._state || {};
  return loaders._state;
}
var getGlobalLoaderOptions = () => {
  const state = getGlobalLoaderState();
  state.globalOptions = state.globalOptions || {
    ...DEFAULT_LOADER_OPTIONS
  };
  return state.globalOptions;
};
function setGlobalOptions(options) {
  const state = getGlobalLoaderState();
  const globalOptions = getGlobalLoaderOptions();
  state.globalOptions = normalizeOptionsInternal(globalOptions, options);
}
function normalizeOptions(options, loader, loaders, url) {
  loaders = loaders || [];
  loaders = Array.isArray(loaders) ? loaders : [loaders];
  validateOptions(options, loaders);
  return normalizeOptionsInternal(loader, options, url);
}
function getFetchFunction(options, context) {
  const globalOptions = getGlobalLoaderOptions();
  const fetchOptions = options || globalOptions;
  if (typeof fetchOptions.fetch === "function") {
    return fetchOptions.fetch;
  }
  if (isObject(fetchOptions.fetch)) {
    return (url) => fetchFile(url, fetchOptions);
  }
  if (context !== null && context !== void 0 && context.fetch) {
    return context === null || context === void 0 ? void 0 : context.fetch;
  }
  return fetchFile;
}
function validateOptions(options, loaders) {
  validateOptionsObject(options, null, DEFAULT_LOADER_OPTIONS, REMOVED_LOADER_OPTIONS, loaders);
  for (const loader of loaders) {
    const idOptions = options && options[loader.id] || {};
    const loaderOptions = loader.options && loader.options[loader.id] || {};
    const deprecatedOptions = loader.deprecatedOptions && loader.deprecatedOptions[loader.id] || {};
    validateOptionsObject(idOptions, loader.id, loaderOptions, deprecatedOptions, loaders);
  }
}
function validateOptionsObject(options, id, defaultOptions, deprecatedOptions, loaders) {
  const loaderName = id || "Top level";
  const prefix = id ? "".concat(id, ".") : "";
  for (const key in options) {
    const isSubOptions = !id && isObject(options[key]);
    const isBaseUriOption = key === "baseUri" && !id;
    const isWorkerUrlOption = key === "workerUrl" && id;
    if (!(key in defaultOptions) && !isBaseUriOption && !isWorkerUrlOption) {
      if (key in deprecatedOptions) {
        probeLog.warn("".concat(loaderName, " loader option '").concat(prefix).concat(key, "' no longer supported, use '").concat(deprecatedOptions[key], "'"))();
      } else if (!isSubOptions) {
        const suggestion = findSimilarOption(key, loaders);
        probeLog.warn("".concat(loaderName, " loader option '").concat(prefix).concat(key, "' not recognized. ").concat(suggestion))();
      }
    }
  }
}
function findSimilarOption(optionKey, loaders) {
  const lowerCaseOptionKey = optionKey.toLowerCase();
  let bestSuggestion = "";
  for (const loader of loaders) {
    for (const key in loader.options) {
      if (optionKey === key) {
        return "Did you mean '".concat(loader.id, ".").concat(key, "'?");
      }
      const lowerCaseKey = key.toLowerCase();
      const isPartialMatch = lowerCaseOptionKey.startsWith(lowerCaseKey) || lowerCaseKey.startsWith(lowerCaseOptionKey);
      if (isPartialMatch) {
        bestSuggestion = bestSuggestion || "Did you mean '".concat(loader.id, ".").concat(key, "'?");
      }
    }
  }
  return bestSuggestion;
}
function normalizeOptionsInternal(loader, options, url) {
  const loaderDefaultOptions = loader.options || {};
  const mergedOptions = {
    ...loaderDefaultOptions
  };
  addUrlOptions(mergedOptions, url);
  if (mergedOptions.log === null) {
    mergedOptions.log = new NullLog();
  }
  mergeNestedFields(mergedOptions, getGlobalLoaderOptions());
  mergeNestedFields(mergedOptions, options);
  return mergedOptions;
}
function mergeNestedFields(mergedOptions, options) {
  for (const key in options) {
    if (key in options) {
      const value = options[key];
      if (isPureObject(value) && isPureObject(mergedOptions[key])) {
        mergedOptions[key] = {
          ...mergedOptions[key],
          ...options[key]
        };
      } else {
        mergedOptions[key] = options[key];
      }
    }
  }
}
function addUrlOptions(options, url) {
  if (url && !("baseUri" in options)) {
    options.baseUri = url;
  }
}

// node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/normalize-loader.js
function isLoaderObject(loader) {
  var _loader;
  if (!loader) {
    return false;
  }
  if (Array.isArray(loader)) {
    loader = loader[0];
  }
  const hasExtensions = Array.isArray((_loader = loader) === null || _loader === void 0 ? void 0 : _loader.extensions);
  return hasExtensions;
}
function normalizeLoader(loader) {
  var _loader2, _loader3;
  assert(loader, "null loader");
  assert(isLoaderObject(loader), "invalid loader");
  let options;
  if (Array.isArray(loader)) {
    options = loader[1];
    loader = loader[0];
    loader = {
      ...loader,
      options: {
        ...loader.options,
        ...options
      }
    };
  }
  if ((_loader2 = loader) !== null && _loader2 !== void 0 && _loader2.parseTextSync || (_loader3 = loader) !== null && _loader3 !== void 0 && _loader3.parseText) {
    loader.text = true;
  }
  if (!loader.text) {
    loader.binary = true;
  }
  return loader;
}

// node_modules/@loaders.gl/core/dist/esm/lib/api/register-loaders.js
var getGlobalLoaderRegistry = () => {
  const state = getGlobalLoaderState();
  state.loaderRegistry = state.loaderRegistry || [];
  return state.loaderRegistry;
};
function registerLoaders(loaders) {
  const loaderRegistry = getGlobalLoaderRegistry();
  loaders = Array.isArray(loaders) ? loaders : [loaders];
  for (const loader of loaders) {
    const normalizedLoader = normalizeLoader(loader);
    if (!loaderRegistry.find((registeredLoader) => normalizedLoader === registeredLoader)) {
      loaderRegistry.unshift(normalizedLoader);
    }
  }
}
function getRegisteredLoaders() {
  return getGlobalLoaderRegistry();
}
function _unregisterLoaders() {
  const state = getGlobalLoaderState();
  state.loaderRegistry = [];
}

// node_modules/@loaders.gl/core/dist/esm/lib/utils/log.js
var log = new Log({
  id: "loaders.gl"
});

// node_modules/@loaders.gl/core/dist/esm/lib/api/select-loader.js
var EXT_PATTERN = /\.([^.]+)$/;
async function selectLoader(data) {
  let loaders = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  let options = arguments.length > 2 ? arguments[2] : void 0;
  let context = arguments.length > 3 ? arguments[3] : void 0;
  if (!validHTTPResponse(data)) {
    return null;
  }
  let loader = selectLoaderSync(data, loaders, {
    ...options,
    nothrow: true
  }, context);
  if (loader) {
    return loader;
  }
  if (isBlob(data)) {
    data = await data.slice(0, 10).arrayBuffer();
    loader = selectLoaderSync(data, loaders, options, context);
  }
  if (!loader && !(options !== null && options !== void 0 && options.nothrow)) {
    throw new Error(getNoValidLoaderMessage(data));
  }
  return loader;
}
function selectLoaderSync(data) {
  let loaders = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  let options = arguments.length > 2 ? arguments[2] : void 0;
  let context = arguments.length > 3 ? arguments[3] : void 0;
  if (!validHTTPResponse(data)) {
    return null;
  }
  if (loaders && !Array.isArray(loaders)) {
    return normalizeLoader(loaders);
  }
  let candidateLoaders = [];
  if (loaders) {
    candidateLoaders = candidateLoaders.concat(loaders);
  }
  if (!(options !== null && options !== void 0 && options.ignoreRegisteredLoaders)) {
    candidateLoaders.push(...getRegisteredLoaders());
  }
  normalizeLoaders(candidateLoaders);
  const loader = selectLoaderInternal(data, candidateLoaders, options, context);
  if (!loader && !(options !== null && options !== void 0 && options.nothrow)) {
    throw new Error(getNoValidLoaderMessage(data));
  }
  return loader;
}
function selectLoaderInternal(data, loaders, options, context) {
  const {
    url,
    type
  } = getResourceUrlAndType(data);
  const testUrl = url || (context === null || context === void 0 ? void 0 : context.url);
  let loader = null;
  let reason = "";
  if (options !== null && options !== void 0 && options.mimeType) {
    loader = findLoaderByMIMEType(loaders, options === null || options === void 0 ? void 0 : options.mimeType);
    reason = "match forced by supplied MIME type ".concat(options === null || options === void 0 ? void 0 : options.mimeType);
  }
  loader = loader || findLoaderByUrl(loaders, testUrl);
  reason = reason || (loader ? "matched url ".concat(testUrl) : "");
  loader = loader || findLoaderByMIMEType(loaders, type);
  reason = reason || (loader ? "matched MIME type ".concat(type) : "");
  loader = loader || findLoaderByInitialBytes(loaders, data);
  reason = reason || (loader ? "matched initial data ".concat(getFirstCharacters(data)) : "");
  loader = loader || findLoaderByMIMEType(loaders, options === null || options === void 0 ? void 0 : options.fallbackMimeType);
  reason = reason || (loader ? "matched fallback MIME type ".concat(type) : "");
  if (reason) {
    var _loader;
    log.log(1, "selectLoader selected ".concat((_loader = loader) === null || _loader === void 0 ? void 0 : _loader.name, ": ").concat(reason, "."));
  }
  return loader;
}
function validHTTPResponse(data) {
  if (data instanceof Response) {
    if (data.status === 204) {
      return false;
    }
  }
  return true;
}
function getNoValidLoaderMessage(data) {
  const {
    url,
    type
  } = getResourceUrlAndType(data);
  let message = "No valid loader found (";
  message += url ? "".concat(path_exports.filename(url), ", ") : "no url provided, ";
  message += "MIME type: ".concat(type ? '"'.concat(type, '"') : "not provided", ", ");
  const firstCharacters = data ? getFirstCharacters(data) : "";
  message += firstCharacters ? ' first bytes: "'.concat(firstCharacters, '"') : "first bytes: not available";
  message += ")";
  return message;
}
function normalizeLoaders(loaders) {
  for (const loader of loaders) {
    normalizeLoader(loader);
  }
}
function findLoaderByUrl(loaders, url) {
  const match = url && EXT_PATTERN.exec(url);
  const extension = match && match[1];
  return extension ? findLoaderByExtension(loaders, extension) : null;
}
function findLoaderByExtension(loaders, extension) {
  extension = extension.toLowerCase();
  for (const loader of loaders) {
    for (const loaderExtension of loader.extensions) {
      if (loaderExtension.toLowerCase() === extension) {
        return loader;
      }
    }
  }
  return null;
}
function findLoaderByMIMEType(loaders, mimeType) {
  for (const loader of loaders) {
    if (loader.mimeTypes && loader.mimeTypes.includes(mimeType)) {
      return loader;
    }
    if (mimeType === "application/x.".concat(loader.id)) {
      return loader;
    }
  }
  return null;
}
function findLoaderByInitialBytes(loaders, data) {
  if (!data) {
    return null;
  }
  for (const loader of loaders) {
    if (typeof data === "string") {
      if (testDataAgainstText(data, loader)) {
        return loader;
      }
    } else if (ArrayBuffer.isView(data)) {
      if (testDataAgainstBinary(data.buffer, data.byteOffset, loader)) {
        return loader;
      }
    } else if (data instanceof ArrayBuffer) {
      const byteOffset = 0;
      if (testDataAgainstBinary(data, byteOffset, loader)) {
        return loader;
      }
    }
  }
  return null;
}
function testDataAgainstText(data, loader) {
  if (loader.testText) {
    return loader.testText(data);
  }
  const tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];
  return tests.some((test) => data.startsWith(test));
}
function testDataAgainstBinary(data, byteOffset, loader) {
  const tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];
  return tests.some((test) => testBinary(data, byteOffset, loader, test));
}
function testBinary(data, byteOffset, loader, test) {
  if (test instanceof ArrayBuffer) {
    return compareArrayBuffers(test, data, test.byteLength);
  }
  switch (typeof test) {
    case "function":
      return test(data, loader);
    case "string":
      const magic = getMagicString(data, byteOffset, test.length);
      return test === magic;
    default:
      return false;
  }
}
function getFirstCharacters(data) {
  let length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5;
  if (typeof data === "string") {
    return data.slice(0, length);
  } else if (ArrayBuffer.isView(data)) {
    return getMagicString(data.buffer, data.byteOffset, length);
  } else if (data instanceof ArrayBuffer) {
    const byteOffset = 0;
    return getMagicString(data, byteOffset, length);
  }
  return "";
}
function getMagicString(arrayBuffer, byteOffset, length) {
  if (arrayBuffer.byteLength < byteOffset + length) {
    return "";
  }
  const dataView = new DataView(arrayBuffer);
  let magic = "";
  for (let i = 0; i < length; i++) {
    magic += String.fromCharCode(dataView.getUint8(byteOffset + i));
  }
  return magic;
}

// node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-string-iterator.js
var DEFAULT_CHUNK_SIZE = 256 * 1024;
function* makeStringIterator(string, options) {
  const chunkSize = (options === null || options === void 0 ? void 0 : options.chunkSize) || DEFAULT_CHUNK_SIZE;
  let offset = 0;
  const textEncoder = new TextEncoder();
  while (offset < string.length) {
    const chunkLength = Math.min(string.length - offset, chunkSize);
    const chunk = string.slice(offset, offset + chunkLength);
    offset += chunkLength;
    yield textEncoder.encode(chunk);
  }
}

// node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-array-buffer-iterator.js
var DEFAULT_CHUNK_SIZE2 = 256 * 1024;
function* makeArrayBufferIterator(arrayBuffer) {
  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    chunkSize = DEFAULT_CHUNK_SIZE2
  } = options;
  let byteOffset = 0;
  while (byteOffset < arrayBuffer.byteLength) {
    const chunkByteLength = Math.min(arrayBuffer.byteLength - byteOffset, chunkSize);
    const chunk = new ArrayBuffer(chunkByteLength);
    const sourceArray = new Uint8Array(arrayBuffer, byteOffset, chunkByteLength);
    const chunkArray = new Uint8Array(chunk);
    chunkArray.set(sourceArray);
    byteOffset += chunkByteLength;
    yield chunk;
  }
}

// node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-blob-iterator.js
var DEFAULT_CHUNK_SIZE3 = 1024 * 1024;
async function* makeBlobIterator(blob, options) {
  const chunkSize = (options === null || options === void 0 ? void 0 : options.chunkSize) || DEFAULT_CHUNK_SIZE3;
  let offset = 0;
  while (offset < blob.size) {
    const end = offset + chunkSize;
    const chunk = await blob.slice(offset, end).arrayBuffer();
    offset = end;
    yield chunk;
  }
}

// node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-stream-iterator.js
function makeStreamIterator(stream, options) {
  return isBrowser ? makeBrowserStreamIterator(stream, options) : makeNodeStreamIterator(stream, options);
}
async function* makeBrowserStreamIterator(stream, options) {
  const reader = stream.getReader();
  let nextBatchPromise;
  try {
    while (true) {
      const currentBatchPromise = nextBatchPromise || reader.read();
      if (options !== null && options !== void 0 && options._streamReadAhead) {
        nextBatchPromise = reader.read();
      }
      const {
        done,
        value
      } = await currentBatchPromise;
      if (done) {
        return;
      }
      yield toArrayBuffer(value);
    }
  } catch (error) {
    reader.releaseLock();
  }
}
async function* makeNodeStreamIterator(stream, options) {
  for await (const chunk of stream) {
    yield toArrayBuffer(chunk);
  }
}

// node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-iterator.js
function makeIterator(data, options) {
  if (typeof data === "string") {
    return makeStringIterator(data, options);
  }
  if (data instanceof ArrayBuffer) {
    return makeArrayBufferIterator(data, options);
  }
  if (isBlob(data)) {
    return makeBlobIterator(data, options);
  }
  if (isReadableStream(data)) {
    return makeStreamIterator(data, options);
  }
  if (isResponse(data)) {
    const response = data;
    return makeStreamIterator(response.body, options);
  }
  throw new Error("makeIterator");
}

// node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/get-data.js
var ERR_DATA = "Cannot convert supplied data type";
function getArrayBufferOrStringFromDataSync(data, loader, options) {
  if (loader.text && typeof data === "string") {
    return data;
  }
  if (isBuffer(data)) {
    data = data.buffer;
  }
  if (data instanceof ArrayBuffer) {
    const arrayBuffer = data;
    if (loader.text && !loader.binary) {
      const textDecoder = new TextDecoder("utf8");
      return textDecoder.decode(arrayBuffer);
    }
    return arrayBuffer;
  }
  if (ArrayBuffer.isView(data)) {
    if (loader.text && !loader.binary) {
      const textDecoder = new TextDecoder("utf8");
      return textDecoder.decode(data);
    }
    let arrayBuffer = data.buffer;
    const byteLength = data.byteLength || data.length;
    if (data.byteOffset !== 0 || byteLength !== arrayBuffer.byteLength) {
      arrayBuffer = arrayBuffer.slice(data.byteOffset, data.byteOffset + byteLength);
    }
    return arrayBuffer;
  }
  throw new Error(ERR_DATA);
}
async function getArrayBufferOrStringFromData(data, loader, options) {
  const isArrayBuffer = data instanceof ArrayBuffer || ArrayBuffer.isView(data);
  if (typeof data === "string" || isArrayBuffer) {
    return getArrayBufferOrStringFromDataSync(data, loader, options);
  }
  if (isBlob(data)) {
    data = await makeResponse(data);
  }
  if (isResponse(data)) {
    const response = data;
    await checkResponse(response);
    return loader.binary ? await response.arrayBuffer() : await response.text();
  }
  if (isReadableStream(data)) {
    data = makeIterator(data, options);
  }
  if (isIterable(data) || isAsyncIterable(data)) {
    return concatenateArrayBuffersAsync(data);
  }
  throw new Error(ERR_DATA);
}
async function getAsyncIterableFromData(data, options) {
  if (isIterator(data)) {
    return data;
  }
  if (isResponse(data)) {
    const response = data;
    await checkResponse(response);
    const body = await response.body;
    return makeIterator(body, options);
  }
  if (isBlob(data) || isReadableStream(data)) {
    return makeIterator(data, options);
  }
  if (isAsyncIterable(data)) {
    return data[Symbol.asyncIterator]();
  }
  return getIterableFromData(data);
}
function getIterableFromData(data) {
  if (ArrayBuffer.isView(data)) {
    return function* oneChunk() {
      yield data.buffer;
    }();
  }
  if (data instanceof ArrayBuffer) {
    return function* oneChunk() {
      yield data;
    }();
  }
  if (isIterator(data)) {
    return data;
  }
  if (isIterable(data)) {
    return data[Symbol.iterator]();
  }
  throw new Error(ERR_DATA);
}

// node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/loader-context.js
function getLoaderContext(context, options) {
  let previousContext = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
  if (previousContext) {
    return previousContext;
  }
  const resolvedContext = {
    fetch: getFetchFunction(options, context),
    ...context
  };
  if (!Array.isArray(resolvedContext.loaders)) {
    resolvedContext.loaders = null;
  }
  return resolvedContext;
}
function getLoadersFromContext(loaders, context) {
  if (!context && loaders && !Array.isArray(loaders)) {
    return loaders;
  }
  let candidateLoaders;
  if (loaders) {
    candidateLoaders = Array.isArray(loaders) ? loaders : [loaders];
  }
  if (context && context.loaders) {
    const contextLoaders = Array.isArray(context.loaders) ? context.loaders : [context.loaders];
    candidateLoaders = candidateLoaders ? [...candidateLoaders, ...contextLoaders] : contextLoaders;
  }
  return candidateLoaders && candidateLoaders.length ? candidateLoaders : null;
}

// node_modules/@loaders.gl/core/dist/esm/lib/api/parse.js
async function parse(data, loaders, options, context) {
  assert2(!context || typeof context === "object");
  if (loaders && !Array.isArray(loaders) && !isLoaderObject(loaders)) {
    context = void 0;
    options = loaders;
    loaders = void 0;
  }
  data = await data;
  options = options || {};
  const {
    url
  } = getResourceUrlAndType(data);
  const typedLoaders = loaders;
  const candidateLoaders = getLoadersFromContext(typedLoaders, context);
  const loader = await selectLoader(data, candidateLoaders, options);
  if (!loader) {
    return null;
  }
  options = normalizeOptions(options, loader, candidateLoaders, url);
  context = getLoaderContext({
    url,
    parse,
    loaders: candidateLoaders
  }, options, context);
  return await parseWithLoader(loader, data, options, context);
}
async function parseWithLoader(loader, data, options, context) {
  validateWorkerVersion(loader);
  if (isResponse(data)) {
    const response = data;
    const {
      ok,
      redirected,
      status,
      statusText,
      type,
      url
    } = response;
    const headers = Object.fromEntries(response.headers.entries());
    context.response = {
      headers,
      ok,
      redirected,
      status,
      statusText,
      type,
      url
    };
  }
  data = await getArrayBufferOrStringFromData(data, loader, options);
  if (loader.parseTextSync && typeof data === "string") {
    options.dataType = "text";
    return loader.parseTextSync(data, options, context, loader);
  }
  if (canParseWithWorker(loader, options)) {
    return await parseWithWorker(loader, data, options, context, parse);
  }
  if (loader.parseText && typeof data === "string") {
    return await loader.parseText(data, options, context, loader);
  }
  if (loader.parse) {
    return await loader.parse(data, options, context, loader);
  }
  assert2(!loader.parseSync);
  throw new Error("".concat(loader.id, " loader - no parser found and worker is disabled"));
}

// node_modules/@loaders.gl/core/dist/esm/lib/api/parse-sync.js
function parseSync(data, loaders, options, context) {
  assert(!context || typeof context === "object");
  if (!Array.isArray(loaders) && !isLoaderObject(loaders)) {
    context = void 0;
    options = loaders;
    loaders = void 0;
  }
  options = options || {};
  const typedLoaders = loaders;
  const candidateLoaders = getLoadersFromContext(typedLoaders, context);
  const loader = selectLoaderSync(data, candidateLoaders, options);
  if (!loader) {
    return null;
  }
  options = normalizeOptions(options, loader, candidateLoaders);
  const {
    url
  } = getResourceUrlAndType(data);
  const parse2 = () => {
    throw new Error("parseSync called parse");
  };
  context = getLoaderContext({
    url,
    parseSync,
    parse: parse2,
    loaders
  }, options);
  return parseWithLoaderSync(loader, data, options, context);
}
function parseWithLoaderSync(loader, data, options, context) {
  data = getArrayBufferOrStringFromDataSync(data, loader, options);
  if (loader.parseTextSync && typeof data === "string") {
    return loader.parseTextSync(data, options);
  }
  if (loader.parseSync && data instanceof ArrayBuffer) {
    return loader.parseSync(data, options, context);
  }
  throw new Error("".concat(loader.name, " loader: 'parseSync' not supported by this loader, use 'parse' instead. ").concat(context.url || ""));
}

// node_modules/@loaders.gl/core/dist/esm/lib/api/parse-in-batches.js
async function parseInBatches(data, loaders, options, context) {
  assert(!context || typeof context === "object");
  if (!Array.isArray(loaders) && !isLoaderObject(loaders)) {
    context = void 0;
    options = loaders;
    loaders = void 0;
  }
  data = await data;
  options = options || {};
  const {
    url
  } = getResourceUrlAndType(data);
  const loader = await selectLoader(data, loaders, options);
  if (!loader) {
    return null;
  }
  options = normalizeOptions(options, loader, loaders, url);
  context = getLoaderContext(
    {
      url,
      parseInBatches,
      parse,
      loaders
    },
    options,
    context
  );
  return await parseWithLoaderInBatches(loader, data, options, context);
}
async function parseWithLoaderInBatches(loader, data, options, context) {
  const outputIterator = await parseToOutputIterator(loader, data, options, context);
  if (!options.metadata) {
    return outputIterator;
  }
  const metadataBatch = {
    batchType: "metadata",
    metadata: {
      _loader: loader,
      _context: context
    },
    data: [],
    bytesUsed: 0
  };
  async function* makeMetadataBatchIterator(iterator) {
    yield metadataBatch;
    yield* iterator;
  }
  return makeMetadataBatchIterator(outputIterator);
}
async function parseToOutputIterator(loader, data, options, context) {
  const inputIterator = await getAsyncIterableFromData(data, options);
  const transformedIterator = await applyInputTransforms(inputIterator, (options === null || options === void 0 ? void 0 : options.transforms) || []);
  if (loader.parseInBatches) {
    return loader.parseInBatches(transformedIterator, options, context);
  }
  async function* parseChunkInBatches() {
    const arrayBuffer = await concatenateArrayBuffersAsync(transformedIterator);
    const parsedData = await parse(
      arrayBuffer,
      loader,
      {
        ...options,
        mimeType: loader.mimeTypes[0]
      },
      context
    );
    const batch = {
      mimeType: loader.mimeTypes[0],
      shape: Array.isArray(parsedData) ? "row-table" : "unknown",
      batchType: "data",
      data: parsedData,
      length: Array.isArray(parsedData) ? parsedData.length : 1
    };
    yield batch;
  }
  return parseChunkInBatches();
}
async function applyInputTransforms(inputIterator) {
  let transforms = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  let iteratorChain = inputIterator;
  for await (const transformBatches of transforms) {
    iteratorChain = transformBatches(iteratorChain);
  }
  return iteratorChain;
}

// node_modules/@loaders.gl/core/dist/esm/lib/api/load.js
async function load(url, loaders, options, context) {
  if (!Array.isArray(loaders) && !isLoaderObject(loaders)) {
    context = void 0;
    options = loaders;
    loaders = void 0;
  }
  const fetch2 = getFetchFunction(options);
  let data = url;
  if (typeof url === "string") {
    data = await fetch2(url);
  }
  if (isBlob(url)) {
    data = await fetch2(url);
  }
  return await parse(data, loaders, options);
}

// node_modules/@loaders.gl/core/dist/esm/lib/api/load-in-batches.js
function loadInBatches(files, loaders, options, context) {
  if (!Array.isArray(loaders) && !isLoaderObject(loaders)) {
    context = void 0;
    options = loaders;
    loaders = null;
  }
  const fetch2 = getFetchFunction(options || {});
  if (!Array.isArray(files)) {
    return loadOneFileInBatches(files, loaders, options, fetch2);
  }
  const promises = files.map((file) => loadOneFileInBatches(file, loaders, options, fetch2));
  return promises;
}
async function loadOneFileInBatches(file, loaders, options, fetch2) {
  if (typeof file === "string") {
    const url = file;
    const response = await fetch2(url);
    return await parseInBatches(response, loaders, options);
  }
  return await parseInBatches(file, loaders, options);
}

// node_modules/@loaders.gl/core/dist/esm/lib/api/encode.js
async function encode(data, writer, options) {
  const globalOptions = getGlobalLoaderOptions();
  options = {
    ...globalOptions,
    ...options
  };
  if (canEncodeWithWorker(writer, options)) {
    return await processOnWorker(writer, data, options);
  }
  if (writer.encode) {
    return await writer.encode(data, options);
  }
  if (writer.encodeSync) {
    return writer.encodeSync(data, options);
  }
  if (writer.encodeText) {
    return new TextEncoder().encode(await writer.encodeText(data, options));
  }
  if (writer.encodeInBatches) {
    const batches = encodeInBatches(data, writer, options);
    const chunks = [];
    for await (const batch of batches) {
      chunks.push(batch);
    }
    return concatenateArrayBuffers(...chunks);
  }
  if (!isBrowser && writer.encodeURLtoURL) {
    const tmpInputFilename = getTemporaryFilename("input");
    await writeFile(tmpInputFilename, data);
    const tmpOutputFilename = getTemporaryFilename("output");
    const outputFilename = await encodeURLtoURL(tmpInputFilename, tmpOutputFilename, writer, options);
    const response = await fetchFile(outputFilename);
    return response.arrayBuffer();
  }
  throw new Error("Writer could not encode data");
}
function encodeSync(data, writer, options) {
  if (writer.encodeSync) {
    return writer.encodeSync(data, options);
  }
  throw new Error("Writer could not synchronously encode data");
}
async function encodeText(data, writer, options) {
  if (writer.text && writer.encodeText) {
    return await writer.encodeText(data, options);
  }
  if (writer.text && (writer.encode || writer.encodeInBatches)) {
    const arrayBuffer = await encode(data, writer, options);
    return new TextDecoder().decode(arrayBuffer);
  }
  throw new Error("Writer could not encode data as text");
}
function encodeInBatches(data, writer, options) {
  if (writer.encodeInBatches) {
    const dataIterator = getIterator(data);
    return writer.encodeInBatches(dataIterator, options);
  }
  throw new Error("Writer could not encode data in batches");
}
async function encodeURLtoURL(inputUrl, outputUrl, writer, options) {
  inputUrl = resolvePath(inputUrl);
  outputUrl = resolvePath(outputUrl);
  if (isBrowser || !writer.encodeURLtoURL) {
    throw new Error();
  }
  const outputFilename = await writer.encodeURLtoURL(inputUrl, outputUrl, options);
  return outputFilename;
}
function getIterator(data) {
  const dataIterator = [{
    table: data,
    start: 0,
    end: data.length
  }];
  return dataIterator;
}
function getTemporaryFilename(filename) {
  return "/tmp/".concat(filename);
}

// node_modules/@loaders.gl/core/dist/esm/lib/api/save.js
async function save(data, url, writer, options) {
  const encodedData = await encode(data, writer, options);
  return await writeFile(url, encodedData);
}
function saveSync(data, url, writer, options) {
  const encodedData = encodeSync(data, writer, options);
  return writeFileSync(url, encodedData);
}

// node_modules/@loaders.gl/core/dist/esm/iterators/make-stream/make-dom-stream.js
function makeStream(source, options) {
  const iterator = source[Symbol.asyncIterator] ? source[Symbol.asyncIterator]() : source[Symbol.iterator]();
  return new ReadableStream(
    {
      type: "bytes",
      async pull(controller) {
        try {
          const {
            done,
            value
          } = await iterator.next();
          if (done) {
            controller.close();
          } else {
            controller.enqueue(new Uint8Array(value));
          }
        } catch (error) {
          controller.error(error);
        }
      },
      async cancel() {
        var _iterator$return;
        await (iterator === null || iterator === void 0 ? void 0 : (_iterator$return = iterator.return) === null || _iterator$return === void 0 ? void 0 : _iterator$return.call(iterator));
      }
    },
    {
      highWaterMark: 2 ** 24,
      ...options
    }
  );
}

// node_modules/@loaders.gl/core/dist/esm/null-loader.js
var VERSION2 = true ? "3.3.3" : "latest";
var NullWorkerLoader = {
  name: "Null loader",
  id: "null",
  module: "core",
  version: VERSION2,
  worker: true,
  mimeTypes: ["application/x.empty"],
  extensions: ["null"],
  tests: [() => false],
  options: {
    null: {}
  }
};
function parseSync2(arrayBuffer, options, context) {
  if (!options.null.echoParameters)
    return null;
  context = context && JSON.parse(JSON.stringify(context));
  return {
    arrayBuffer,
    options,
    context
  };
}
var NullLoader = {
  name: "Null loader",
  id: "null",
  module: "core",
  version: VERSION2,
  mimeTypes: ["application/x.empty"],
  extensions: ["null"],
  parse: async (arrayBuffer, options, context) => parseSync2(arrayBuffer, options, context),
  parseSync: parseSync2,
  parseInBatches: async function* generator(asyncIterator, options, context) {
    for await (const batch of asyncIterator) {
      yield parseSync2(batch, options, context);
    }
  },
  tests: [() => false],
  options: {
    null: {
      echoParameters: false
    }
  }
};

// node_modules/@loaders.gl/core/dist/esm/lib/progress/fetch-progress.js
async function fetchProgress(response, onProgress) {
  let onDone = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : () => {
  };
  let onError = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : () => {
  };
  response = await response;
  if (!response.ok) {
    return response;
  }
  const body = response.body;
  if (!body) {
    return response;
  }
  const contentLength = response.headers.get("content-length") || 0;
  const totalBytes = contentLength && parseInt(contentLength);
  if (!(contentLength > 0)) {
    return response;
  }
  if (typeof ReadableStream === "undefined" || !body.getReader) {
    return response;
  }
  const progressStream = new ReadableStream({
    async start(controller) {
      const reader = body.getReader();
      await read(controller, reader, 0, totalBytes, onProgress, onDone, onError);
    }
  });
  return new Response(progressStream);
}
async function read(controller, reader, loadedBytes, totalBytes, onProgress, onDone, onError) {
  try {
    const {
      done,
      value
    } = await reader.read();
    if (done) {
      onDone();
      controller.close();
      return;
    }
    loadedBytes += value.byteLength;
    const percent = Math.round(loadedBytes / totalBytes * 100);
    onProgress(percent, {
      loadedBytes,
      totalBytes
    });
    controller.enqueue(value);
    await read(controller, reader, loadedBytes, totalBytes, onProgress, onDone, onError);
  } catch (error) {
    controller.error(error);
    onError(error);
  }
}

// node_modules/@loaders.gl/core/dist/esm/lib/filesystems/browser-filesystem.js
var BrowserFileSystem = class {
  constructor(files, options) {
    _defineProperty(this, "_fetch", void 0);
    _defineProperty(this, "files", {});
    _defineProperty(this, "lowerCaseFiles", {});
    _defineProperty(this, "usedFiles", {});
    this._fetch = (options === null || options === void 0 ? void 0 : options.fetch) || fetch;
    for (let i = 0; i < files.length; ++i) {
      const file = files[i];
      this.files[file.name] = file;
      this.lowerCaseFiles[file.name.toLowerCase()] = file;
      this.usedFiles[file.name] = false;
    }
    this.fetch = this.fetch.bind(this);
  }
  async fetch(path, options) {
    if (path.includes("://")) {
      return this._fetch(path, options);
    }
    const file = this.files[path];
    if (!file) {
      return new Response(path, {
        status: 400,
        statusText: "NOT FOUND"
      });
    }
    const headers = new Headers(options === null || options === void 0 ? void 0 : options.headers);
    const range = headers.get("Range");
    const bytes = range && /bytes=($1)-($2)/.exec(range);
    if (bytes) {
      const start = parseInt(bytes[1]);
      const end = parseInt(bytes[2]);
      const data = await file.slice(start, end).arrayBuffer();
      const response2 = new Response(data);
      Object.defineProperty(response2, "url", {
        value: path
      });
      return response2;
    }
    const response = new Response(file);
    Object.defineProperty(response, "url", {
      value: path
    });
    return response;
  }
  async readdir(dirname) {
    const files = [];
    for (const path in this.files) {
      files.push(path);
    }
    return files;
  }
  async stat(path, options) {
    const file = this.files[path];
    if (!file) {
      throw new Error(path);
    }
    return {
      size: file.size
    };
  }
  async unlink(path) {
    delete this.files[path];
    delete this.lowerCaseFiles[path];
    this.usedFiles[path] = true;
  }
  async open(pathname, flags, mode) {
    return this.files[pathname];
  }
  async read(fd, buffer) {
    let offset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    let length = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : buffer.byteLength;
    let position = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;
    const file = fd;
    const startPosition = 0;
    const arrayBuffer = await file.slice(startPosition, startPosition + length).arrayBuffer();
    return {
      bytesRead: length,
      buffer: arrayBuffer
    };
  }
  async close(fd) {
  }
  _getFile(path, used) {
    const file = this.files[path] || this.lowerCaseFiles[path];
    if (file && used) {
      this.usedFiles[path] = true;
    }
    return file;
  }
};

export {
  isPureObject,
  isPromise,
  isIterable,
  isAsyncIterable,
  isIterator,
  isResponse,
  isReadableStream,
  isWritableStream,
  fetchFile,
  readArrayBuffer,
  readFileSync,
  writeFile,
  writeFileSync,
  isBrowser2 as isBrowser,
  getBrowser,
  Log,
  getGlobalLoaderOptions,
  setGlobalOptions,
  registerLoaders,
  _unregisterLoaders,
  selectLoader,
  selectLoaderSync,
  makeIterator,
  parse,
  parseSync,
  parseInBatches,
  load,
  loadInBatches,
  encode,
  encodeSync,
  encodeText,
  encodeInBatches,
  encodeURLtoURL,
  save,
  saveSync,
  makeStream,
  NullWorkerLoader,
  NullLoader,
  fetchProgress,
  BrowserFileSystem
};
//# sourceMappingURL=chunk-RNSZBP6P.js.map
