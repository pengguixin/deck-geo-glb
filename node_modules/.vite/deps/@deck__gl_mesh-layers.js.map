{
  "version": 3,
  "sources": ["../../@deck.gl/mesh-layers/src/utils/matrix.ts", "../../@deck.gl/mesh-layers/src/simple-mesh-layer/simple-mesh-layer-vertex.glsl.ts", "../../@deck.gl/mesh-layers/src/simple-mesh-layer/simple-mesh-layer-fragment.glsl.ts", "../../@deck.gl/mesh-layers/src/simple-mesh-layer/simple-mesh-layer.ts", "../../@luma.gl/experimental/src/scenegraph/scenegraph-node.js", "../../@luma.gl/experimental/src/scenegraph/group-node.js", "../../@luma.gl/experimental/src/gltf/gltf-animator.js", "../../@luma.gl/experimental/src/scenegraph/model-node.js", "../../@luma.gl/experimental/src/gltf/gltf-material-parser.js", "../../@luma.gl/experimental/src/gltf/create-gltf-model.js", "../../@luma.gl/experimental/src/gltf/gltf-instantiator.js", "../../@luma.gl/experimental/src/gltf/create-gltf-objects.js", "../../@luma.gl/experimental/src/gpgpu/point-in-polygon/polygon.js", "../../@deck.gl/mesh-layers/src/scenegraph-layer/gltf-utils.ts", "../../@deck.gl/mesh-layers/src/scenegraph-layer/scenegraph-layer-vertex.glsl.ts", "../../@deck.gl/mesh-layers/src/scenegraph-layer/scenegraph-layer-fragment.glsl.ts", "../../@deck.gl/mesh-layers/src/scenegraph-layer/scenegraph-layer.ts"],
  "sourcesContent": ["import {COORDINATE_SYSTEM, createIterable} from '@deck.gl/core';\n\n/* eslint-disable max-statements, complexity, camelcase */\nconst RADIAN_PER_DEGREE = Math.PI / 180;\nconst modelMatrix = new Float32Array(16);\nconst valueArray = new Float32Array(12);\n\nfunction calculateTransformMatrix(targetMatrix, orientation, scale) {\n  const pitch = orientation[0] * RADIAN_PER_DEGREE;\n  const yaw = orientation[1] * RADIAN_PER_DEGREE;\n  const roll = orientation[2] * RADIAN_PER_DEGREE;\n\n  const sr = Math.sin(roll);\n  const sp = Math.sin(pitch);\n  const sw = Math.sin(yaw);\n\n  const cr = Math.cos(roll);\n  const cp = Math.cos(pitch);\n  const cw = Math.cos(yaw);\n\n  const scx = scale[0];\n  const scy = scale[1];\n  const scz = scale[2];\n\n  targetMatrix[0] = scx * cw * cp; // 0,0\n  targetMatrix[1] = scx * sw * cp; // 1,0\n  targetMatrix[2] = scx * -sp; // 2,0\n  targetMatrix[3] = scy * (-sw * cr + cw * sp * sr); // 0,1\n  targetMatrix[4] = scy * (cw * cr + sw * sp * sr); // 1,1\n  targetMatrix[5] = scy * cp * sr; // 2,1\n  targetMatrix[6] = scz * (sw * sr + cw * sp * cr); // 0,2\n  targetMatrix[7] = scz * (-cw * sr + sw * sp * cr); // 1,2\n  targetMatrix[8] = scz * cp * cr; // 2,2\n}\n\nfunction getExtendedMat3FromMat4(mat4) {\n  mat4[0] = mat4[0];\n  mat4[1] = mat4[1];\n  mat4[2] = mat4[2];\n  mat4[3] = mat4[4];\n  mat4[4] = mat4[5];\n  mat4[5] = mat4[6];\n  mat4[6] = mat4[8];\n  mat4[7] = mat4[9];\n  mat4[8] = mat4[10];\n  mat4[9] = mat4[12];\n  mat4[10] = mat4[13];\n  mat4[11] = mat4[14];\n\n  return mat4.subarray(0, 12);\n}\n\nexport const MATRIX_ATTRIBUTES = {\n  size: 12,\n  accessor: ['getOrientation', 'getScale', 'getTranslation', 'getTransformMatrix'],\n  shaderAttributes: {\n    instanceModelMatrix__LOCATION_0: {\n      size: 3,\n      elementOffset: 0\n    },\n    instanceModelMatrix__LOCATION_1: {\n      size: 3,\n      elementOffset: 3\n    },\n    instanceModelMatrix__LOCATION_2: {\n      size: 3,\n      elementOffset: 6\n    },\n    instanceTranslation: {\n      size: 3,\n      elementOffset: 9\n    }\n  } as const,\n\n  update(attribute, {startRow, endRow}) {\n    // @ts-expect-error: \"this\" will be bound to a layer when this function is called\n    const {data, getOrientation, getScale, getTranslation, getTransformMatrix} = this.props;\n\n    const arrayMatrix = Array.isArray(getTransformMatrix);\n    const constantMatrix = arrayMatrix && getTransformMatrix.length === 16;\n    const constantScale = Array.isArray(getScale);\n    const constantOrientation = Array.isArray(getOrientation);\n    const constantTranslation = Array.isArray(getTranslation);\n\n    const hasMatrix = constantMatrix || (!arrayMatrix && Boolean(getTransformMatrix(data[0])));\n\n    if (hasMatrix) {\n      attribute.constant = constantMatrix;\n    } else {\n      attribute.constant = constantOrientation && constantScale && constantTranslation;\n    }\n\n    const instanceModelMatrixData = attribute.value;\n\n    if (attribute.constant) {\n      let matrix;\n\n      if (hasMatrix) {\n        modelMatrix.set(getTransformMatrix);\n        matrix = getExtendedMat3FromMat4(modelMatrix);\n      } else {\n        matrix = valueArray;\n\n        const orientation = getOrientation;\n        const scale = getScale;\n\n        calculateTransformMatrix(matrix, orientation, scale);\n        matrix.set(getTranslation, 9);\n      }\n\n      attribute.value = new Float32Array(matrix);\n    } else {\n      let i = startRow * attribute.size;\n      const {iterable, objectInfo} = createIterable(data, startRow, endRow);\n      for (const object of iterable) {\n        objectInfo.index++;\n        let matrix;\n\n        if (hasMatrix) {\n          modelMatrix.set(\n            constantMatrix ? getTransformMatrix : getTransformMatrix(object, objectInfo)\n          );\n          matrix = getExtendedMat3FromMat4(modelMatrix);\n        } else {\n          matrix = valueArray;\n\n          const orientation = constantOrientation\n            ? getOrientation\n            : getOrientation(object, objectInfo);\n          const scale = constantScale ? getScale : getScale(object, objectInfo);\n\n          calculateTransformMatrix(matrix, orientation, scale);\n          matrix.set(constantTranslation ? getTranslation : getTranslation(object, objectInfo), 9);\n        }\n\n        instanceModelMatrixData[i++] = matrix[0];\n        instanceModelMatrixData[i++] = matrix[1];\n        instanceModelMatrixData[i++] = matrix[2];\n        instanceModelMatrixData[i++] = matrix[3];\n        instanceModelMatrixData[i++] = matrix[4];\n        instanceModelMatrixData[i++] = matrix[5];\n        instanceModelMatrixData[i++] = matrix[6];\n        instanceModelMatrixData[i++] = matrix[7];\n        instanceModelMatrixData[i++] = matrix[8];\n        instanceModelMatrixData[i++] = matrix[9];\n        instanceModelMatrixData[i++] = matrix[10];\n        instanceModelMatrixData[i++] = matrix[11];\n      }\n    }\n  }\n};\n\n// only apply composeModelMatrix when in cartesian or meter_offsets coordinate system\n// with `composeModelMatrix` enabled, the rotation part of the layer's modelMatrix will be composed to instance's transformations\n// since rotating latitude and longitude can not provide meaningful results, hence `composeModelMatrix` is disabled\n// when in LNGLAT and LNGLAT_OFFSET coordinates.\nexport function shouldComposeModelMatrix(viewport, coordinateSystem) {\n  return (\n    coordinateSystem === COORDINATE_SYSTEM.CARTESIAN ||\n    coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS ||\n    (coordinateSystem === COORDINATE_SYSTEM.DEFAULT && !viewport.isGeospatial)\n  );\n}\n", "export default `#version 300 es\n#define SHADER_NAME simple-mesh-layer-vs\n\n// Scale the model\nuniform float sizeScale;\nuniform bool composeModelMatrix;\n\n// Primitive attributes\nin vec3 positions;\nin vec3 normals;\nin vec3 colors;\nin vec2 texCoords;\n\n// Instance attributes\nin vec3 instancePositions;\nin vec3 instancePositions64Low;\nin vec4 instanceColors;\nin vec3 instancePickingColors;\nin mat3 instanceModelMatrix;\nin vec3 instanceTranslation;\n\n// Outputs to fragment shader\nout vec2 vTexCoord;\nout vec3 cameraPosition;\nout vec3 normals_commonspace;\nout vec4 position_commonspace;\nout vec4 vColor;\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  geometry.uv = texCoords;\n  geometry.pickingColor = instancePickingColors;\n\n  vTexCoord = texCoords;\n  cameraPosition = project_uCameraPosition;\n  vColor = vec4(colors * instanceColors.rgb, instanceColors.a);\n\n  vec3 pos = (instanceModelMatrix * positions) * sizeScale + instanceTranslation;\n\n  if (composeModelMatrix) {\n    DECKGL_FILTER_SIZE(pos, geometry);\n    // using instancePositions as world coordinates\n    // when using globe mode, this branch does not re-orient the model to align with the surface of the earth\n    // call project_normal before setting position to avoid rotation\n    normals_commonspace = project_normal(instanceModelMatrix * normals);\n    geometry.worldPosition += pos;\n    gl_Position = project_position_to_clipspace(pos + instancePositions, instancePositions64Low, vec3(0.0), position_commonspace);\n    geometry.position = position_commonspace;\n  }\n  else {\n    pos = project_size(pos);\n    DECKGL_FILTER_SIZE(pos, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, pos, position_commonspace);\n    geometry.position = position_commonspace;\n    normals_commonspace = project_normal(instanceModelMatrix * normals);\n  }\n\n  geometry.normal = normals_commonspace;\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n`;\n", "export default `#version 300 es\n#define SHADER_NAME simple-mesh-layer-fs\n\nprecision highp float;\n\nuniform bool hasTexture;\nuniform sampler2D sampler;\nuniform bool flatShading;\nuniform float opacity;\n\nin vec2 vTexCoord;\nin vec3 cameraPosition;\nin vec3 normals_commonspace;\nin vec4 position_commonspace;\nin vec4 vColor;\n\nout vec4 fragColor;\n\nvoid main(void) {\n  geometry.uv = vTexCoord;\n\n  vec3 normal;\n  if (flatShading) {\n\n// NOTE(Tarek): This is necessary because\n// headless.gl reports the extension as\n// available but does not support it in\n// the shader.\n#ifdef DERIVATIVES_AVAILABLE\n    normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));\n#else\n    normal = vec3(0.0, 0.0, 1.0);\n#endif\n  } else {\n    normal = normals_commonspace;\n  }\n\n  vec4 color = hasTexture ? texture(sampler, vTexCoord) : vColor;\n  DECKGL_FILTER_COLOR(color, geometry);\n\n  vec3 lightColor = lighting_getLightColor(color.rgb, cameraPosition, position_commonspace.xyz, normal);\n  fragColor = vec4(lightColor, color.a * opacity);\n}\n`;\n", "// Note: This file will either be moved back to deck.gl or reformatted to web-monorepo standards\n// Disabling lint temporarily to facilitate copying code in and out of this repo\n/* eslint-disable */\n\n// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {\n  Layer,\n  project32,\n  phongLighting,\n  picking,\n  DefaultProps,\n  log,\n  LayerContext,\n  Material\n} from '@deck.gl/core';\nimport GL from '@luma.gl/constants';\nimport {Model, Geometry, Texture2D, isWebGL2} from '@luma.gl/core';\nimport {hasFeature, FEATURES} from '@luma.gl/webgl';\n\nimport {MATRIX_ATTRIBUTES, shouldComposeModelMatrix} from '../utils/matrix';\n\nimport vs from './simple-mesh-layer-vertex.glsl';\nimport fs from './simple-mesh-layer-fragment.glsl';\n\nimport type {\n  LayerProps,\n  LayerDataSource,\n  UpdateParameters,\n  Accessor,\n  Position,\n  Color,\n  Texture\n} from '@deck.gl/core';\nimport type {MeshAttribute, MeshAttributes} from '@loaders.gl/schema';\nimport type {Geometry as GeometryType} from '@luma.gl/engine';\nimport {GLTFMaterialParser} from '@luma.gl/experimental';\nimport {getMeshBoundingBox} from '@loaders.gl/schema';\n\nfunction validateGeometryAttributes(attributes: Record<string, any>, useMeshColors: boolean): void {\n  const hasColorAttribute = attributes.COLOR_0 || attributes.colors;\n  const useColorAttribute = hasColorAttribute && useMeshColors;\n  if (!useColorAttribute) {\n    attributes.colors = {constant: true, value: new Float32Array([1, 1, 1])};\n  }\n  log.assert(\n    attributes.positions || attributes.POSITION,\n    'no \"postions\" or \"POSITION\" attribute in mesh'\n  );\n}\n\n/*\n * Convert mesh data into geometry\n * @returns {Geometry} geometry\n */\nfunction getGeometry(data: Mesh, useMeshColors: boolean): Geometry {\n  if ((data as any).attributes) {\n    validateGeometryAttributes((data as any).attributes, useMeshColors);\n    if (data instanceof Geometry) {\n      return data;\n    } else {\n      return new Geometry(data);\n    }\n  } else if ((data as MeshAttributes).positions || (data as MeshAttributes).POSITION) {\n    validateGeometryAttributes(data, useMeshColors);\n    return new Geometry({\n      attributes: data\n    });\n  }\n  throw Error('Invalid mesh');\n}\n\nconst DEFAULT_COLOR: [number, number, number, number] = [0, 0, 0, 255];\n\ntype Mesh =\n  | GeometryType\n  | {\n      attributes: MeshAttributes;\n      indices?: MeshAttribute;\n    }\n  | MeshAttributes;\n\ntype _SimpleMeshLayerProps<DataT> = {\n  data: LayerDataSource<DataT>;\n  mesh: string | Mesh | Promise<Mesh> | null;\n  texture?: string | Texture | Promise<Texture>;\n  /** Customize the [texture parameters](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texParameter). */\n  textureParameters?: Record<number, number> | null;\n\n  /** Anchor position accessor. */\n  getPosition?: Accessor<DataT, Position>;\n  /** Color value or accessor.\n   * If `mesh` does not contain vertex colors, use this color to render each object.\n   * If `mesh` contains vertex colors, then the two colors are mixed together.\n   * Use `[255, 255, 255]` to use the original mesh colors.\n   * If `texture` is assigned, then both colors will be ignored.\n   * @default [0, 0, 0, 255]\n   */\n  getColor?: Accessor<DataT, Color>;\n  /**\n   * Orientation in [pitch, yaw, roll] in degrees.\n   * @see https://en.wikipedia.org/wiki/Euler_angles\n   * @default [0, 0, 0]\n   */\n  getOrientation?: Accessor<DataT, [number, number, number]>;\n  /**\n   * Scaling factor of the model along each axis.\n   * @default [1, 1, 1]\n   */\n  getScale?: Accessor<DataT, [number, number, number]>;\n  /**\n   * Translation from the anchor point, [x, y, z] in meters.\n   * @default [0, 0, 0]\n   */\n  getTranslation?: Accessor<DataT, [number, number, number]>;\n  /**\n   * TransformMatrix. If specified, `getOrientation`, `getScale` and `getTranslation` are ignored.\n   */\n  getTransformMatrix?: Accessor<DataT, number[]>;\n  /**\n   * Multiplier to scale each geometry by.\n   * @default 1\n   */\n  sizeScale?: number;\n  /**\n   * @deprecated Whether to color pixels using vertex colors supplied in the mesh (the `COLOR_0` or `colors` attribute).\n   * If set to `false` vertex colors will be ignored.\n   * This prop will be removed and set to always true in the next major release.\n   * @default false\n   */\n  _useMeshColors?: boolean;\n\n  /**\n   * (Experimental) If rendering only one instance of the mesh, set this to false to treat mesh positions\n   * as deltas of the world coordinates of the anchor.\n   * E.g. in LNGLAT coordinates, mesh positions are interpreted as meter offsets by default.\n   * setting _instanced to false interpreted mesh positions as lnglat deltas.\n   * @default true\n   */\n  _instanced?: boolean; // TODO - formalize API\n  /**\n   * Whether to render the mesh in wireframe mode.\n   * @default false\n   */\n  wireframe?: boolean;\n  /**\n   * Material props for lighting effect.\n   *\n   * @default true\n   * @see https://deck.gl/docs/developer-guide/using-lighting#constructing-a-material-instance\n   */\n  material?: Material;\n};\n\nexport type SimpleMeshLayerProps<DataT = any> = _SimpleMeshLayerProps<DataT> & LayerProps;\n\nconst defaultProps: DefaultProps<SimpleMeshLayerProps> = {\n  mesh: {type: 'object', value: null, async: true},\n  texture: {type: 'image', value: null, async: true},\n  sizeScale: {type: 'number', value: 1, min: 0},\n  // Whether the color attribute in a mesh will be used\n  // This prop will be removed and set to true in next major release\n  _useMeshColors: {type: 'boolean', value: false},\n\n  // _instanced is a hack to use world position instead of meter offsets in mesh\n  // TODO - formalize API\n  _instanced: true,\n  // NOTE(Tarek): Quick and dirty wireframe. Just draws\n  // the same mesh with LINE_STRIPS. Won't follow edges\n  // of the original mesh.\n  wireframe: false,\n  // Optional material for 'lighting' shader module\n  material: true,\n  getPosition: {type: 'accessor', value: x => x.position},\n  getColor: {type: 'accessor', value: DEFAULT_COLOR},\n\n  // yaw, pitch and roll are in degrees\n  // https://en.wikipedia.org/wiki/Euler_angles\n  // [pitch, yaw, roll]\n  getOrientation: {type: 'accessor', value: [0, 0, 0]},\n  getScale: {type: 'accessor', value: [1, 1, 1]},\n  getTranslation: {type: 'accessor', value: [0, 0, 0]},\n  // 4x4 matrix\n  getTransformMatrix: {type: 'accessor', value: []},\n\n  textureParameters: {type: 'object', ignore: true}\n};\n\n/** Render a number of instances of an arbitrary 3D geometry. */\nexport default class SimpleMeshLayer<DataT = any, ExtraPropsT extends {} = {}> extends Layer<\n  ExtraPropsT & Required<_SimpleMeshLayerProps<DataT>>\n> {\n  static defaultProps = defaultProps;\n  static layerName = 'SimpleMeshLayer';\n\n  state!: {\n    materialParser?: GLTFMaterialParser;\n    model?: Model;\n    emptyTexture: Texture2D;\n    hasNormals?: boolean;\n    positionBounds?: [number[], number[]] | null;\n  };\n\n  getShaders() {\n    const transpileToGLSL100 = !isWebGL2(this.context.gl);\n\n    const defines: any = {};\n\n    if (hasFeature(this.context.gl, FEATURES.GLSL_DERIVATIVES)) {\n      defines.DERIVATIVES_AVAILABLE = 1;\n    }\n\n    return super.getShaders({\n      vs,\n      fs,\n      modules: [project32, phongLighting, picking],\n      transpileToGLSL100,\n      defines\n    });\n  }\n\n  getBounds(): [number[], number[]] | null {\n    if (this.props._instanced) {\n      return super.getBounds();\n    }\n    let result = this.state.positionBounds;\n    if (result) {\n      return result;\n    }\n    const {mesh} = this.props;\n    if (!mesh) {\n      return null;\n    }\n    // @ts-ignore Detect if mesh is generated by loaders.gl\n    result = mesh.header?.boundingBox;\n\n    if (!result) {\n      // Otherwise, calculate bounding box from positions\n      const {attributes} = getGeometry(mesh as Mesh, this.props._useMeshColors);\n      attributes.POSITION = attributes.POSITION || attributes.positions;\n      result = getMeshBoundingBox(attributes);\n    }\n\n    this.state.positionBounds = result;\n    return result;\n  }\n\n  initializeState() {\n    const attributeManager = this.getAttributeManager();\n    // attributeManager is always defined in a primitive layer\n    attributeManager!.addInstanced({\n      instancePositions: {\n        transition: true,\n        type: GL.DOUBLE,\n        fp64: this.use64bitPositions(),\n        size: 3,\n        accessor: 'getPosition'\n      },\n      instanceColors: {\n        type: GL.UNSIGNED_BYTE,\n        transition: true,\n        size: this.props.colorFormat.length,\n        normalized: true,\n        accessor: 'getColor',\n        defaultValue: [0, 0, 0, 255]\n      },\n      instanceModelMatrix: MATRIX_ATTRIBUTES\n    });\n\n    this.setState({\n      // Avoid luma.gl's missing uniform warning\n      // TODO - add feature to luma.gl to specify ignored uniforms?\n      emptyTexture: new Texture2D(this.context.gl, {\n        data: new Uint8Array(4),\n        width: 1,\n        height: 1\n      })\n    });\n  }\n\n  updateState(params: UpdateParameters<this>) {\n    super.updateState(params);\n\n    const {props, oldProps, changeFlags} = params;\n    if (props.mesh !== oldProps.mesh || changeFlags.extensionsChanged) {\n      this.state.positionBounds = null;\n      this.state.model?.delete();\n      if (props.mesh) {\n        this.state.model = this.getModel(props.mesh as Mesh);\n\n        const attributes = (props.mesh as any).attributes || props.mesh;\n        this.setState({\n          hasNormals: Boolean(attributes.NORMAL || attributes.normals)\n        });\n      }\n      // attributeManager is always defined in a primitive layer\n      this.getAttributeManager()!.invalidateAll();\n    }\n\n    if (props.texture !== oldProps.texture) {\n      this.setTexture(props.texture);\n    }\n\n    if (this.state.model) {\n      this.state.model.setDrawMode(this.props.wireframe ? GL.LINE_STRIP : GL.TRIANGLES);\n    }\n  }\n\n  finalizeState(context: LayerContext) {\n    super.finalizeState(context);\n\n    this.state.emptyTexture.delete();\n  }\n\n  draw({uniforms}) {\n    if (!this.state.model) {\n      return;\n    }\n\n    const {viewport} = this.context;\n    const {sizeScale, coordinateSystem, _instanced} = this.props;\n\n    this.state.model\n      .setUniforms(uniforms)\n      .setUniforms({\n        sizeScale,\n        composeModelMatrix: !_instanced || shouldComposeModelMatrix(viewport, coordinateSystem),\n        flatShading: !this.state.hasNormals\n      })\n      .draw();\n  }\n\n  protected getModel(mesh: Mesh): Model {\n    const model = new Model(this.context.gl, {\n      ...this.getShaders(),\n      id: this.props.id,\n      geometry: getGeometry(mesh, this.props._useMeshColors),\n      isInstanced: true\n    });\n\n    const {texture} = this.props;\n    const {emptyTexture} = this.state;\n    model.setUniforms({\n      sampler: texture || emptyTexture,\n      hasTexture: Boolean(texture)\n    });\n\n    return model;\n  }\n\n  private setTexture(texture: Texture2D): void {\n    const {emptyTexture, model} = this.state;\n\n    // props.mesh may not be ready at this time.\n    // The sampler will be set when `getModel` is called\n    if (model) {\n      model.setUniforms({\n        sampler: texture || emptyTexture,\n        hasTexture: Boolean(texture)\n      });\n    }\n  }\n}\n", "import {Vector3, Matrix4} from '@math.gl/core';\nimport {assert, uid} from '@luma.gl/webgl';\n\nexport default class ScenegraphNode {\n  constructor(props = {}) {\n    const {id} = props;\n\n    this.id = id || uid(this.constructor.name);\n\n    this.display = true; // whether to display the object at all\n    this.position = new Vector3();\n    this.rotation = new Vector3();\n    this.scale = new Vector3(1, 1, 1);\n    this.matrix = new Matrix4();\n    this.userData = {};\n\n    this.props = {};\n    this._setScenegraphNodeProps(props);\n  }\n\n  delete() {}\n\n  setProps(props) {\n    this._setScenegraphNodeProps(props);\n    return this;\n  }\n\n  toString() {\n    return `{type: ScenegraphNode, id: ${this.id})}`;\n  }\n\n  getBounds() {\n    return null;\n  }\n\n  setPosition(position) {\n    assert(position.length === 3, 'setPosition requires vector argument');\n    this.position = position;\n    return this;\n  }\n\n  setRotation(rotation) {\n    assert(rotation.length === 3, 'setRotation requires vector argument');\n    this.rotation = rotation;\n    return this;\n  }\n\n  setScale(scale) {\n    assert(scale.length === 3, 'setScale requires vector argument');\n    this.scale = scale;\n    return this;\n  }\n\n  setMatrix(matrix, copyMatrix = true) {\n    if (copyMatrix) {\n      this.matrix.copy(matrix);\n    } else {\n      this.matrix = matrix;\n    }\n  }\n\n  setMatrixComponents({position, rotation, scale, update = true}) {\n    if (position) {\n      this.setPosition(position);\n    }\n    if (rotation) {\n      this.setRotation(rotation);\n    }\n    if (scale) {\n      this.setScale(scale);\n    }\n    if (update) {\n      this.updateMatrix();\n    }\n    return this;\n  }\n\n  updateMatrix() {\n    const pos = this.position;\n    const rot = this.rotation;\n    const scale = this.scale;\n\n    this.matrix.identity();\n    this.matrix.translate(pos);\n    this.matrix.rotateXYZ(rot);\n    this.matrix.scale(scale);\n    return this;\n  }\n\n  update(options = {}) {\n    const {position, rotation, scale} = options;\n    if (position) {\n      this.setPosition(position);\n    }\n    if (rotation) {\n      this.setRotation(rotation);\n    }\n    if (scale) {\n      this.setScale(scale);\n    }\n    this.updateMatrix();\n    return this;\n  }\n\n  getCoordinateUniforms(viewMatrix, modelMatrix) {\n    // TODO - solve multiple class problem\n    // assert(viewMatrix instanceof Matrix4);\n    assert(viewMatrix);\n    modelMatrix = modelMatrix || this.matrix;\n    const worldMatrix = new Matrix4(viewMatrix).multiplyRight(modelMatrix);\n    const worldInverse = worldMatrix.invert();\n    const worldInverseTranspose = worldInverse.transpose();\n\n    return {\n      viewMatrix,\n      modelMatrix,\n      objectMatrix: modelMatrix,\n      worldMatrix,\n      worldInverseMatrix: worldInverse,\n      worldInverseTransposeMatrix: worldInverseTranspose\n    };\n  }\n\n  // TODO - copied code, not yet vetted\n  /*\n  transform() {\n    if (!this.parent) {\n      this.endPosition.set(this.position);\n      this.endRotation.set(this.rotation);\n      this.endScale.set(this.scale);\n    } else {\n      const parent = this.parent;\n      this.endPosition.set(this.position.add(parent.endPosition));\n      this.endRotation.set(this.rotation.add(parent.endRotation));\n      this.endScale.set(this.scale.add(parent.endScale));\n    }\n\n    const ch = this.children;\n    for (let i = 0; i < ch.length; ++i) {\n      ch[i].transform();\n    }\n\n    return this;\n  }\n  */\n\n  _setScenegraphNodeProps(props) {\n    if ('display' in props) {\n      this.display = props.display;\n    }\n\n    if ('position' in props) {\n      this.setPosition(props.position);\n    }\n    if ('rotation' in props) {\n      this.setRotation(props.rotation);\n    }\n    if ('scale' in props) {\n      this.setScale(props.scale);\n    }\n\n    // Matrix overwrites other props\n    if ('matrix' in props) {\n      this.setMatrix(props.matrix);\n    }\n\n    Object.assign(this.props, props);\n  }\n}\n", "import {Matrix4, Vector3} from '@math.gl/core';\nimport {log} from '@luma.gl/webgl';\nimport ScenegraphNode from './scenegraph-node';\n\nexport default class GroupNode extends ScenegraphNode {\n  constructor(props = {}) {\n    props = Array.isArray(props) ? {children: props} : props;\n    const {children = []} = props;\n    log.assert(\n      children.every(child => child instanceof ScenegraphNode),\n      'every child must an instance of ScenegraphNode'\n    );\n    super(props);\n    this.children = children;\n  }\n\n  // Unpacks arrays and nested arrays of children\n  add(...children) {\n    for (const child of children) {\n      if (Array.isArray(child)) {\n        this.add(...child);\n      } else {\n        this.children.push(child);\n      }\n    }\n    return this;\n  }\n\n  remove(child) {\n    const children = this.children;\n    const indexOf = children.indexOf(child);\n    if (indexOf > -1) {\n      children.splice(indexOf, 1);\n    }\n    return this;\n  }\n\n  removeAll() {\n    this.children = [];\n    return this;\n  }\n\n  delete() {\n    this.children.forEach(child => child.delete());\n    this.removeAll();\n    super.delete();\n  }\n\n  getBounds() {\n    /** @type [number[], number[]] */\n    const result = [[Infinity, Infinity, Infinity], [-Infinity, -Infinity, -Infinity]];\n\n    this.traverse((node, {worldMatrix}) => {\n      const bounds = node.getBounds();\n      if (!bounds) {\n        return;\n      }\n      const [min, max] = bounds;\n      const center = new Vector3(min).add(max).divide([2, 2, 2]);\n      worldMatrix.transformAsPoint(center, center);\n      const halfSize = new Vector3(max).subtract(min).divide([2, 2, 2]);\n      worldMatrix.transformAsVector(halfSize, halfSize);\n\n      for (let v = 0; v < 8; v++) {\n        // Test all 8 corners of the box\n        const position = new Vector3(v & 0b001 ? -1 : 1, v & 0b010 ? -1 : 1, v & 0b100 ? -1 : 1)\n          .multiply(halfSize)\n          .add(center);\n\n        for (let i = 0; i < 3; i++) {\n          result[0][i] = Math.min(result[0][i], position[i]);\n          result[1][i] = Math.max(result[1][i], position[i]);\n        }\n      }\n    });\n    if (!Number.isFinite(result[0][0])) {\n      return null;\n    }\n    return result;\n  }\n\n  traverse(visitor, {worldMatrix = new Matrix4()} = {}) {\n    const modelMatrix = new Matrix4(worldMatrix).multiplyRight(this.matrix);\n\n    for (const child of this.children) {\n      if (child instanceof GroupNode) {\n        child.traverse(visitor, {worldMatrix: modelMatrix});\n      } else {\n        visitor(child, {worldMatrix: modelMatrix});\n      }\n    }\n  }\n}\n", "import {assert, log} from '@luma.gl/webgl';\nimport {Matrix4, Quaternion} from '@math.gl/core';\n\n// TODO: import from loaders.gl?\nexport const ATTRIBUTE_TYPE_TO_COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\n\nexport const ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array\n};\n//\n\nfunction accessorToJsArray(accessor) {\n  if (!accessor._animation) {\n    const ArrayType = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY[accessor.componentType];\n    const components = ATTRIBUTE_TYPE_TO_COMPONENTS[accessor.type];\n    const length = components * accessor.count;\n    const {buffer, byteOffset} = accessor.bufferView.data;\n\n    const array = new ArrayType(buffer, byteOffset + (accessor.byteOffset || 0), length);\n\n    if (components === 1) {\n      accessor._animation = Array.from(array);\n    } else {\n      // Slice array\n      const slicedArray = [];\n      for (let i = 0; i < array.length; i += components) {\n        slicedArray.push(Array.from(array.slice(i, i + components)));\n      }\n      accessor._animation = slicedArray;\n    }\n  }\n\n  return accessor._animation;\n}\n\n// TODO: share with GLTFInstantiator\nconst helperMatrix = new Matrix4();\nfunction applyTranslationRotationScale(gltfNode, node) {\n  node.matrix.identity();\n\n  if (gltfNode.translation) {\n    node.matrix.translate(gltfNode.translation);\n  }\n\n  if (gltfNode.rotation) {\n    const rotationMatrix = helperMatrix.fromQuaternion(gltfNode.rotation);\n    node.matrix.multiplyRight(rotationMatrix);\n  }\n\n  if (gltfNode.scale) {\n    node.matrix.scale(gltfNode.scale);\n  }\n}\n\nconst quaternion = new Quaternion();\nfunction linearInterpolate(target, path, start, stop, ratio) {\n  if (path === 'rotation') {\n    // SLERP when path is rotation\n    quaternion.slerp({start, target: stop, ratio});\n    for (let i = 0; i < quaternion.length; i++) {\n      target[path][i] = quaternion[i];\n    }\n  } else {\n    // regular interpolation\n    for (let i = 0; i < start.length; i++) {\n      target[path][i] = ratio * stop[i] + (1 - ratio) * start[i];\n    }\n  }\n}\n\nfunction cubicsplineInterpolate(target, path, {p0, outTangent0, inTangent1, p1, tDiff, ratio: t}) {\n  // TODO: Quaternion might need normalization\n  for (let i = 0; i < target[path].length; i++) {\n    const m0 = outTangent0[i] * tDiff;\n    const m1 = inTangent1[i] * tDiff;\n    target[path][i] =\n      (2 * Math.pow(t, 3) - 3 * Math.pow(t, 2) + 1) * p0[i] +\n      (Math.pow(t, 3) - 2 * Math.pow(t, 2) + t) * m0 +\n      (-2 * Math.pow(t, 3) + 3 * Math.pow(t, 2)) * p1[i] +\n      (Math.pow(t, 3) - Math.pow(t, 2)) * m1;\n  }\n}\n\nfunction stepInterpolate(target, path, value) {\n  for (let i = 0; i < value.length; i++) {\n    target[path][i] = value[i];\n  }\n}\n\nfunction interpolate(time, {input, interpolation, output}, target, path) {\n  const maxTime = input[input.length - 1];\n  const animationTime = time % maxTime;\n\n  const nextIndex = input.findIndex(t => t >= animationTime);\n  const previousIndex = Math.max(0, nextIndex - 1);\n\n  if (!Array.isArray(target[path])) {\n    switch (path) {\n      case 'translation':\n        target[path] = [0, 0, 0];\n        break;\n\n      case 'rotation':\n        target[path] = [0, 0, 0, 1];\n        break;\n\n      case 'scale':\n        target[path] = [1, 1, 1];\n        break;\n\n      default:\n        log.warn(`Bad animation path ${path}`)();\n    }\n  }\n\n  assert(target[path].length === output[previousIndex].length);\n  const previousTime = input[previousIndex];\n  const nextTime = input[nextIndex];\n\n  switch (interpolation) {\n    case 'STEP':\n      stepInterpolate(target, path, output[previousIndex]);\n      break;\n\n    case 'LINEAR':\n      if (nextTime > previousTime) {\n        const ratio = (animationTime - previousTime) / (nextTime - previousTime);\n        linearInterpolate(target, path, output[previousIndex], output[nextIndex], ratio);\n      }\n      break;\n\n    case 'CUBICSPLINE':\n      if (nextTime > previousTime) {\n        const ratio = (animationTime - previousTime) / (nextTime - previousTime);\n        const tDiff = nextTime - previousTime;\n\n        const p0 = output[3 * previousIndex + 1];\n        const outTangent0 = output[3 * previousIndex + 2];\n        const inTangent1 = output[3 * nextIndex + 0];\n        const p1 = output[3 * nextIndex + 1];\n\n        cubicsplineInterpolate(target, path, {p0, outTangent0, inTangent1, p1, tDiff, ratio});\n      }\n      break;\n\n    default:\n      log.warn(`Interpolation ${interpolation} not supported`)();\n      break;\n  }\n}\n\nclass GLTFAnimation {\n  constructor(props) {\n    this.startTime = 0;\n    this.playing = true;\n    this.speed = 1;\n    this.channels = [];\n\n    Object.assign(this, props);\n  }\n\n  animate(timeMs) {\n    if (!this.playing) {\n      return;\n    }\n\n    const absTime = timeMs / 1000;\n    const time = (absTime - this.startTime) * this.speed;\n\n    this.channels.forEach(({sampler, target, path}) => {\n      interpolate(time, sampler, target, path);\n      applyTranslationRotationScale(target, target._node);\n    });\n  }\n}\n\nexport default class GLTFAnimator {\n  constructor(gltf) {\n    this.animations = gltf.animations.map((animation, index) => {\n      const name = animation.name || `Animation-${index}`;\n      const samplers = animation.samplers.map(({input, interpolation = 'LINEAR', output}) => ({\n        input: accessorToJsArray(gltf.accessors[input]),\n        interpolation,\n        output: accessorToJsArray(gltf.accessors[output])\n      }));\n      const channels = animation.channels.map(({sampler, target}) => ({\n        sampler: samplers[sampler],\n        target: gltf.nodes[target.node],\n        path: target.path\n      }));\n      return new GLTFAnimation({name, channels});\n    });\n  }\n\n  // TODO(Tarek): This should be removed? (deck.gl is using this)\n  animate(time) {\n    this.setTime(time);\n  }\n\n  setTime(time) {\n    this.animations.forEach(animation => animation.animate(time));\n  }\n\n  getAnimations() {\n    return this.animations;\n  }\n}\n", "import {Model} from '@luma.gl/engine';\nimport ScenegraphNode from './scenegraph-node';\n\nexport default class ModelNode extends ScenegraphNode {\n  constructor(gl, props = {}) {\n    super(props);\n\n    // pverride callbacks to make sure we call them with this\n    this.onBeforeRender = null;\n    this.AfterRender = null;\n\n    // Create new Model or used supplied Model\n    if (gl instanceof Model) {\n      this.model = gl;\n      this._setModelNodeProps(props);\n    } else {\n      this.model = new Model(gl, props);\n    }\n\n    this.bounds = null;\n    this.managedResources = props.managedResources || [];\n  }\n\n  setProps(props) {\n    super.setProps(props);\n    this._setModelNodeProps(props);\n    return this;\n  }\n\n  getBounds() {\n    return this.bounds;\n  }\n\n  delete() {\n    if (this.model) {\n      this.model.delete();\n      this.model = null;\n    }\n\n    this.managedResources.forEach(resource => resource.delete());\n    this.managedResources = [];\n  }\n\n  // Forward node methods\n  draw(...args) {\n    // Return value indicates if something was actually drawn\n    return this.model.draw(...args);\n  }\n\n  setUniforms(...args) {\n    this.model.setUniforms(...args);\n    return this;\n  }\n\n  setAttributes(...args) {\n    this.model.setAttributes(...args);\n    return this;\n  }\n\n  updateModuleSettings(...args) {\n    this.model.updateModuleSettings(...args);\n    return this;\n  }\n\n  // PRIVATE\n\n  _setModelNodeProps(props) {\n    this.model.setProps(props);\n  }\n}\n", "import {Texture2D, hasFeature, FEATURES, log} from '@luma.gl/webgl';\n\nexport default class GLTFMaterialParser {\n  constructor(\n    gl,\n    {attributes, material, pbrDebug, imageBasedLightingEnvironment, lights, useTangents}\n  ) {\n    this.gl = gl;\n\n    this.defines = {\n      // TODO: Use EXT_sRGB if available (Standard in WebGL 2.0)\n      MANUAL_SRGB: 1,\n      SRGB_FAST_APPROXIMATION: 1\n    };\n\n    if (hasFeature(gl, FEATURES.GLSL_TEXTURE_LOD)) {\n      this.defines.USE_TEX_LOD = 1;\n    }\n\n    this.uniforms = {\n      // TODO: find better values?\n      u_Camera: [0, 0, 0], // Model should override\n\n      u_MetallicRoughnessValues: [1, 1] // Default is 1 and 1\n    };\n\n    this.parameters = {};\n    this.generatedTextures = [];\n\n    if (imageBasedLightingEnvironment) {\n      this.uniforms.u_DiffuseEnvSampler = imageBasedLightingEnvironment.getDiffuseEnvSampler();\n      this.uniforms.u_SpecularEnvSampler = imageBasedLightingEnvironment.getSpecularEnvSampler();\n      this.uniforms.u_brdfLUT = imageBasedLightingEnvironment.getBrdfTexture();\n      this.uniforms.u_ScaleIBLAmbient = [1, 1];\n    }\n\n    if (pbrDebug) {\n      // Override final color for reference app visualization\n      // of various parameters in the lighting equation.\n      this.uniforms.u_ScaleDiffBaseMR = [0, 0, 0, 0];\n      this.uniforms.u_ScaleFGDSpec = [0, 0, 0, 0];\n    }\n\n    this.defineIfPresent(attributes.NORMAL, 'HAS_NORMALS');\n    this.defineIfPresent(attributes.TANGENT && useTangents, 'HAS_TANGENTS');\n    this.defineIfPresent(attributes.TEXCOORD_0, 'HAS_UV');\n\n    this.defineIfPresent(imageBasedLightingEnvironment, 'USE_IBL');\n    this.defineIfPresent(lights, 'USE_LIGHTS');\n    this.defineIfPresent(pbrDebug, 'PBR_DEBUG');\n\n    if (material) {\n      this.parseMaterial(material);\n    }\n  }\n\n  defineIfPresent(value, name) {\n    if (value) {\n      this.defines[name] = 1;\n    }\n  }\n\n  parseTexture(gltfTexture, name, define = null) {\n    const parameters =\n      (gltfTexture.texture &&\n        gltfTexture.texture.sampler &&\n        gltfTexture.texture.sampler.parameters) ||\n      {};\n\n    const image = gltfTexture.texture.source.image;\n    let textureOptions;\n    let specialTextureParameters = {};\n    if (image.compressed) {\n      textureOptions = image;\n      specialTextureParameters = {\n        [this.gl.TEXTURE_MIN_FILTER]:\n          image.data.length > 1 ? this.gl.LINEAR_MIPMAP_NEAREST : this.gl.LINEAR\n      };\n    } else {\n      // Texture2D accepts a promise that returns an image as data (Async Textures)\n      textureOptions = {data: image};\n    }\n\n    const texture = new Texture2D(this.gl, {\n      id: gltfTexture.name || gltfTexture.id,\n      parameters: {\n        ...parameters,\n        ...specialTextureParameters\n      },\n      pixelStore: {\n        [this.gl.UNPACK_FLIP_Y_WEBGL]: false\n      },\n      ...textureOptions\n    });\n    this.uniforms[name] = texture;\n    this.defineIfPresent(define, define);\n    this.generatedTextures.push(texture);\n  }\n\n  parsePbrMetallicRoughness(pbrMetallicRoughness) {\n    if (pbrMetallicRoughness.baseColorTexture) {\n      this.parseTexture(\n        pbrMetallicRoughness.baseColorTexture,\n        'u_BaseColorSampler',\n        'HAS_BASECOLORMAP'\n      );\n    }\n    this.uniforms.u_BaseColorFactor = pbrMetallicRoughness.baseColorFactor || [1, 1, 1, 1];\n\n    if (pbrMetallicRoughness.metallicRoughnessTexture) {\n      this.parseTexture(\n        pbrMetallicRoughness.metallicRoughnessTexture,\n        'u_MetallicRoughnessSampler',\n        'HAS_METALROUGHNESSMAP'\n      );\n    }\n    const {metallicFactor = 1, roughnessFactor = 1} = pbrMetallicRoughness;\n    this.uniforms.u_MetallicRoughnessValues = [metallicFactor, roughnessFactor];\n  }\n\n  parseMaterial(material) {\n    this.uniforms.pbr_uUnlit = Boolean(material.unlit);\n\n    if (material.pbrMetallicRoughness) {\n      this.parsePbrMetallicRoughness(material.pbrMetallicRoughness);\n    }\n    if (material.normalTexture) {\n      this.parseTexture(material.normalTexture, 'u_NormalSampler', 'HAS_NORMALMAP');\n\n      const {scale = 1} = material.normalTexture;\n      this.uniforms.u_NormalScale = scale;\n    }\n    if (material.occlusionTexture) {\n      this.parseTexture(material.occlusionTexture, 'u_OcclusionSampler', 'HAS_OCCLUSIONMAP');\n\n      const {strength = 1} = material.occlusionTexture;\n      this.uniforms.u_OcclusionStrength = strength;\n    }\n    if (material.emissiveTexture) {\n      this.parseTexture(material.emissiveTexture, 'u_EmissiveSampler', 'HAS_EMISSIVEMAP');\n      this.uniforms.u_EmissiveFactor = material.emissiveFactor || [0, 0, 0];\n    }\n    if (material.alphaMode === 'MASK') {\n      const {alphaCutoff = 0.5} = material;\n      this.defines.ALPHA_CUTOFF = 1;\n      this.uniforms.u_AlphaCutoff = alphaCutoff;\n    } else if (material.alphaMode === 'BLEND') {\n      log.warn('BLEND alphaMode might not work well because it requires mesh sorting')();\n      Object.assign(this.parameters, {\n        blend: true,\n        blendEquation: this.gl.FUNC_ADD,\n        blendFunc: [\n          this.gl.SRC_ALPHA,\n          this.gl.ONE_MINUS_SRC_ALPHA,\n          this.gl.ONE,\n          this.gl.ONE_MINUS_SRC_ALPHA\n        ]\n      });\n    }\n  }\n\n  /**\n   * Destroy all generated resources to release memory.\n   */\n  delete() {\n    this.generatedTextures.forEach(texture => texture.delete());\n  }\n}\n", "import {isWebGL2} from '@luma.gl/gltools';\nimport {log} from '@luma.gl/webgl';\nimport {pbr} from '@luma.gl/shadertools';\nimport ModelNode from '../scenegraph/model-node';\nimport GLTFMaterialParser from './gltf-material-parser';\n\nconst vs = `\n#if (__VERSION__ < 300)\n  #define _attr attribute\n#else\n  #define _attr in\n#endif\n\n  _attr vec4 POSITION;\n\n  #ifdef HAS_NORMALS\n    _attr vec4 NORMAL;\n  #endif\n\n  #ifdef HAS_TANGENTS\n    _attr vec4 TANGENT;\n  #endif\n\n  #ifdef HAS_UV\n    _attr vec2 TEXCOORD_0;\n  #endif\n\n  void main(void) {\n    vec4 _NORMAL = vec4(0.);\n    vec4 _TANGENT = vec4(0.);\n    vec2 _TEXCOORD_0 = vec2(0.);\n\n    #ifdef HAS_NORMALS\n      _NORMAL = NORMAL;\n    #endif\n\n    #ifdef HAS_TANGENTS\n      _TANGENT = TANGENT;\n    #endif\n\n    #ifdef HAS_UV\n      _TEXCOORD_0 = TEXCOORD_0;\n    #endif\n\n    pbr_setPositionNormalTangentUV(POSITION, _NORMAL, _TANGENT, _TEXCOORD_0);\n    gl_Position = u_MVPMatrix * POSITION;\n  }\n`;\n\nconst fs = `\n#if (__VERSION__ < 300)\n  #define fragmentColor gl_FragColor\n#else\n  out vec4 fragmentColor;\n#endif\n\n  void main(void) {\n    fragmentColor = pbr_filterColor(vec4(0));\n  }\n`;\n\nfunction addVersionToShader(gl, source) {\n  if (isWebGL2(gl)) {\n    return `#version 300 es\\n${source}`;\n  }\n\n  return source;\n}\n\nexport default function createGLTFModel(gl, options) {\n  const {id, drawMode, vertexCount, attributes, modelOptions} = options;\n  const materialParser = new GLTFMaterialParser(gl, options);\n\n  log.info(4, 'createGLTFModel defines: ', materialParser.defines)();\n\n  // Calculate managedResources\n  // TODO: Implement resource management logic that will\n  // not deallocate resources/textures/buffers that are shared\n  const managedResources = [];\n  managedResources.push(...materialParser.generatedTextures);\n  managedResources.push(...Object.values(attributes).map(attribute => attribute.buffer));\n\n  const model = new ModelNode(\n    gl,\n    Object.assign(\n      {\n        id,\n        drawMode,\n        vertexCount,\n        modules: [pbr],\n        defines: materialParser.defines,\n        parameters: materialParser.parameters,\n        vs: addVersionToShader(gl, vs),\n        fs: addVersionToShader(gl, fs),\n        managedResources\n      },\n      modelOptions\n    )\n  );\n\n  model.setProps({attributes});\n  model.setUniforms(materialParser.uniforms);\n\n  return model;\n}\n", "import {Matrix4} from '@math.gl/core';\nimport {Buffer, Accessor, log} from '@luma.gl/webgl';\nimport GroupNode from '../scenegraph/group-node';\n\nimport GLTFAnimator from './gltf-animator';\nimport createGLTFModel from './create-gltf-model';\n\n// TODO: import {ATTRIBUTE_TYPE_TO_COMPONENTS} from '@loaders.gl/gltf';\nconst ATTRIBUTE_TYPE_TO_COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\n\nconst DEFAULT_OPTIONS = {\n  modelOptions: {},\n  pbrDebug: false,\n  imageBasedLightingEnvironment: null,\n  lights: true,\n  useTangents: false\n};\n\n// GLTF instantiator for luma.gl\n// Walks the parsed and resolved glTF structure and builds a luma.gl scenegraph\nexport default class GLTFInstantiator {\n  constructor(gl, options = {}) {\n    this.gl = gl;\n    this.options = Object.assign({}, DEFAULT_OPTIONS, options);\n  }\n\n  instantiate(gltf) {\n    this.gltf = gltf;\n    const scenes = (gltf.scenes || []).map(scene => this.createScene(scene));\n    return scenes;\n  }\n\n  createAnimator() {\n    if (Array.isArray(this.gltf.animations)) {\n      return new GLTFAnimator(this.gltf);\n    }\n\n    return null;\n  }\n\n  createScene(gltfScene) {\n    const gltfNodes = gltfScene.nodes || [];\n    const nodes = gltfNodes.map(node => this.createNode(node));\n    const scene = new GroupNode({\n      id: gltfScene.name || gltfScene.id,\n      children: nodes\n    });\n    return scene;\n  }\n\n  createNode(gltfNode) {\n    if (!gltfNode._node) {\n      const gltfChildren = gltfNode.children || [];\n      const children = gltfChildren.map(child => this.createNode(child));\n\n      // Node can have children nodes and meshes at the same time\n      if (gltfNode.mesh) {\n        children.push(this.createMesh(gltfNode.mesh));\n      }\n\n      const node = new GroupNode({\n        id: gltfNode.name || gltfNode.id,\n        children\n      });\n\n      if (gltfNode.matrix) {\n        node.setMatrix(gltfNode.matrix);\n      } else {\n        node.matrix.identity();\n\n        if (gltfNode.translation) {\n          node.matrix.translate(gltfNode.translation);\n        }\n\n        if (gltfNode.rotation) {\n          const rotationMatrix = new Matrix4().fromQuaternion(gltfNode.rotation);\n          node.matrix.multiplyRight(rotationMatrix);\n        }\n\n        if (gltfNode.scale) {\n          node.matrix.scale(gltfNode.scale);\n        }\n      }\n      gltfNode._node = node;\n    }\n\n    return gltfNode._node;\n  }\n\n  createMesh(gltfMesh) {\n    // TODO: avoid changing the gltf\n    if (!gltfMesh._mesh) {\n      const gltfPrimitives = gltfMesh.primitives || [];\n      const primitives = gltfPrimitives.map((gltfPrimitive, i) =>\n        this.createPrimitive(gltfPrimitive, i, gltfMesh)\n      );\n      const mesh = new GroupNode({\n        id: gltfMesh.name || gltfMesh.id,\n        children: primitives\n      });\n      gltfMesh._mesh = mesh;\n    }\n\n    return gltfMesh._mesh;\n  }\n\n  getVertexCount(attributes) {\n    // TODO: implement this\n    log.warn('getVertexCount() not found')();\n  }\n\n  createPrimitive(gltfPrimitive, i, gltfMesh) {\n    const model = createGLTFModel(\n      this.gl,\n      Object.assign(\n        {\n          id: gltfPrimitive.name || `${gltfMesh.name || gltfMesh.id}-primitive-${i}`,\n          drawMode: gltfPrimitive.mode || 4,\n          vertexCount: gltfPrimitive.indices\n            ? gltfPrimitive.indices.count\n            : this.getVertexCount(gltfPrimitive.attributes),\n          attributes: this.createAttributes(gltfPrimitive.attributes, gltfPrimitive.indices),\n          material: gltfPrimitive.material\n        },\n        this.options\n      )\n    );\n\n    model.bounds = [gltfPrimitive.attributes.POSITION.min, gltfPrimitive.attributes.POSITION.max];\n\n    return model;\n  }\n\n  createAttributes(attributes, indices) {\n    const loadedAttributes = {};\n\n    Object.keys(attributes).forEach(attrName => {\n      loadedAttributes[attrName] = this.createAccessor(\n        attributes[attrName],\n        this.createBuffer(attributes[attrName], this.gl.ARRAY_BUFFER)\n      );\n    });\n\n    if (indices) {\n      loadedAttributes.indices = this.createAccessor(\n        indices,\n        this.createBuffer(indices, this.gl.ELEMENT_ARRAY_BUFFER)\n      );\n    }\n\n    log.info(4, 'glTF Attributes', {attributes, indices, generated: loadedAttributes})();\n\n    return loadedAttributes;\n  }\n\n  createBuffer(attribute, target) {\n    if (!attribute.bufferView) {\n      // Draco decoded files do not have a bufferView\n      attribute.bufferView = {};\n    }\n\n    const {bufferView} = attribute;\n    if (!bufferView.lumaBuffers) {\n      bufferView.lumaBuffers = {};\n    }\n\n    if (!bufferView.lumaBuffers[target]) {\n      bufferView.lumaBuffers[target] = new Buffer(this.gl, {\n        id: `from-${bufferView.id}`,\n        // Draco decoded files have attribute.value\n        data: bufferView.data || attribute.value,\n        target\n      });\n    }\n\n    return bufferView.lumaBuffers[target];\n  }\n\n  createAccessor(accessor, buffer) {\n    return new Accessor({\n      buffer,\n      offset: accessor.byteOffset || 0,\n      stride: accessor.bufferView.byteStride || 0,\n      type: accessor.componentType,\n      size: ATTRIBUTE_TYPE_TO_COMPONENTS[accessor.type]\n    });\n  }\n\n  // TODO - create sampler in WebGL2\n  createSampler(gltfSampler) {\n    return gltfSampler;\n  }\n\n  // Helper methods (move to GLTFLoader.resolve...?)\n\n  needsPOT() {\n    // Has a wrapping mode (either wrapS or wrapT) equal to REPEAT or MIRRORED_REPEAT, or\n    // Has a minification filter (minFilter) that uses mipmapping\n    // (NEAREST_MIPMAP_NEAREST, NEAREST_MIPMAP_LINEAR,\n    // LINEAR_MIPMAP_NEAREST, or LINEAR_MIPMAP_LINEAR).\n    return false;\n  }\n}\n", "import GLTFInstantiator from './gltf-instantiator';\n\nexport default function createGLTFObjects(gl, gltf, options) {\n  const instantiator = new GLTFInstantiator(gl, options);\n  const scenes = instantiator.instantiate(gltf);\n  const animator = instantiator.createAnimator();\n\n  return {scenes, animator};\n}\n", "// => COPIED FROM  deck.gl\n\n// Copyright (c) 2015 - 2020 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* eslint-disable max-params */\nimport earcut from 'earcut';\n\n// For Web Mercator projection\nconst PI_4 = Math.PI / 4;\nconst DEGREES_TO_RADIANS_HALF = Math.PI / 360;\n\n// 4 data formats are supported:\n// Simple Polygon: an array of points\n// Complex Polygon: an array of array of points (array of rings)\n//   with the first ring representing the outer hull and other rings representing holes\n// Simple Flat: an array of numbers (flattened \"simple polygon\")\n// Complex Flat: {position: array<number>, holeIndices: array<number>}\n//   (flattened \"complex polygon\")\n\n/**\n * Ensure a polygon is valid format\n * @param {Array|Object} polygon\n */\nfunction validate(polygon) {\n  polygon = (polygon && polygon.positions) || polygon;\n  if (!Array.isArray(polygon) && !ArrayBuffer.isView(polygon)) {\n    throw new Error('invalid polygon');\n  }\n}\n\n/**\n * Check if a polygon is simple or complex\n * @param {Array} polygon - either a complex or simple polygon\n * @return {Boolean} - true if the polygon is a simple polygon (i.e. not an array of polygons)\n */\nfunction isSimple(polygon) {\n  return polygon.length >= 1 && polygon[0].length >= 2 && Number.isFinite(polygon[0][0]);\n}\n\n/**\n * Check if a simple polygon is a closed ring\n * @param {Array} simplePolygon - array of points\n * @return {Boolean} - true if the simple polygon is a closed ring\n */\nfunction isNestedRingClosed(simplePolygon) {\n  // check if first and last vertex are the same\n  const p0 = simplePolygon[0];\n  const p1 = simplePolygon[simplePolygon.length - 1];\n\n  return p0[0] === p1[0] && p0[1] === p1[1] && p0[2] === p1[2];\n}\n\n/**\n * Check if a simple flat array is a closed ring\n * @param {Array} positions - array of numbers\n * @param {Number} size - size of a position, 2 (xy) or 3 (xyz)\n * @param {Number} startIndex - start index of the path in the positions array\n * @param {Number} endIndex - end index of the path in the positions array\n * @return {Boolean} - true if the simple flat array is a closed ring\n */\nfunction isFlatRingClosed(positions, size, startIndex, endIndex) {\n  for (let i = 0; i < size; i++) {\n    if (positions[startIndex + i] !== positions[endIndex - size + i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Copy a simple polygon coordinates into a flat array, closes the ring if needed.\n * @param {Float64Array} target - destination\n * @param {Number} targetStartIndex - index in the destination to start copying into\n * @param {Array} simplePolygon - array of points\n * @param {Number} size - size of a position, 2 (xy) or 3 (xyz)\n * @returns {Number} - the index of the write head in the destination\n */\nfunction copyNestedRing(target, targetStartIndex, simplePolygon, size) {\n  let targetIndex = targetStartIndex;\n  const len = simplePolygon.length;\n  for (let i = 0; i < len; i++) {\n    for (let j = 0; j < size; j++) {\n      target[targetIndex++] = simplePolygon[i][j] || 0;\n    }\n  }\n\n  if (!isNestedRingClosed(simplePolygon)) {\n    for (let j = 0; j < size; j++) {\n      target[targetIndex++] = simplePolygon[0][j] || 0;\n    }\n  }\n  return targetIndex;\n}\n\n/**\n * Copy a simple flat array into another flat array, closes the ring if needed.\n * @param {Float64Array} target - destination\n * @param {Number} targetStartIndex - index in the destination to start copying into\n * @param {Array} positions - array of numbers\n * @param {Number} size - size of a position, 2 (xy) or 3 (xyz)\n * @param {Number} [srcStartIndex] - start index of the path in the positions array\n * @param {Number} [srcEndIndex] - end index of the path in the positions array\n * @returns {Number} - the index of the write head in the destination\n */\nfunction copyFlatRing(target, targetStartIndex, positions, size, srcStartIndex = 0, srcEndIndex) {\n  srcEndIndex = srcEndIndex || positions.length;\n  const srcLength = srcEndIndex - srcStartIndex;\n  if (srcLength <= 0) {\n    return targetStartIndex;\n  }\n  let targetIndex = targetStartIndex;\n\n  for (let i = 0; i < srcLength; i++) {\n    target[targetIndex++] = positions[srcStartIndex + i];\n  }\n\n  if (!isFlatRingClosed(positions, size, srcStartIndex, srcEndIndex)) {\n    for (let i = 0; i < size; i++) {\n      target[targetIndex++] = positions[srcStartIndex + i];\n    }\n  }\n  return targetIndex;\n}\n\n/**\n * Counts the number of vertices in a simple polygon, closes the polygon if needed.\n * @param {Array} simplePolygon - array of points\n * @returns {Number} vertex count\n */\nfunction getNestedVertexCount(simplePolygon) {\n  return (isNestedRingClosed(simplePolygon) ? 0 : 1) + simplePolygon.length;\n}\n\n/**\n * Counts the number of vertices in a simple flat array, closes the polygon if needed.\n * @param {Array} positions - array of numbers\n * @param {Number} size - size of a position, 2 (xy) or 3 (xyz)\n * @param {Number} [startIndex] - start index of the path in the positions array\n * @param {Number} [endIndex] - end index of the path in the positions array\n * @returns {Number} vertex count\n */\nfunction getFlatVertexCount(positions, size, startIndex = 0, endIndex) {\n  endIndex = endIndex || positions.length;\n  if (startIndex >= endIndex) {\n    return 0;\n  }\n  return (\n    (isFlatRingClosed(positions, size, startIndex, endIndex) ? 0 : 1) +\n    (endIndex - startIndex) / size\n  );\n}\n\n/**\n * Counts the number of vertices in any polygon representation.\n * @param {Array|Object} polygon\n * @param {Number} positionSize - size of a position, 2 (xy) or 3 (xyz)\n * @returns {Number} vertex count\n */\nexport function getVertexCount(polygon, positionSize, normalization = true) {\n  if (!normalization) {\n    polygon = polygon.positions || polygon;\n    return polygon.length / positionSize;\n  }\n\n  validate(polygon);\n\n  if (polygon.positions) {\n    // complex flat\n    const {positions, holeIndices} = polygon;\n\n    if (holeIndices) {\n      let vertexCount = 0;\n      // split the positions array into `holeIndices.length + 1` rings\n      // holeIndices[-1] falls back to 0\n      // holeIndices[holeIndices.length] falls back to positions.length\n      for (let i = 0; i <= holeIndices.length; i++) {\n        vertexCount += getFlatVertexCount(\n          polygon.positions,\n          positionSize,\n          holeIndices[i - 1],\n          holeIndices[i]\n        );\n      }\n      return vertexCount;\n    }\n    polygon = positions;\n  }\n  if (Number.isFinite(polygon[0])) {\n    // simple flat\n    return getFlatVertexCount(polygon, positionSize);\n  }\n  if (!isSimple(polygon)) {\n    // complex polygon\n    let vertexCount = 0;\n    for (const simplePolygon of polygon) {\n      vertexCount += getNestedVertexCount(simplePolygon);\n    }\n    return vertexCount;\n  }\n  // simple polygon\n  return getNestedVertexCount(polygon);\n}\n\n/**\n * Normalize any polygon representation into the \"complex flat\" format\n * @param {Array|Object} polygon\n * @param {Number} positionSize - size of a position, 2 (xy) or 3 (xyz)\n * @param {Number} [vertexCount] - pre-computed vertex count in the polygon.\n *   If provided, will skip counting.\n * @return {Object} - {positions: <Float64Array>, holeIndices: <Array|null>}\n */\n/* eslint-disable max-statements */\nexport function normalize(polygon, positionSize, vertexCount) {\n  validate(polygon);\n\n  vertexCount = vertexCount || getVertexCount(polygon, positionSize);\n\n  const positions = new Float64Array(vertexCount * positionSize);\n  const holeIndices = [];\n\n  if (polygon.positions) {\n    // complex flat\n    const {positions: srcPositions, holeIndices: srcHoleIndices} = polygon;\n\n    if (srcHoleIndices) {\n      let targetIndex = 0;\n      // split the positions array into `holeIndices.length + 1` rings\n      // holeIndices[-1] falls back to 0\n      // holeIndices[holeIndices.length] falls back to positions.length\n      for (let i = 0; i <= srcHoleIndices.length; i++) {\n        targetIndex = copyFlatRing(\n          positions,\n          targetIndex,\n          srcPositions,\n          positionSize,\n          srcHoleIndices[i - 1],\n          srcHoleIndices[i]\n        );\n        holeIndices.push(targetIndex);\n      }\n      // The last one is not a starting index of a hole, remove\n      holeIndices.pop();\n\n      return {positions, holeIndices};\n    }\n    polygon = srcPositions;\n  }\n  if (Number.isFinite(polygon[0])) {\n    // simple flat\n    copyFlatRing(positions, 0, polygon, positionSize);\n    return positions;\n  }\n  if (!isSimple(polygon)) {\n    // complex polygon\n    let targetIndex = 0;\n\n    for (const simplePolygon of polygon) {\n      targetIndex = copyNestedRing(positions, targetIndex, simplePolygon, positionSize);\n      holeIndices.push(targetIndex);\n    }\n    // The last one is not a starting index of a hole, remove\n    holeIndices.pop();\n    // last index points to the end of the array, remove it\n    return {positions, holeIndices};\n  }\n  // simple polygon\n  copyNestedRing(positions, 0, polygon, positionSize);\n  return positions;\n}\n/* eslint-enable max-statements */\n\n/*\n * Get vertex indices for drawing polygon mesh\n * @param {Object} normalizedPolygon - {positions, holeIndices}\n * @param {Number} positionSize - size of a position, 2 (xy) or 3 (xyz)\n * @returns {Array} array of indices\n */\nexport function getSurfaceIndices(normalizedPolygon, positionSize, preproject) {\n  let holeIndices = null;\n\n  if (normalizedPolygon.holeIndices) {\n    holeIndices = normalizedPolygon.holeIndices.map(positionIndex => positionIndex / positionSize);\n  }\n  let positions = normalizedPolygon.positions || normalizedPolygon;\n\n  // TODO - handle other coordinate systems and projection modes\n  if (preproject) {\n    // When tesselating lnglat coordinates, project them to the Web Mercator plane for accuracy\n    const n = positions.length;\n    // Clone the array\n    positions = positions.slice();\n    for (let i = 0; i < n; i += positionSize) {\n      // project points to a scaled version of the web-mercator plane\n      // It doesn't matter if x and y are scaled/translated, but the relationship must be linear\n      const y = positions[i + 1];\n      positions[i + 1] = Math.log(Math.tan(PI_4 + y * DEGREES_TO_RADIANS_HALF));\n    }\n  }\n\n  // Let earcut triangulate the polygon\n  return earcut(positions, holeIndices, positionSize);\n}\n", "/* global requestAnimationFrame */\nimport type {GroupNode, ModelNode} from '@luma.gl/experimental';\n\nexport async function waitForGLTFAssets(gltfObjects: {scenes: GroupNode[]}): Promise<void> {\n  const remaining: any[] = [];\n\n  gltfObjects.scenes.forEach(scene => {\n    scene.traverse((model: ModelNode) => {\n      Object.values(model.model.getUniforms()).forEach((uniform: any) => {\n        if (uniform.loaded === false) {\n          remaining.push(uniform);\n        }\n      });\n    });\n  });\n\n  return await waitWhileCondition(() => remaining.some(uniform => !uniform.loaded));\n}\n\nasync function waitWhileCondition(condition: () => boolean): Promise<void> {\n  while (condition()) {\n    await new Promise(resolve => requestAnimationFrame(resolve));\n  }\n}\n", "export default `\\\n#version 300 es\n\n// Instance attributes\nin vec3 instancePositions;\nin vec3 instancePositions64Low;\nin vec4 instanceColors;\nin vec3 instancePickingColors;\nin mat3 instanceModelMatrix;\nin vec3 instanceTranslation;\n\n// Uniforms\nuniform float sizeScale;\nuniform float sizeMinPixels;\nuniform float sizeMaxPixels;\nuniform mat4 sceneModelMatrix;\nuniform bool composeModelMatrix;\n\n// Attributes\nin vec4 POSITION;\n\n#ifdef HAS_UV\n  in vec2 TEXCOORD_0;\n#endif\n\n#ifdef MODULE_PBR\n  #ifdef HAS_NORMALS\n    in vec4 NORMAL;\n  #endif\n#endif\n\n// Varying\nout vec4 vColor;\n\n// MODULE_PBR contains all the varying definitions needed\n#ifndef MODULE_PBR\n  #ifdef HAS_UV\n    out vec2 vTEXCOORD_0;\n  #endif\n#endif\n\n// Main\nvoid main(void) {\n  #if defined(HAS_UV) && !defined(MODULE_PBR)\n    vTEXCOORD_0 = TEXCOORD_0;\n    geometry.uv = vTEXCOORD_0;\n  #endif\n\n  geometry.worldPosition = instancePositions;\n  geometry.pickingColor = instancePickingColors;\n\n  vec3 normal = vec3(0.0, 0.0, 1.0);\n  #ifdef MODULE_PBR\n    #ifdef HAS_NORMALS\n      normal = instanceModelMatrix * (sceneModelMatrix * vec4(NORMAL.xyz, 0.0)).xyz;\n    #endif\n  #endif\n\n  float originalSize = project_size_to_pixel(sizeScale);\n  float clampedSize = clamp(originalSize, sizeMinPixels, sizeMaxPixels);\n\n  vec3 pos = (instanceModelMatrix * (sceneModelMatrix * POSITION).xyz) * sizeScale * (clampedSize / originalSize) + instanceTranslation;\n  if(composeModelMatrix) {\n    DECKGL_FILTER_SIZE(pos, geometry);\n    // using instancePositions as world coordinates\n    // when using globe mode, this branch does not re-orient the model to align with the surface of the earth\n    // call project_normal before setting position to avoid rotation\n    geometry.normal = project_normal(normal);\n    geometry.worldPosition += pos;\n    gl_Position = project_position_to_clipspace(pos + instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n  }\n  else {\n    pos = project_size(pos);\n    DECKGL_FILTER_SIZE(pos, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, pos, geometry.position);\n    geometry.normal = project_normal(normal);\n  }\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  #ifdef MODULE_PBR\n    // set PBR data\n    pbr_vPosition = geometry.position.xyz;\n    #ifdef HAS_NORMALS\n      pbr_vNormal = geometry.normal;\n    #endif\n\n    #ifdef HAS_UV\n      pbr_vUV = TEXCOORD_0;\n    #else\n      pbr_vUV = vec2(0., 0.);\n    #endif\n    geometry.uv = pbr_vUV;\n  #endif\n\n  vColor = instanceColors;\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n`;\n", "export default `\\\n#version 300 es\n\n// Uniforms\nuniform float opacity;\n\n// Varying\nin vec4 vColor;\n\nout vec4 fragmentColor;\n\n// MODULE_PBR contains all the varying definitions needed\n#ifndef MODULE_PBR\n  #if defined(HAS_UV) && defined(HAS_BASECOLORMAP)\n    in vec2 vTEXCOORD_0;\n    uniform sampler2D u_BaseColorSampler;\n  #endif\n#endif\n\nvoid main(void) {\n  #ifdef MODULE_PBR\n    fragmentColor = vColor * pbr_filterColor(vec4(0));\n    geometry.uv = pbr_vUV;\n  #else\n    #if defined(HAS_UV) && defined(HAS_BASECOLORMAP)\n      fragmentColor = vColor * texture2D(u_BaseColorSampler, vTEXCOORD_0);\n      geometry.uv = vTEXCOORD_0;\n    #else\n      fragmentColor = vColor;\n    #endif\n  #endif\n\n  fragmentColor.a *= opacity;\n  DECKGL_FILTER_COLOR(fragmentColor, geometry);\n}\n`;\n", "// Copyright (c) 2019 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {Layer, project32, picking, log} from '@deck.gl/core';\nimport {isWebGL2} from '@luma.gl/core';\nimport {pbr} from '@luma.gl/shadertools';\nimport {\n  ScenegraphNode,\n  GroupNode,\n  GLTFAnimator,\n  GLTFEnvironment,\n  createGLTFObjects\n} from '@luma.gl/experimental';\nimport GL from '@luma.gl/constants';\nimport {GLTFLoader} from '@loaders.gl/gltf';\nimport {waitForGLTFAssets} from './gltf-utils';\n\nimport {MATRIX_ATTRIBUTES, shouldComposeModelMatrix} from '../utils/matrix';\n\nimport vs from './scenegraph-layer-vertex.glsl';\nimport fs from './scenegraph-layer-fragment.glsl';\n\nimport type {\n  UpdateParameters,\n  LayerContext,\n  LayerProps,\n  LayerDataSource,\n  Position,\n  Color,\n  Accessor,\n  DefaultProps\n} from '@deck.gl/core';\n\nconst DEFAULT_COLOR: [number, number, number, number] = [255, 255, 255, 255];\n\nexport type ScenegraphLayerProps<DataT = any> = _ScenegraphLayerProps<DataT> & LayerProps;\n\ntype _ScenegraphLayerProps<DataT> = {\n  data: LayerDataSource<DataT>;\n  // TODO - define in luma.gl\n  /**\n   * A url for a glTF model or scenegraph loaded via a [scenegraph loader](https://loaders.gl/docs/specifications/category-scenegraph)\n   */\n  scenegraph: any;\n  /**\n   * Create a luma.gl GroupNode from the resolved scenegraph prop\n   */\n  getScene?: (\n    scenegraph: any,\n    context: {gl: WebGLRenderingContext; layer: ScenegraphLayer<DataT>}\n  ) => GroupNode;\n  /**\n   * Create a luma.gl GLTFAnimator from the resolved scenegraph prop\n   */\n  getAnimator?: (\n    scenegraph: any,\n    context: {gl: WebGLRenderingContext; layer: ScenegraphLayer<DataT>}\n  ) => GLTFAnimator;\n  /**\n   * (Experimental) animation configurations. Requires `_animate` on deck object.\n   */\n  _animations?: {\n    [name: number | string | '*']: {\n      /** If the animation is playing */\n      playing?: boolean;\n      /** Start time of the animation, default `0` */\n      startTime?: number;\n      /** Speed multiplier of the animation, default `1` */\n      speed?: number;\n    };\n  } | null;\n  /**\n   * (Experimental) lighting mode\n   * @default 'flat'\n   */\n  _lighting?: 'flat' | 'pbr';\n  /**\n   * (Experimental) lighting environment. Requires `_lighting` to be `'pbr'`.\n   */\n  _imageBasedLightingEnvironment?:\n    | null\n    | GLTFEnvironment\n    | ((context: {gl: WebGLRenderingContext; layer: ScenegraphLayer<DataT>}) => GLTFEnvironment);\n\n  /** Anchor position accessor. */\n  getPosition?: Accessor<DataT, Position>;\n  /** Color value or accessor.\n   * @default [255, 255, 255, 255]\n   */\n  getColor?: Accessor<DataT, Color>;\n  /**\n   * Orientation in [pitch, yaw, roll] in degrees.\n   * @see https://en.wikipedia.org/wiki/Euler_angles\n   * @default [0, 0, 0]\n   */\n  getOrientation?: Accessor<DataT, [number, number, number]>;\n  /**\n   * Scaling factor of the model along each axis.\n   * @default [1, 1, 1]\n   */\n  getScale?: Accessor<DataT, [number, number, number]>;\n  /**\n   * Translation from the anchor point, [x, y, z] in meters.\n   * @default [0, 0, 0]\n   */\n  getTranslation?: Accessor<DataT, [number, number, number]>;\n  /**\n   * TransformMatrix. If specified, `getOrientation`, `getScale` and `getTranslation` are ignored.\n   */\n  getTransformMatrix?: Accessor<DataT, number[]>;\n  /**\n   * Multiplier to scale each geometry by.\n   * @default 1\n   */\n  sizeScale?: number;\n  /**\n   * The minimum size in pixels for one unit of the scene.\n   * @default 0\n   */\n  sizeMinPixels?: number;\n  /**\n   * The maximum size in pixels for one unit of the scene.\n   * @default Number.MAX_SAFE_INTEGER\n   */\n  sizeMaxPixels?: number;\n};\n\nconst defaultProps: DefaultProps<ScenegraphLayerProps> = {\n  scenegraph: {type: 'object', value: null, async: true},\n  getScene: gltf => {\n    if (gltf && gltf.scenes) {\n      // gltf post processor replaces `gltf.scene` number with the scene `object`\n      return typeof gltf.scene === 'object' ? gltf.scene : gltf.scenes[gltf.scene || 0];\n    }\n    return gltf;\n  },\n  getAnimator: scenegraph => scenegraph && scenegraph.animator,\n  _animations: null,\n\n  sizeScale: {type: 'number', value: 1, min: 0},\n  sizeMinPixels: {type: 'number', min: 0, value: 0},\n  sizeMaxPixels: {type: 'number', min: 0, value: Number.MAX_SAFE_INTEGER},\n\n  getPosition: {type: 'accessor', value: x => x.position},\n  getColor: {type: 'accessor', value: DEFAULT_COLOR},\n\n  // flat or pbr\n  _lighting: 'flat',\n  // _lighting must be pbr for this to work\n  _imageBasedLightingEnvironment: null,\n\n  // yaw, pitch and roll are in degrees\n  // https://en.wikipedia.org/wiki/Euler_angles\n  // [pitch, yaw, roll]\n  getOrientation: {type: 'accessor', value: [0, 0, 0]},\n  getScale: {type: 'accessor', value: [1, 1, 1]},\n  getTranslation: {type: 'accessor', value: [0, 0, 0]},\n  // 4x4 matrix\n  getTransformMatrix: {type: 'accessor', value: []},\n\n  loaders: [GLTFLoader]\n};\n\n/** Render a number of instances of a complete glTF scenegraph. */\nexport default class ScenegraphLayer<DataT = any, ExtraPropsT extends {} = {}> extends Layer<\n  ExtraPropsT & Required<_ScenegraphLayerProps<DataT>>\n> {\n  static defaultProps = defaultProps;\n  static layerName = 'ScenegraphLayer';\n\n  state!: {\n    scenegraph: GroupNode;\n    animator: GLTFAnimator;\n    attributesAvailable?: boolean;\n  };\n\n  getShaders() {\n    const modules = [project32, picking];\n\n    if (this.props._lighting === 'pbr') {\n      modules.push(pbr);\n    }\n\n    return {vs, fs, modules};\n  }\n\n  initializeState() {\n    const attributeManager = this.getAttributeManager();\n    // attributeManager is always defined for primitive layers\n    attributeManager!.addInstanced({\n      instancePositions: {\n        size: 3,\n        type: GL.DOUBLE,\n        fp64: this.use64bitPositions(),\n        accessor: 'getPosition',\n        transition: true\n      },\n      instanceColors: {\n        type: GL.UNSIGNED_BYTE,\n        size: this.props.colorFormat.length,\n        accessor: 'getColor',\n        normalized: true,\n        defaultValue: DEFAULT_COLOR,\n        transition: true\n      },\n      instanceModelMatrix: MATRIX_ATTRIBUTES\n    });\n  }\n\n  updateState(params: UpdateParameters<this>) {\n    super.updateState(params);\n    const {props, oldProps} = params;\n\n    if (props.scenegraph !== oldProps.scenegraph) {\n      this._updateScenegraph();\n    } else if (props._animations !== oldProps._animations) {\n      this._applyAnimationsProp(this.state.scenegraph, this.state.animator, props._animations);\n    }\n  }\n\n  finalizeState(context: LayerContext) {\n    super.finalizeState(context);\n    this._deleteScenegraph();\n  }\n\n  private _updateScenegraph(): void {\n    const props = this.props;\n    const {gl} = this.context;\n    let scenegraphData: any = null;\n    if (props.scenegraph instanceof ScenegraphNode) {\n      // Signature 1: props.scenegraph is a proper luma.gl Scenegraph\n      scenegraphData = {scenes: [props.scenegraph]};\n    } else if (props.scenegraph && !props.scenegraph.gltf) {\n      // Converts loaders.gl gltf to luma.gl scenegraph using the undocumented @luma.gl/experimental function\n      const gltf = props.scenegraph;\n      const gltfObjects = createGLTFObjects(gl, gltf, this._getModelOptions());\n      scenegraphData = {gltf, ...gltfObjects};\n\n      waitForGLTFAssets(gltfObjects).then(() => this.setNeedsRedraw()); // eslint-disable-line @typescript-eslint/no-floating-promises\n    } else if (props.scenegraph) {\n      // DEPRECATED PATH: Assumes this data was loaded through GLTFScenegraphLoader\n      log.deprecated(\n        'ScenegraphLayer.props.scenegraph',\n        'Use GLTFLoader instead of GLTFScenegraphLoader'\n      )();\n      scenegraphData = props.scenegraph;\n    }\n\n    const options = {layer: this, gl};\n    const scenegraph = props.getScene(scenegraphData, options);\n    const animator = props.getAnimator(scenegraphData, options);\n\n    if (scenegraph instanceof ScenegraphNode) {\n      this._deleteScenegraph();\n      this._applyAllAttributes(scenegraph);\n      this._applyAnimationsProp(scenegraph, animator, props._animations);\n      this.setState({scenegraph, animator});\n    } else if (scenegraph !== null) {\n      log.warn('invalid scenegraph:', scenegraph)();\n    }\n  }\n\n  private _applyAllAttributes(scenegraph: GroupNode): void {\n    if (this.state.attributesAvailable) {\n      // attributeManager is always defined for primitive layers\n      const allAttributes = this.getAttributeManager()!.getAttributes();\n      scenegraph.traverse(model => {\n        this._setModelAttributes(model.model, allAttributes);\n      });\n    }\n  }\n\n  private _applyAnimationsProp(\n    scenegraph: GroupNode,\n    animator: GLTFAnimator,\n    animationsProp: any\n  ): void {\n    if (!scenegraph || !animator || !animationsProp) {\n      return;\n    }\n\n    const animations = animator.getAnimations();\n\n    // sort() to ensure '*' comes first so that other values can override\n    Object.keys(animationsProp)\n      .sort()\n      .forEach(key => {\n        // Key can be:\n        //  - number for index number\n        //  - name for animation name\n        //  - * to affect all animations\n        const value = animationsProp[key];\n\n        if (key === '*') {\n          animations.forEach(animation => {\n            Object.assign(animation, value);\n          });\n        } else if (Number.isFinite(Number(key))) {\n          const number = Number(key);\n          if (number >= 0 && number < animations.length) {\n            Object.assign(animations[number], value);\n          } else {\n            log.warn(`animation ${key} not found`)();\n          }\n        } else {\n          const findResult = animations.find(({name}) => name === key);\n          if (findResult) {\n            Object.assign(findResult, value);\n          } else {\n            log.warn(`animation ${key} not found`)();\n          }\n        }\n      });\n  }\n\n  private _deleteScenegraph(): void {\n    const {scenegraph} = this.state;\n    if (scenegraph instanceof ScenegraphNode) {\n      scenegraph.delete();\n    }\n  }\n\n  private _getModelOptions(): any {\n    const {_imageBasedLightingEnvironment} = this.props;\n\n    let env: GLTFEnvironment | null = null;\n    if (_imageBasedLightingEnvironment) {\n      if (typeof _imageBasedLightingEnvironment === 'function') {\n        env = _imageBasedLightingEnvironment({gl: this.context.gl, layer: this});\n      } else {\n        env = _imageBasedLightingEnvironment;\n      }\n    }\n\n    return {\n      gl: this.context.gl,\n      waitForFullLoad: true,\n      imageBasedLightingEnvironment: env,\n      modelOptions: {\n        isInstanced: true,\n        transpileToGLSL100: !isWebGL2(this.context.gl),\n        ...this.getShaders()\n      },\n      // tangents are not supported\n      useTangents: false\n    };\n  }\n\n  updateAttributes(changedAttributes) {\n    this.setState({attributesAvailable: true});\n    if (!this.state.scenegraph) return;\n\n    this.state.scenegraph.traverse(model => {\n      this._setModelAttributes(model.model, changedAttributes);\n    });\n  }\n\n  draw({moduleParameters = null, parameters = {}, context}) {\n    if (!this.state.scenegraph) return;\n\n    if (this.props._animations && this.state.animator) {\n      this.state.animator.animate(context.timeline.getTime());\n      this.setNeedsRedraw();\n    }\n\n    const {viewport} = this.context;\n    const {sizeScale, sizeMinPixels, sizeMaxPixels, opacity, coordinateSystem} = this.props;\n    const numInstances = this.getNumInstances();\n    this.state.scenegraph.traverse((model, {worldMatrix}) => {\n      model.model.setInstanceCount(numInstances);\n      model.updateModuleSettings(moduleParameters);\n      model.draw({\n        parameters,\n        uniforms: {\n          sizeScale,\n          opacity,\n          sizeMinPixels,\n          sizeMaxPixels,\n          composeModelMatrix: shouldComposeModelMatrix(viewport, coordinateSystem),\n          sceneModelMatrix: worldMatrix,\n          // Needed for PBR (TODO: find better way to get it)\n          // eslint-disable-next-line camelcase\n          u_Camera: model.model.getUniforms().project_uCameraPosition\n        }\n      });\n    });\n  }\n}\n"],
  "mappings": "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",
  "names": ["RADIAN_PER_DEGREE", "Math", "PI", "modelMatrix", "Float32Array", "valueArray", "calculateTransformMatrix", "targetMatrix", "orientation", "scale", "pitch", "yaw", "roll", "sr", "sin", "sp", "sw", "cr", "cos", "cp", "cw", "scx", "scy", "scz", "getExtendedMat3FromMat4", "mat4", "subarray", "MATRIX_ATTRIBUTES", "size", "accessor", "shaderAttributes", "instanceModelMatrix__LOCATION_0", "elementOffset", "instanceModelMatrix__LOCATION_1", "instanceModelMatrix__LOCATION_2", "instanceTranslation", "update", "attribute", "startRow", "endRow", "data", "getOrientation", "getScale", "getTranslation", "getTransformMatrix", "props", "arrayMatrix", "Array", "isArray", "constantMatrix", "length", "constantScale", "constantOrientation", "constantTranslation", "hasMatrix", "Boolean", "constant", "instanceModelMatrixData", "value", "matrix", "set", "i", "iterable", "objectInfo", "createIterable", "object", "index", "shouldComposeModelMatrix", "viewport", "coordinateSystem", "COORDINATE_SYSTEM", "CARTESIAN", "METER_OFFSETS", "DEFAULT", "isGeospatial", "validateGeometryAttributes", "attributes", "useMeshColors", "hasColorAttribute", "COLOR_0", "colors", "useColorAttribute", "constant", "value", "Float32Array", "log", "assert", "positions", "POSITION", "getGeometry", "data", "Geometry", "Error", "DEFAULT_COLOR", "defaultProps", "mesh", "type", "async", "texture", "sizeScale", "min", "_useMeshColors", "_instanced", "wireframe", "material", "getPosition", "x", "position", "getColor", "getOrientation", "getScale", "getTranslation", "getTransformMatrix", "textureParameters", "ignore", "SimpleMeshLayer", "Layer", "getShaders", "transpileToGLSL100", "isWebGL2", "context", "gl", "defines", "hasFeature", "FEATURES", "GLSL_DERIVATIVES", "DERIVATIVES_AVAILABLE", "vs", "fs", "modules", "project32", "phongLighting", "picking", "getBounds", "props", "result", "state", "positionBounds", "header", "boundingBox", "getMeshBoundingBox", "initializeState", "attributeManager", "getAttributeManager", "addInstanced", "instancePositions", "transition", "fp64", "use64bitPositions", "size", "accessor", "instanceColors", "colorFormat", "length", "normalized", "defaultValue", "instanceModelMatrix", "MATRIX_ATTRIBUTES", "setState", "emptyTexture", "Texture2D", "Uint8Array", "width", "height", "updateState", "params", "oldProps", "changeFlags", "extensionsChanged", "model", "delete", "getModel", "hasNormals", "Boolean", "NORMAL", "normals", "invalidateAll", "setTexture", "setDrawMode", "finalizeState", "draw", "uniforms", "viewport", "coordinateSystem", "setUniforms", "composeModelMatrix", "shouldComposeModelMatrix", "flatShading", "Model", "id", "geometry", "isInstanced", "sampler", "hasTexture", "ScenegraphNode", "constructor", "props", "id", "uid", "name", "display", "position", "Vector3", "rotation", "scale", "matrix", "Matrix4", "userData", "_setScenegraphNodeProps", "delete", "setProps", "toString", "getBounds", "setPosition", "assert", "length", "setRotation", "setScale", "setMatrix", "copyMatrix", "copy", "setMatrixComponents", "update", "updateMatrix", "pos", "rot", "identity", "translate", "rotateXYZ", "options", "getCoordinateUniforms", "viewMatrix", "modelMatrix", "worldMatrix", "multiplyRight", "worldInverse", "invert", "worldInverseTranspose", "transpose", "objectMatrix", "worldInverseMatrix", "worldInverseTransposeMatrix", "Object", "assign", "GroupNode", "ScenegraphNode", "constructor", "props", "Array", "isArray", "children", "log", "assert", "every", "child", "add", "push", "remove", "indexOf", "splice", "removeAll", "delete", "forEach", "getBounds", "result", "Infinity", "traverse", "node", "worldMatrix", "bounds", "min", "max", "center", "Vector3", "divide", "transformAsPoint", "halfSize", "subtract", "transformAsVector", "v", "position", "multiply", "i", "Math", "Number", "isFinite", "visitor", "Matrix4", "modelMatrix", "multiplyRight", "matrix", "ATTRIBUTE_TYPE_TO_COMPONENTS", "SCALAR", "VEC2", "VEC3", "VEC4", "MAT2", "MAT3", "MAT4", "ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY", "Int8Array", "Uint8Array", "Int16Array", "Uint16Array", "Uint32Array", "Float32Array", "accessorToJsArray", "accessor", "_animation", "ArrayType", "componentType", "components", "type", "length", "count", "buffer", "byteOffset", "bufferView", "data", "array", "Array", "from", "slicedArray", "i", "push", "slice", "helperMatrix", "Matrix4", "applyTranslationRotationScale", "gltfNode", "node", "matrix", "identity", "translation", "translate", "rotation", "rotationMatrix", "fromQuaternion", "multiplyRight", "scale", "quaternion", "Quaternion", "linearInterpolate", "target", "path", "start", "stop", "ratio", "slerp", "cubicsplineInterpolate", "p0", "outTangent0", "inTangent1", "p1", "tDiff", "t", "m0", "m1", "Math", "pow", "stepInterpolate", "value", "interpolate", "time", "input", "interpolation", "output", "maxTime", "animationTime", "nextIndex", "findIndex", "previousIndex", "max", "isArray", "log", "warn", "assert", "previousTime", "nextTime", "GLTFAnimation", "constructor", "props", "startTime", "playing", "speed", "channels", "Object", "assign", "animate", "timeMs", "absTime", "forEach", "sampler", "_node", "GLTFAnimator", "gltf", "animations", "map", "animation", "index", "name", "samplers", "accessors", "nodes", "setTime", "getAnimations", "ModelNode", "ScenegraphNode", "constructor", "gl", "props", "onBeforeRender", "AfterRender", "Model", "model", "_setModelNodeProps", "bounds", "managedResources", "setProps", "getBounds", "delete", "forEach", "resource", "draw", "setUniforms", "setAttributes", "updateModuleSettings", "GLTFMaterialParser", "constructor", "gl", "attributes", "material", "pbrDebug", "imageBasedLightingEnvironment", "lights", "useTangents", "defines", "MANUAL_SRGB", "SRGB_FAST_APPROXIMATION", "hasFeature", "FEATURES", "GLSL_TEXTURE_LOD", "USE_TEX_LOD", "uniforms", "u_Camera", "u_MetallicRoughnessValues", "parameters", "generatedTextures", "u_DiffuseEnvSampler", "getDiffuseEnvSampler", "u_SpecularEnvSampler", "getSpecularEnvSampler", "u_brdfLUT", "getBrdfTexture", "u_ScaleIBLAmbient", "u_ScaleDiffBaseMR", "u_ScaleFGDSpec", "defineIfPresent", "NORMAL", "TANGENT", "TEXCOORD_0", "parseMaterial", "value", "name", "parseTexture", "gltfTexture", "define", "texture", "sampler", "image", "source", "textureOptions", "specialTextureParameters", "compressed", "TEXTURE_MIN_FILTER", "data", "length", "LINEAR_MIPMAP_NEAREST", "LINEAR", "Texture2D", "id", "pixelStore", "UNPACK_FLIP_Y_WEBGL", "push", "parsePbrMetallicRoughness", "pbrMetallicRoughness", "baseColorTexture", "u_BaseColorFactor", "baseColorFactor", "metallicRoughnessTexture", "metallicFactor", "roughnessFactor", "pbr_uUnlit", "Boolean", "unlit", "normalTexture", "scale", "u_NormalScale", "occlusionTexture", "strength", "u_OcclusionStrength", "emissiveTexture", "u_EmissiveFactor", "emissiveFactor", "alphaMode", "alphaCutoff", "ALPHA_CUTOFF", "u_AlphaCutoff", "log", "warn", "Object", "assign", "blend", "blendEquation", "FUNC_ADD", "blendFunc", "SRC_ALPHA", "ONE_MINUS_SRC_ALPHA", "ONE", "delete", "forEach", "vs", "fs", "addVersionToShader", "gl", "source", "isWebGL2", "options", "id", "drawMode", "vertexCount", "attributes", "modelOptions", "materialParser", "GLTFMaterialParser", "log", "info", "defines", "managedResources", "push", "generatedTextures", "Object", "values", "map", "attribute", "buffer", "model", "ModelNode", "assign", "modules", "pbr", "parameters", "setProps", "setUniforms", "uniforms", "ATTRIBUTE_TYPE_TO_COMPONENTS", "SCALAR", "VEC2", "VEC3", "VEC4", "MAT2", "MAT3", "MAT4", "DEFAULT_OPTIONS", "modelOptions", "pbrDebug", "imageBasedLightingEnvironment", "lights", "useTangents", "GLTFInstantiator", "constructor", "gl", "options", "Object", "assign", "instantiate", "gltf", "scenes", "map", "scene", "createScene", "createAnimator", "Array", "isArray", "animations", "GLTFAnimator", "gltfScene", "gltfNodes", "nodes", "node", "createNode", "GroupNode", "id", "name", "children", "gltfNode", "_node", "gltfChildren", "child", "mesh", "push", "createMesh", "matrix", "setMatrix", "identity", "translation", "translate", "rotation", "rotationMatrix", "Matrix4", "fromQuaternion", "multiplyRight", "scale", "gltfMesh", "_mesh", "gltfPrimitives", "primitives", "gltfPrimitive", "i", "createPrimitive", "getVertexCount", "attributes", "log", "warn", "model", "createGLTFModel", "drawMode", "mode", "vertexCount", "indices", "count", "createAttributes", "material", "bounds", "POSITION", "min", "max", "loadedAttributes", "keys", "forEach", "attrName", "createAccessor", "createBuffer", "ARRAY_BUFFER", "ELEMENT_ARRAY_BUFFER", "info", "generated", "attribute", "target", "bufferView", "lumaBuffers", "Buffer", "data", "value", "accessor", "buffer", "Accessor", "offset", "byteOffset", "stride", "byteStride", "type", "componentType", "size", "createSampler", "gltfSampler", "needsPOT", "gl", "gltf", "options", "instantiator", "GLTFInstantiator", "scenes", "instantiate", "animator", "createAnimator", "PI_4", "Math", "PI", "DEGREES_TO_RADIANS_HALF", "waitForGLTFAssets", "gltfObjects", "remaining", "scenes", "forEach", "scene", "traverse", "model", "Object", "values", "getUniforms", "uniform", "loaded", "push", "waitWhileCondition", "some", "condition", "Promise", "resolve", "requestAnimationFrame", "DEFAULT_COLOR", "defaultProps", "scenegraph", "type", "value", "async", "getScene", "gltf", "scenes", "scene", "getAnimator", "animator", "_animations", "sizeScale", "min", "sizeMinPixels", "sizeMaxPixels", "Number", "MAX_SAFE_INTEGER", "getPosition", "x", "position", "getColor", "_lighting", "_imageBasedLightingEnvironment", "getOrientation", "getScale", "getTranslation", "getTransformMatrix", "loaders", "GLTFLoader", "ScenegraphLayer", "Layer", "getShaders", "modules", "project32", "picking", "props", "push", "pbr", "vs", "fs", "initializeState", "attributeManager", "getAttributeManager", "addInstanced", "instancePositions", "size", "fp64", "use64bitPositions", "accessor", "transition", "instanceColors", "colorFormat", "length", "normalized", "defaultValue", "instanceModelMatrix", "MATRIX_ATTRIBUTES", "updateState", "params", "oldProps", "_updateScenegraph", "_applyAnimationsProp", "state", "finalizeState", "context", "_deleteScenegraph", "gl", "scenegraphData", "ScenegraphNode", "gltfObjects", "createGLTFObjects", "_getModelOptions", "waitForGLTFAssets", "then", "setNeedsRedraw", "log", "deprecated", "options", "layer", "_applyAllAttributes", "setState", "warn", "attributesAvailable", "allAttributes", "getAttributes", "traverse", "model", "_setModelAttributes", "animationsProp", "animations", "getAnimations", "Object", "keys", "sort", "forEach", "key", "animation", "assign", "isFinite", "number", "findResult", "find", "name", "delete", "env", "waitForFullLoad", "imageBasedLightingEnvironment", "modelOptions", "isInstanced", "transpileToGLSL100", "isWebGL2", "useTangents", "updateAttributes", "changedAttributes", "draw", "moduleParameters", "parameters", "animate", "timeline", "getTime", "viewport", "opacity", "coordinateSystem", "numInstances", "getNumInstances", "worldMatrix", "setInstanceCount", "updateModuleSettings", "uniforms", "composeModelMatrix", "shouldComposeModelMatrix", "sceneModelMatrix", "u_Camera", "getUniforms", "project_uCameraPosition"]
}
